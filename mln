#!/usr/bin/perl
#
# This tool is meant to read a configuration file and to create
# a virtual network.
#
# For more info: mln.sourceforge.net
#
#
# kyrre.begnum@iu.hio.no
#

# Import
use Class::Struct;
use Getopt::Std;
use IO::File;
use strict "vars";

######### USER CONFIGURATION AREA ############

# Version:
our $VERSION = "1.0.8.8";

my $DEFAULT_TEMPLATE_VERSION = "1.1";
my $DEFAULT_COLLECT_TICKETS_SLEEP = 2;

# How many virtual machines do we build in one batch.
# http://mln.sourceforge.net/index.php?page=compile
my $BATCH_SIZE = 7;

# Change if you know of any other mirror closer to you.
# No trailing slash!
my $TEMPLATE_FILE_SITE   = "dl.sourceforge.net/sourceforge/mln";
my $TEMPLATE_FILE_MIRROR = "kent";

##############################################

struct(
    buildTicket => {
	ticket => '$',
	host => '$',
	port => '$',
	output => '$',
	sock => '$'
    }
);

struct(
    TemplateVersion => {
        major => '$',
        minor => '$'
    }
);

struct(
    CowFilesystem => {
        size     => '$',
        template => '$'
    }
);

struct(
    block => {
	name => '$',
	value => '%',
	array => '@',
	blocks => '%'
    }
);


# DEBUG VARIABLE
our $DEBUG    = 0;
my $SIMULATE = 0;

# Global variables

# we need a version this high or higher of the user-mode build template.
my $USER_BUILD_REQ_VERSION_MAJOR = "0";
my $USER_BUILD_REQ_VERSION_MINOR = "5";

# Defaults
my $SYS_CONF_DIR = "/etc/mln";
my $DEFAULT_FILE = "$SYS_CONF_DIR/mln.conf";    # Default name for config file
our %DEFAULTS;
$DEFAULTS{FILESYSTEM_SIZE} = "250M";
$DEFAULTS{MEMORY}          = "128M";    # Default memory for a virtual machine
$DEFAULTS{TERM_COMMAND}    =
  "xterm -bg black -fn fixed ";        # Default term command used
$DEFAULTS{COLOR}          = "lightgrey";
$DEFAULTS{TERM}           = "xterm";
$DEFAULTS{SCREEN_COMMAND} =
  "screen -d -m -S "
  ;    # if the vm is to start in the background, but attached to a screen
$DEFAULTS{TEMPLATE} =
  "Debian-4.0.ext3";    # Default template to use as a filesystem
$DEFAULTS{MAC_BASE}       = "fe:fd:0:0:";    # The base for all mac addressses
$DEFAULTS{MAC_BASE}       = "fe:fd:0:0:";    # The base for all mac addressses
$DEFAULTS{FAMILY}         = "debian";
$DEFAULTS{SERVICE_HOST}   = "";
$DEFAULTS{KERNEL}         = "linux";
# $DEFAULTS{KERNEL_VERSION} = "";
$DEFAULTS{MODULE_PATH} = "/usr/lib/uml/modules/";
$DEFAULTS{SLIRP_IF_ADDR} = "10.0.2.15";
$DEFAULTS{SLIRP_DNS}     = "10.0.2.3";
$DEFAULTS{PLUGIN_LOCATIONS}[0] = "/etc/mln/plugins";
$DEFAULTS{PLUGIN_LOCATIONS}[1] = $ENV{'HOME'} . "/.mln_plugins";
$DEFAULTS{PLUGIN_LOCATIONS}[2] = "/tmp/mln/plugins";
# $DEFAULTS{XEN_KERNEL} = "/boot/vmlinuz-2.6-xen";
$DEFAULTS{MLN_VG} = "mln-images";
$DEFAULTS{XEN_BRIDGE} = "xenbr0";
$DEFAULTS{SLIRP} = which('slirp');
$DEFAULTS{DAEMON_SOCKET} = 34001;
$DEFAULTS{BOOT_ORDER} = 99;
$DEFAULTS{CPUHOG} = 0.3;
$DEFAULTS{LOCK_TIMEOUT} = 60;

chomp $DEFAULTS{SLIRP};

# my $DEFAULT_KERNEL = "linux";
# my $DEFAULT_KERNEL_VERSION = `$DEFAULT_KERNEL --version`;
# chomp $DEFAULT_KERNEL_VERSION;

################################
# GLOBAL VARIABLES FOR XENGUARD
#
my %xenhosts;
my %host_info;
my %chunks;
my @chunk_list;
my %all_vms;
my $mln_files_dir;
my $mln;
my $host_cpu_utilisation_low;
my $host_cpu_utilisation_high;
my %chunked_hosts;
my %tried_placements;

#
################################

# GLOBAL VARIABLES WHICH ARE NOT SUBJECT TO CHANGE

my @XML_DOC;
our $IMAGEDIR;
my $IMAGEDIR_NAME = "images";    # name of the directory with all images
my $NETDIR;
my %HOST_INFO;
my %PROJECT_INFO;
my %LAST_HOST_INFO;
my %LAST_PROJECT_INFO;
my @PROJECT_CHUNKS;
my $NETDIR_NAME  = "network";           # where to put the network sockets
my $START_SCRIPT = "start";             # the name of the start script
my $STOP_SCRIPT  = "stop__network.sh";  # the name of the stop script
my $SWAP_PREFIX  = "swap_";
our $MOUNTDIR     = "/tmp/mln-mnt";      # need this for temporary mounting
our $TEMPLATEDIR  = "templates";         # this is where we put all the templates
my $PIDDIR;
my $PIDDIR_NAME = "uml_dir";            # The place to put the umid files
my $SCREEN_PATH = "/usr/bin/screen";
our $FILES_PATH  = "files";
our $PROJECT     = "";                   # The name of the project.
my $LOCAL     = "yes";    # we do not try the shipping kernel by default.
my $USER_MODE = "";       # We assume root
my $USER_MODE_COPY_FS       = "Debian-3.0r0.ext2";
my $CONFIG_FILE_NAME        = ".mln";
our $PROJECT_PATH            = "";
my $UML_PATH                = "";
my $USER_MODE_TEMP_DIR      = "$ENV{'HOME'}/.mln_user_mode_build";
my $UPGRADE_CANDIDATES_FILE = "/tmp/mln/diff.mln";
my $MODULESDIR              =  "/tmp/mln/modules/";  # where to find kernel modules (when in user-build mode)
my $COW_MOUNT_DIR            = "/tmp/mln/mount";
my $MLN_MISC_BASE            = "/tmp/mln";
my $KERNEL_VERSION_LOOKUP    = "kernel_versions";
my $UML_KERNEL_PACKAGE       = "uml-2.6.12-rc2-mm3.tar.gz";
my $UML_DOWNLOAD_PATH        = "http://mln.sourceforge.net/files/";
my $GLOBAL_USER_PREFIX       = "/opt/mln";
my $SINGLE_USER_UML_DIR      = "$ENV{HOME}/mln/uml";
my $GLOBAL_USER_UML_DIR      = "uml";
my $SINGLE_USER_PROJECT_DIR  = "$ENV{HOME}/mln/projects";
my $GLOBAL_USER_PROJECT_DIR  = 'projects/$USER';
my $SINGLE_USER_TEMPLATE_DIR = "$ENV{HOME}/mln/templates";
my $GLOBAL_USER_TEMPLATE_DIR = "templates";
my $SINGLE_USER_FILES_DIR    = "$ENV{HOME}/mln/files";
my $GLOBAL_USER_FILES_DIR    = "files";
my $XEN_SAVE_FILE = "";
my $MLN_LOCKFILE = "/var/lock/mln_lockfile";
my $NO_UML_BUILD;
my $NO_UML_MOUNTDIR = "$ENV{HOME}/.mln_mountdir";
my @IFCONFIG_CACHE;
my $CONFIGFILE;
my $HOST_COUNTER;
my $REMOVE;
my $ADD;
my $UPGRADE            = 0;
my $UPGRADE_CANDIDATES = 0;
my $RESTART_UPGRADED   = 0;
my $KEEP_OLD           = 0;
our $SERVICE_HOST       = "";
our $VERBOSE            = 0;
my $COLORS             = 0;
my @CONFIGFILE_TRANSCRIPT;
my $USER_MODE_REC        = 0;
my $CONFIGURE_HOSTS_ONLY = 0;
my @MODULE_DIRS;
my $UMID_DIR = $PIDDIR;    # The place to put the umid files
my %KERNEL_VERSION_TABLE;
my %NOTIFICATION;
my $BATCH_NUMBER;
my $HOSTLIST;
my $MOUNT_OFFSET           = 16;
my $HOST_COUNTER           = 0;
my $SUPERCLASS_COUNTER     = 0;
my $STDIN_MODE             = 0;
my @CONFIG_FILE_TRANSCRIPT = ();
my @PARSE_STACK            = ();
my @SOCKET_HOLDER;
my $CURRENT_INPUT;
my $GLOBAL_OUTPUT;
my @INPUT_STACK = ();
my $INPUT_STACK_COUNTER;
my @INPUT_FILES = ();
my $MAIN_FILE_OPENED;
our $QUIET;
our %GLOBAL_VARIABLES;
my $SPAWNED_REMOTELY;
our $data_temp;
our %BACKUP;
my @PENDING_TICKETS;
my %CLIENT_TICKETS;
my $TEMPLATE_LIST_SITE = "http://mln.sourceforge.net/templates";
my $TEMPLATE_LIST_FILE = "templates.list";
my %MIGRATION_DATA;
my %PUSH_TARGETS;
my %DOWN_SERVERS;
my @ALLOWED_DAEMONS;
my @DAEMON_STATUS_QUERY_HOSTS;
my %IFCONFIG_NETFLOW;
my %VBD_ACTIVITY;
my %RESOURCE_TABLE;
my %RESOURCE_DELAY_TABLE;
my @DEVICE_MAPPING_CACHE;
my %NETWORK_TABLE;
my %LOCATION_CONFLICT_TABLE;
my @STATUS_ARRAY;
my %SAN_PATH;
my %LIVE_LIST;
# this is where the entire data is supposed to be stored.
our $DATA_ROOT;
our $OLD_DATA_ROOT;
our $DIFF;
our $DATA_BACKUP;
our $RECONFIGURE;
our $RECONFIGURE_REBUILD;
our @RECONFIGURE_HOST_LIST;
our %LVM_EXECUTE_SERVER;

# Global variables
my @HOSTS_FILE_COMMON = (
    "127.0.0.1	localhost",
    "::1     ip6-localhost ip6-loopback",
    "fe00::0 ip6-localnet",
    "ff00::0 ip6-mcastprefix",
    "ff02::1 ip6-allnodes",
    "ff02::2 ip6-allrouters",
    "ff02::3 ip6-allhosts"
);

my $DAEMON_USED_MEMORY;
my $NUM_RUNNING_PROJECTS;
my $NUM_RUNNING_HOSTS;
my %DAEMON_GROUP_INDEX;
my @HOSTS_FILE      = ();
my @HOST2ROLE_FILE  = ();
my $MAC_COUNTER     = 0;
my $COW_COUNTER     = 0;
my $BATCH_COUNTER   = 1;
my %USED_VARIABLES  = ();
my %LOCAL_TEMPLATES = ();
my %COW_FILESYSTEMS = ();
my %RESTART_ME = ();
my $CLIENT_TICKET_FOLDER = "/tmp/mln-tickets";
my $DAEMON_MAX_MEMORY;
my %DAEMON_GROUPS;
my %XM_LIST_RESULT;
my @XM_LIST_CACHE;
my $STATUS_MAX_VM_NAME_LENGTH;
my $CHECK_PERSISTENT_HINT = "/tmp/mln_check_persistent";
my $CHECK_PERSISTENT_FILE = "/etc/mln/admin";
our $CURRENT_HOSTNAME;

# Used to save the data-structure
# my %SUPERCLASSES = ();
my %HOSTS    = ();
my %SWITCHES = ();
my $GLOBAL;
my %UPGRADE_LIST = ();

# These are used to determine Linux distributions

my $DEBIAN_HINT = "/etc/network/interfaces";
my $REDHAT_HINT = "/etc/sysconfig/network-scripts";
my $BUSYBOX_HINT = "/bin/busybox";
my $WINDOWS_HINT = "/boot.ini";
my $SUSE_HINT = "/etc/suseRegister.conf";

# we use these if we wish to generate a data structure from the old project


my $homedir;
my $user;

our %PLUGIN_LIST = ();

my @HOST_SCALAR_KEYWORDS = (
    "free_space", "nice",  "template",   "term",   "size",       "swap",
    "type",       "owner", "group",      "sudo",   "superclass", "memory",
    "nameserver", "color", "boot_order", "kernel", "modules_dir", "xen", "lvm"
);
my @HOST_BLOCK_KEYWORDS   = ( "modules", "roles",   "startup" );
my @HOST_SPECIAL_KEYWORDS = ( "files",   "network", "user", "dyndns", "mount" );

# All commands used by this script:
our %shell;
$shell{"DD"}        = "/bin/dd";
$shell{"FSCK"}      = "/sbin/e2fsck";
$shell{"MKFS"}      = "/sbin/mkfs.ext2";
$shell{"MOUNT"}     = "/bin/mount";
$shell{"UMOUNT"}    = "/bin/umount";
$shell{"RESIZE2FS"} = "/sbin/resize2fs";
$shell{"CP"}        = "/bin/cp";
$shell{"MV"}        = "/bin/mv";
$shell{"CHROOT"}    = "/usr/sbin/chroot";
$shell{"CHMOD"}     = "/bin/chmod";
$shell{"CHOWN"}     = "/bin/chown";
$shell{"MKDIR"}     = "/bin/mkdir";
$shell{"TAR"}       = "/bin/tar";
$shell{'LN'}        = "/bin/ln";
$shell{'IFCONFIG'}  = "/sbin/ifconfig";
$shell{"ECHO"}      = "/bin/echo";
$shell{'ROUTE'}     = '/sbin/route';
$shell{'RM'}        = '/bin/rm';
$shell{'FIND'}      = '/usr/bin/find';
$shell{'MKCOW'}     = '/usr/bin/uml_mkcow';
$shell{'MKSWAP'}    = '/sbin/mkswap';
$shell{'TUNE2FS'}   = '/sbin/tune2fs';
$shell{'WGET'}      = "/usr/bin/wget";
$shell{'LVCREATE'} = `which lvcreate`; chomp $shell{'LVCREATE'};
$shell{'LVREMOVE'} = `which lvremove`; chomp $shell{'LVREMOVE'};
$shell{'LVRESIZE'} = `which lvresize`; chomp $shell{'LVRESIZE'};
$shell{'XM'}       = "/usr/sbin/xm";
# If you don't want to use the binaries that came
# with the package then change these settings

$shell{"UML_SWITCH"} = which('uml_switch');
chomp $shell{"UML_SWITCH"};
$shell{"TUNCTL"} = which('tunctl');
chomp $shell{"TUNCTL"};
$shell{"UML_MCONSOLE"} = which('uml_mconsole');
chomp $shell{"UML_MCONSOLE"};

#####################################################################
# Looking for a local configuration file
# and getting a list of all available templates
#########################################

initializeConfig();
findLocalTemplates();

####################################################################
# We find and include all the plugins
####################################################################
findPlugins();

foreach (keys %PLUGIN_LIST ){
    my $file = $PLUGIN_LIST{$_};
    verbose("including $_ -> $PLUGIN_LIST{$_}\n");
    require "$file";
}


#####################################################################

if ( $ARGV[0] =~ /download_templates/ ) {
    shift @ARGV;
    downloadTemplates();
    exit;
}
elsif ( $ARGV[0] =~ /write_config/ ) {
    writeConfig();
    exit;
}
elsif ( $ARGV[0] =~ /setup/ ) {
    shift @ARGV;
    setupMLN();
    exit;
}elsif ( $ARGV[0] =~ /setScalar/ ) {
    shift @ARGV;
    commandSetScalar();
    exit;
}
elsif ( $ARGV[0] =~ /^status$/ ) {
    shift @ARGV;
    printStatus();
    exit;
}elsif ( $ARGV[0] =~ /^console$/ ) {
    shift @ARGV;
    startMlnConsole();
    exit;
}
elsif ( $ARGV[0] =~ /enable_bridge/ ) {
    shift @ARGV;
    setupBridge();
    exit;
}
elsif ( $ARGV[0] =~ /disable_bridge/ ) {
    shift @ARGV;
    disableBridge();
    exit;
}
elsif ( $ARGV[0] =~ /clean_filesystems/ ) {
    shift @ARGV;
    cleanCowFilesystems();
    exit;
} elsif ( $ARGV[0] =~ /^export|save$/ ) {
    shift @ARGV;
    exportMLNproject();
    exit;       
}
elsif ( $ARGV[0] =~ /^start$/ ) {
    shift @ARGV;
    startProjectHandler();
    exit;
} elsif ( $ARGV[0] =~ /^daemon_status$/ ) {
    shift @ARGV;
    showDaemonStatus();
    exit;
}
elsif ( $ARGV[0] =~ /^remove$/ ) {
    shift @ARGV;
    removeProject( );
    exit;
}
elsif ( $ARGV[0] =~ /^check_persistent$/ ) {
    shift @ARGV;
    monitorPersistentHandler();
    exit;
}
elsif ( $ARGV[0] =~ /^set_persistent$/ ) {
    shift @ARGV;
    setPersistentHandler();
    exit;
}
elsif ( $ARGV[0] =~ /^monitor$/ ) {
    monitorXen();
    exit;
}
elsif ( $ARGV[0] =~ /^stop$/ ) {
    shift @ARGV;
    stopProjectHandler();
    exit;
}
elsif ( $ARGV[0] =~ /^clean$/ ) {
    shift @ARGV;
    cleanUpProject();
    exit;
}
elsif ( $ARGV[0] =~ /^client$/ ) {
    shift @ARGV;
    doOnRemote();
    exit;
} elsif ( $ARGV[0] =~ /^xenguard$/ ) {
    shift @ARGV;
    xenguard();
    exit;
} 
elsif ( $ARGV[0] =~ /^diff$/ ) {
    shift @ARGV;
    commandDiff();
    exit;
}elsif ( $ARGV[0] =~ /^(help|usage)$/ ) {
    shift @ARGV;
    printUsage();
    exit;
}
elsif ( $ARGV[0] =~ /^list$/ ) {
    shift @ARGV;
    listProjects();
    exit;
}
elsif ( $ARGV[0] =~ /version/ ) {
    printVersion();
    exit;
}
elsif ( $ARGV[0] =~ /^list_templates$/ ) {
    listTemplates();
    exit;
}
elsif ( $ARGV[0] =~ /^xml$/ ) {
    shift @ARGV;
    mln2xml();
    exit;
}
elsif ( $ARGV[0] =~ /^import$/ ) {
    shift @ARGV;
    importMLNprojectHandler();
    exit;
}
elsif ( $ARGV[0] =~ /^daemon$/ ) {
    shift @ARGV;
    runDaemon();
    exit;
}
elsif ( $ARGV[0] =~ /^parse$/ ) {
    shift @ARGV;
    parseMLN();
    exit;
}
elsif ( $ARGV[0] =~ /^build$/ ) {

    buildMLNprojectHandler();
    exit;
}elsif ( $ARGV[0] =~ /^lupgrade$/ ) {

    upgradeMLNprojectHandler();
    exit;
}
elsif ( $ARGV[0] =~ /^register_template$/ or $ARGV[0] =~ /^rt$/ ) {
    shift @ARGV;
    registerTemplate();
    exit;
} elsif ( $ARGV[0] =~ /^check_remote_daemon$/ ) {
    shift @ARGV;
    checkRemoteDaemonHandler();
    exit;
} elsif ( $ARGV[0] =~ /^check_cpuhogs$/ ) {
    shift @ARGV;
    checkCpuHogHandler();
    exit;
}
elsif ( $ARGV[0] =~ /^build$/ or $ARGV[0] =~ /^upgrade$/ or $ARGV[0] eq "reconfigure" or $ARGV[0] eq "rc" ) {
    $UPGRADE = 1 if $ARGV[0] =~ /upgrade/;
    $RECONFIGURE = 1 if ( $ARGV[0] eq "reconfigure" or $ARGV[0] eq "rc" );


    if ( $ARGV[0] =~ /^build$/ and $ENV{USER} eq "root" ){
#	print "switching to newer build process.\n";
	buildMLNprojectHandler();
	exit;
    }
    if ( $ARGV[0] =~ /^reconfigure$/ and $ENV{USER} eq "root" ){
#	print "switching to newer build process.\n";
	reconfigureMLNprojectHandler();
	exit;
    }
    
    if ( $ARGV[0] =~ /^upgrade$/ and $ENV{USER} eq "root" ){
	upgradeMLNprojectHandler();
	exit;
    }

    shift @ARGV;

    
    
    # UPGRADE iS CURRENTLY DISABLED:
    
    my $opt_string = 'p:h:b:BCvkarsSducf:l:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

#    usage() and die "ERROR: You must supply a config file: build -f <config-file>\n" unless $opt{f};
    $DEBUG            = 1 if $opt{d};
    $SIMULATE         = 1 if $opt{s};
    $REMOVE           = 1 if $opt{r};
    $ADD              = 1 if $opt{a};
    $RESTART_UPGRADED = 1 if $opt{S};
    $KEEP_OLD         = 1 if $opt{k};
    $VERBOSE          = 1 if $opt{v};
    $COLORS           = 1 if $opt{c};
    $RECONFIGURE_REBUILD = 1 if $opt{B};
    
    if ( $opt{l} ){
	foreach (split /:/,$opt{l}){
	    print "registering $_ as a LIVE host\n";
	    $LIVE_LIST{$_} = 1;
	}
    }
    
    if ( $RECONFIGURE ){
#	print "Reconfigure enabled\n";
	print "You must at least supply -p project_name if you reconfigure\n" and exit 1 unless $opt{p};
	if ( $opt{h} ){
	    foreach (split /:/,$opt{h}){
		push (@RECONFIGURE_HOST_LIST,$_);
	    }
	}	
    }
    #      obsolete as of 0.71
    #      $USER_MODE = 1 and print "Enabling user-mode copy\n" if $opt{u};

    #  as of 0.73 user-mode building is on by default.
    $USER_MODE_REC = 1;
    $USER_MODE_REC = 0 if $opt{u};

    if ( $opt{C} ) {
        $CONFIGURE_HOSTS_ONLY = 1;
        $USER_MODE_REC        = 0;
        $BATCH_NUMBER         = $opt{b};
        $HOSTLIST             = $opt{h};
        readKernelVersions();
    }

    if ( not $CONFIGURE_HOSTS_ONLY ) {
        if ( not stat($FILES_PATH) ) {
            die "you don't have access to $FILES_PATH. please re-configure mln";
        }
        if ( not stat($TEMPLATEDIR) ) {
            die
              "you don't have access to $TEMPLATEDIR. please re-configure mln";
        }
        if ( not stat($PROJECT_PATH) ) {
            die
              "you don't have access to $PROJECT_PATH. please re-configure mln";
        }

    }

    if ( $opt{f} ) {
        $CONFIGFILE = $opt{f};
        die "ERROR: The configuration file must always end with the suffix .mln"
          unless $CONFIGFILE =~ /(\.mln$)/;
    } elsif ($RECONFIGURE){
	$CONFIGFILE = "$PROJECT_PATH/$opt{p}/$opt{p}.mln";
#		print "reading old projects conf-file: $CONFIGFILE\n";
    }
    else {
        # we are reading from STDIN
        out("No file supplied, Reading from SDTIN.\n");
        $STDIN_MODE = 1;
    }

    if ( not $USER_MODE ) {
        mkdir("$MOUNTDIR");
    }

    # generate a random number to store user-mode-build files
    if ($USER_MODE_REC) {

        if ( not stat("$USER_MODE_TEMP_DIR") ) {
            mkdir("$USER_MODE_TEMP_DIR")
              or die "Failed to create $USER_MODE_TEMP_DIR. I'm dying.\n";
        }
        $USER_MODE_TEMP_DIR = $USER_MODE_TEMP_DIR . "/" . int( rand(1000) );
    }

    # Nullify some global variables
    my @hosts;    # All hostnames are stored here

#################################################################

    $DATA_ROOT =  buildDataTree($CONFIGFILE);

    buildGlobalConfig();

    assignHostsToSwitches();

    # we run all the plugins postParse-phase. 
    runPostParsePlugins();

#######################
    #

    checkKernels();

    if ($UPGRADE) {

	$OLD_DATA_ROOT =  buildDataTree("$PROJECT_PATH/$PROJECT/$PROJECT.mln");

#	printBlock($OLD_DATA_ROOT);
	$DIFF = getDiff($OLD_DATA_ROOT,$DATA_ROOT);
    }
    else {
#	print "getImages\n";
        getImages();
    }

    if ( not $CONFIGURE_HOSTS_ONLY ) {
	if ( not $SPAWNED_REMOTELY ){
	    printNetwork();
	    printHosts();
	    printGlobal();
	}
        checkCowFilesystems();

        checkTemplates();
    }

#####################
    #
    # This is where I check for the sanity of the configuration
    #
    
    if ( $UPGRADE and not $CONFIGURE_HOSTS_ONLY and not $SPAWNED_REMOTELY ) {
        print "\n+---> Upgrade Info: \n";

        if ( not keys %{$DIFF->value} and not keys %{$DIFF->blocks} ) {
            print "No hosts needed to be rebuildt\n";
            exit;
        }
        else {
            print " The Following Diff has been calculated\n";
            my @uc;
            my $key;
	    printBlock($DIFF);
        }

        my $key;
        my $hosts_will_be_removed;
        foreach $key ( getHosts($OLD_DATA_ROOT) ) {
            if ( not getScalar("/host/$key")) {
                if ( not $hosts_will_be_removed ) {
                    print "\n The following hosts will be removed: \n";
                    $hosts_will_be_removed = 1;
                }
                print "$key\n";
            }
        }
        if ( not $hosts_will_be_removed ) {
            print "\nNo hosts will be removed\n";

        }


	my $amountTested = 0;
	my $amountOK;
	my @return;       
	out("Collecting Status information for $PROJECT\n");
	($amountTested,$amountOK,@return) 
	  = getStatus($PROJECT,"",1,0,$QUIET,0,not $SPAWNED_REMOTELY);
#	print "at: $amountTested, hosts: " . getHosts($OLD_DATA_ROOT) . " switches " . getBlockKeys("/switch",$OLD_DATA_ROOT) . "\n";
	if ( $amountTested != getHosts($OLD_DATA_ROOT) ) {
	    foreach $key ( getHosts($OLD_DATA_ROOT) ){
		if ( not grep(/host $key /,@return)){
		    out("Could not verify the status of $key at " . getScalar("/host/$key/service_host",$OLD_DATA_ROOT)."\n","red");
		}
	    }
	    
	    out("\nFATAL: One or more hosts in this project could not be verified.\nThis might be that the MLN daemon is not running on the service_host,\nor that the project does not exist on it.\nUse the -r opion to override if you really want to continue.\n","red");
	    exit (1) unless $REMOVE;
	}
	my $warning;
	foreach $key ( getHosts($DIFF) ) {
	    my $old_sh = getScalar("/host/$key/service_host",$OLD_DATA_ROOT);	    

	    my $new_sh = getScalar("/host/$key/service_host",$DIFF);
#	    print "checking $key ( $old_sh , $new_sh )\n";
	    if ( not $old_sh and $SERVICE_HOST ){
		$old_sh = $SERVICE_HOST;
	    }
	    if ( $new_sh and $old_sh ne $new_sh ){
#		out("- $key will migrate from $old_sh to $new_sh\n");
		
		if ( not daemonIsRunning($new_sh) ){
		    $warning = 1;
		    out("Could not make contact with MLN daemon at $new_sh\n","red");
		}
	    }	    
	}
	if ( $warning ){
	    out("\nFATAL: One or more MLN daemons could not be verified on remote servers.\nThis might be that the MLN daemon is not running on the service_host,\nor that it does not allow connection from this host.\nUse the -r opion to override if you really want to continue.\n","red");
	    exit (1) unless $REMOVE;
	}
	
#	print "before checkIfAnyAreUp()\n";
	    # Just to be sure, I'll check if the host is really down, before we thrash it
	
	

    	
        if ( not $SIMULATE and not $REMOVE ) {
            print "\nAre you sure you want to continue? (y/N)\n";
            my $answer = <STDIN>;
            if ( not $answer =~ /^([yY]|yes)/ ) {
                exit;
            }
        }
    }
    
    checkForUserModeCopy();

    createHostsFile();
    print "\nParsing complete\n" and exit if $SIMULATE;
#####################
    # Here I do tha actual building or upgrading.

    if ($UPGRADE) {

        if ($USER_MODE_REC) {
            out( "+---> UPGRADING $PROJECT \n", "green" );
	    # stopHosts();
        }
        elsif ($CONFIGURE_HOSTS_ONLY) {
            #	    	out ("\n\n+---> UPGRADING $PROJECT - PHASE 2 \n","green");
        }

	if ( $USER_MODE_REC ){
	    startRemoteBuilds("upgrade");
	    buildNetwork();
	}

        upgradeHosts();


        if ($USER_MODE_REC) {

	    writeExtraScripts();
            prepareForUserModeBuild();
            registerUpgradeCandidates();
            userModeConfigure();
	    out("- Done\n","green");
	    startHosts();
	    removeOldSwitches();
	    removeOldHosts();
	}
        if ($CONFIGURE_HOSTS_ONLY) {


        }
        else {
	    saveConfig();	    
	    collectTickets();
	    if ( not $SPAWNED_REMOTELY ){
		out( "+---> UPGRADING $PROJECT FINISHED \n", "green" ); 
#		print "\n\n";
	    }
        }

    }
    else {
#	print "before getStatus\n";
	my $amountTested;
	my $amountOK;
	my @return;

#	print "before checkIfAnyAreUp()\n";
   # Just to be sure, I'll check if the host is really down, before we thrash it
	# print "$PROJECT_PATH/$PROJECT/${PROJECT}.mln and $USER_MODE_REC\n";
	if ( stat("$PROJECT_PATH/$PROJECT/${PROJECT}.mln") and $USER_MODE_REC ){
	    $OLD_DATA_ROOT = buildDataTree("$PROJECT_PATH/$PROJECT/${PROJECT}.mln");
	    if ( isDistributed($OLD_DATA_ROOT) ){
		out("Collecting Status information for $PROJECT\n");
		if ( not $RECONFIGURE  ) {
		    ($amountTested,$amountOK,@return) 
		      = getStatus($PROJECT,"",1,0,$QUIET,0,not $SPAWNED_REMOTELY);
		    if ( $amountOK > 0 ){
			out(
			    "DANGER: A host in this project is still up!\nYou probarbly want to upgrade instead.\n",
			    "red"
			);
			exit 1;
		    } 
		    
		    if ( $amountTested != getHosts($OLD_DATA_ROOT) and not $SPAWNED_REMOTELY){
#		print "at: $amountTested, " . getHosts($OLD_DATA_ROOT) ."\n";
			my $key;
			foreach $key ( getHosts($OLD_DATA_ROOT) ){
			    if ( not grep(/host $key /,@return)){
				out("Could not verify the status of $key at " . getScalar("/host/$key/service_host",$OLD_DATA_ROOT)."\n","red");
			    }
			}
			out(
			    "\nDANGER: All service hosts did not respond to the status query,\nit is not safe to continue.\nUse the -r option to override.\n",
			    "red"
			);
			exit 1 unless $REMOVE;
		    }
		}
	    }
	}
	if ( $USER_MODE_REC and isDistributed() ){
	    out("Checking if all MLN daemons are running on new service hosts\n");
	    
	    my $key;
	    my $warning;
	    foreach $key ( getHosts($DATA_ROOT) ){
		my $sh = getScalar("/host/$key/service_host",$DATA_ROOT);
		my $old_sh = getScalar("/host/$key/service_host",$OLD_DATA_ROOT);
#		print "sh: $sh, old: $old_sh\n";
		if ( $sh ne $old_sh ){
		    if ( not daemonIsRunning($sh) ){		
			out("Could not verify the status of $key at $sh\n","red");
			$warning = 1;
		    }
		}
	    }
	    if ( $warning ){
		out("\nDANGER: Some service hosts where this project is supposed to be buildt did not\nanswer. Either the host is down or the MLN daemon is not running on it. It is\nnot safe to continue.\nUse the -r option to override\n","red");
		exit 1 unless $REMOVE;
	    }
	}
	
        if ($USER_MODE_REC) {
	    if ( $RECONFIGURE ){
		out( "+---> RECONFIGURING $PROJECT\n", "green" ) unless $SPAWNED_REMOTELY;
	    } else {
		out( "+---> BUILDING $PROJECT\n", "green" ) unless $SPAWNED_REMOTELY;
	    }
        }
        elsif ($CONFIGURE_HOSTS_ONLY) {

            #	    	out ("\n\n+---> BUILDING $PROJECT - PHASE 2 \n","green");
        }
        else {

            #	out( "\n\n########### BUILDING $PROJECT #########\n", "green");

        }

        checkIfExists() unless $RECONFIGURE; 

        if ($USER_MODE_REC) {
            prepareForUserModeBuild();
        }

        if ( not $CONFIGURE_HOSTS_ONLY ) {
	    verifyDirectories("$PROJECT_PATH/$PROJECT",$IMAGEDIR,$NETDIR,$PIDDIR);
#            mkdir("$PROJECT_PATH/$PROJECT");
#            mkdir($IMAGEDIR);
#            mkdir($NETDIR);
#            mkdir($PIDDIR);
            # This is not the most secure solution. I would prefer
            # one folder for each switch, and the folder should be owned
            # by group and/or user
            system("$shell{'CHMOD'} 777 $NETDIR");
	    saveConfig();

	    if ( not $SPAWNED_REMOTELY ){ 
#		print "I SHOULD NOT BE REMOTELY SPAWNED!\n";
		if ( $USER_MODE_REC and $RECONFIGURE_REBUILD ){
		    startRemoteBuilds("reconfigure_rebuild");
		} elsif ( $USER_MODE_REC and $RECONFIGURE ){
		    startRemoteBuilds("reconfigure");
		} elsif ( $USER_MODE_REC ) {
		    startRemoteBuilds("build");
		}
	    }
            buildNetwork();
	    if ( $RECONFIGURE ){
		prepareForReconfig();
	    }

            buildHosts();
	    writeExtraScripts();
            if ($USER_MODE_REC) {
                userModeConfigure();
                cleanUpUserModeBuild();
            }
	    collectTickets();

	    startReconfiguredHosts();
	    if ( not $SPAWNED_REMOTELY ){
		out( "+---> PROJECT $PROJECT FINISHED \n", "green" );

#		my $num_hosts = $#{getHosts()};
#		print "Number of hosts configured: $num_hosts \n";
#		print "\n";
	    }
            exit;
        }
        else {
            
	    buildHosts();

           #	    out ("\n+---> BUILDING $PROJECT - PHASE 2 FINISHED\n","green");
            out( "+---> SHUTTING DOWN VIRTUAL MACHINE\n", "green" );
        }
    }

    if ($USER_MODE_REC) {
        cleanUpUserModeBuild();
    }

}
elsif ( $ARGV[0] eq "--help" or $ARGV[0] eq "-h" ) {

    usage();

}
else {

    usage();

}


#######################
#
# SUBROUTINES:
########################

# locking:

# set a lock in the locking dir
# - in the start script
# - check if directory is present
# - remove lock when shut down ( only if shutdown was successful )
# - create option to remove locks
# - set locking dir in mln.conf


#####################################
# Make sure the directories are present, if not, create them
######################################################

sub verifyDirectories {
    foreach ( @_ ){
	if ( not stat($_)){
	    system("mkdir -p $_"); 
	}
    }
}

sub upgradeMLNprojectHandler {
    shift @ARGV;
    $UPGRADE = 1;

    my %opt;
    # UPGRADE iS CURRENTLY DISABLED:
    my $opt_string = 'p:h:b:CvkarsSducf:l:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

#    usage() and die "ERROR: You must supply a config file: build -f <config-file>\n" unless $opt{f};
    $DEBUG            = 1 if $opt{d};
    $SIMULATE         = 1 if $opt{s};
    $REMOVE           = 1 if $opt{r};
    $ADD              = 1 if $opt{a};
    $RESTART_UPGRADED = 1 if $opt{S};
    $KEEP_OLD         = 1 if $opt{k};
    $VERBOSE          = 1 if $opt{v};
    $COLORS           = 1 if $opt{c};
    
    if ( $opt{l} ){
	foreach (split /:/,$opt{l}){
	    out("registering $_ as a LIVE host\n");
	    $LIVE_LIST{$_} = 1;
	}
    }
    
    # upgradeMLNproject:
    #                   file, live_list, 
#    print "upgradeMLNproject($opt{'f'},$opt{l},$REMOVE,$VERBOSE,$DEBUG,$opt{s},$SPAWNED_REMOTELY)";
#    out("upgradeMLNproject($opt{'f'},$opt{l},$REMOVE,$VERBOSE,$DEBUG,$opt{s},$SPAWNED_REMOTELY)");
    # upgradeMLNproject(s1.mln,,,0,0,,)
#                         0        1      2       3         4      5            6         7  
    upgradeMLNproject($opt{'f'},$opt{l},$REMOVE,$VERBOSE,$DEBUG,$opt{s},$SPAWNED_REMOTELY,0);
}

sub upgradeMLNproject {
    
# this one is dearly needed. :)
    
    $UPGRADE = 1;    
    $SPAWNED_REMOTELY = $_[6];
    # if ( $SPAWNED_REMOTELY){
    # 	print "SPAWNED REMOTELY IS ACTIVATED\n";
    # } else {
    # 	print "SPAWNED REMOTELY IS DE-ACTIVATED\n";
    # }
    
    if ( $_[1] ){
	foreach (split /:/,$_[1]){
#	    out("registering $_ as a LIVE host\n");
	    $LIVE_LIST{$_} = 1;
	}
    }        
    $CONFIGFILE = $_[0];
    $DATA_ROOT =  buildDataTree($CONFIGFILE);

    $REMOVE = 1 if $_[2];

    out("building global config ($CONFIGFILE)\n");
    buildGlobalConfig();
#    print "assigning hosts to switches\n";
    assignHostsToSwitches();
#    print "running PostParsePlugins\n";
    # we run all the plugins postParse-bphase. 
    runPostParsePlugins();
    my $project_version = $_[7];
    $project_version = (getProjectVersion($PROJECT) + 1)  unless $project_version;

    out("fetching old config: $PROJECT_PATH/$PROJECT/$PROJECT.mln\n");
#    system ("ls $PROJECT_PATH/$PROJECT/");
#    system ("cat $PROJECT_PATH/$PROJECT/$PROJECT.mln");

    $OLD_DATA_ROOT = buildDataTree("$PROJECT_PATH/$PROJECT/$PROJECT.mln");

    $DIFF = getDiff($OLD_DATA_ROOT,$DATA_ROOT);
    if ( not $CONFIGURE_HOSTS_ONLY and not $_[6] ) {
        out("\n+---> Upgrade Info: \n");
	out("Attempting upgrade to version $project_version\n");

        if ( not keys %{$DIFF->value} and not keys %{$DIFF->blocks} ) {
            out("No hosts needed to be rebuildt\n");
#            return;
        }
        else {
            out("The Following Diff has been calculated\n");
            my @uc;
            my $key;
	    printBlock($DIFF);
        }

        my $key;
        my $hosts_will_be_removed;
        foreach $key ( getHosts($OLD_DATA_ROOT) ) {
            if ( not getScalar("/host/$key")) {
                if ( not $hosts_will_be_removed ) {
                    out("\n The following hosts will be removed: \n");
                    $hosts_will_be_removed = 1;
                }
                out("$key\n");
            }
        }
        if ( not $hosts_will_be_removed ) {
            out("\nNo hosts will be removed\n");
        }
	
	if ( $SIMULATE ){
	    out("Simulation only, exiting\n");
	    exit;
	}

	out( "+---> UPGRADING $PROJECT \n", "green" );
                # stopHosts();
	
#	if ( not $REMOVE ){

	checkMLNstatus();


#	}
	startRemoteBuilds("upgrade",$project_version);

    }
    
#    if (  $_[6] ){
#	print "local configuration activated\n";
    buildNetwork();
    @XM_LIST_CACHE = ();	
    upgradeMLNHosts();
    
#    writeExtraScripts();

#    prepareForUserModeBuild();
#    registerUpgradeCandidates();
#    userModeConfigure();
#    }
    writeExtraScripts();
    collectTickets();
    out("Done\n","green");
    saveConfig();
    setProjectVersion($PROJECT,$project_version);
    startHosts();
    removeOldSwitches();
    removeOldHosts();    
}

sub buildMLNprojectHandler {
    shift @ARGV;

    $RECONFIGURE = 1 if ( $ARGV[1] eq "reconfigure" or $ARGV[1] eq "rc" );


    my $opt_string = 'p:h:b:BCvkarsSducf:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
#    print "file is $opt{f}\n";
#    usage() and die "ERROR: You must supply a config file: build -f <config-file>\n" unless $opt{f};
    $DEBUG            = 1 if $opt{d};
    $SIMULATE         = 1 if $opt{s};
    $REMOVE           = 1 if $opt{r};
    $ADD              = 1 if $opt{a};
    $RESTART_UPGRADED = 1 if $opt{S};
    $KEEP_OLD         = 1 if $opt{k};
    $VERBOSE          = 1 if $opt{v};
    $COLORS           = 1 if $opt{c};

    buildMLNproject($opt{f},$REMOVE,$VERBOSE,"",$SERVICE_HOST);	      

}


sub buildMLNproject {

    if ( $_[0] ) {
#	print "opt(f) was defined\n";
        $CONFIGFILE = $_[0];
        die "ERROR: The configuration file must always end with the suffix .mln"
          unless $CONFIGFILE =~ /(\.mln$)/;
    } 
    $SPAWNED_REMOTELY = 1 if $_[3];
    if ( $_[3]){
#	print "spawned remotely activated\n";
    }
    $REMOVE = 1 if $_[1];
    $VERBOSE = 1 if $_[2];
    
    my $manager = $_[4];
    my @hosts;    # All hostnames are stored here
#    print "configfile set to: $CONFIGFILE\n";
#################################################################

    $DATA_ROOT =  buildDataTree($CONFIGFILE);

    buildGlobalConfig();
    out( "+---> BUILDING $PROJECT\n", "green" ) unless $SPAWNED_REMOTELY;

    assignHostsToSwitches();

    # we run all the plugins postParse-phase. 

    runPostParsePlugins();

    
#######################
    #

    checkKernels();

    getImages();

    

    if ( not $SPAWNED_REMOTELY ){
	printNetwork();

	printHosts();

	printGlobal();
    }

    if ( $SIMULATE ){
	out("Simulaion only, exiting\n");
	exit;
    }

    checkCowFilesystems();

    checkTemplates();   
    
#    checkMLNstatus();

    checkIfExists();
    verifyDirectories("$PROJECT_PATH/$PROJECT",$IMAGEDIR,$NETDIR,$PIDDIR);   
    system("$shell{'CHMOD'} 777 $NETDIR");
    saveConfig();

    my @service_hosts;
    if ( not $SPAWNED_REMOTELY ){ 
#		print "I SHOULD NOT BE REMOTELY SPAWNED!\n";
	@service_hosts = startRemoteBuilds("build");
	storeServiceHosts(\@service_hosts);

    }
    setProjectManager($manager);    
    buildNetwork();

    buildMLNhosts();

#    writeExtraScripts();
#    print "writing extra scripts\n";
    writeExtraScripts();
#    print "done\n";
    if ( not $SPAWNED_REMOTELY ){
	collectTickets();

    }
    setProjectVersion();
    
    out( "+---> PROJECT $PROJECT FINISHED \n", "green" ) unless $SPAWNED_REMOTELY;

}
sub reconfigureMLNprojectHandler {
    shift @ARGV;

    $RECONFIGURE = 1;


    my $opt_string = 'p:h:b:BCvkarsSducf:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
#    print "file is $opt{f}\n";
#    usage() and die "ERROR: You must supply a config file: build -f <config-file>\n" unless $opt{f};
    $DEBUG            = 1 if $opt{d};
    $SIMULATE         = 1 if $opt{s};
    $REMOVE           = 1 if $opt{r};
    $ADD              = 1 if $opt{a};
    $RESTART_UPGRADED = 1 if $opt{S};
    $KEEP_OLD         = 1 if $opt{k};
    $VERBOSE          = 1 if $opt{v};
    $COLORS           = 1 if $opt{c};
    $RECONFIGURE_REBUILD = 1 if $opt{B};
    $HOSTLIST = $opt{h};
    reconfigureMLNproject($opt{p},$REMOVE,$VERBOSE,"",$SERVICE_HOST);	      

}

sub reconfigureMLNproject {
    $RECONFIGURE = 1;
    if ( $_[0] ) {
#	print "opt(f) was defined\n";
#	print "HOSTLIST: $HOSTLIST\n";
#	print "project path: $PROJECT_PATH/$_[0]/$_[0].mln\n";
        die "ERROR: No such project $_[0]\n"
	unless stat("$PROJECT_PATH/$_[0]/$_[0]" . ".mln");
	$CONFIGFILE = "$PROJECT_PATH/$_[0]/$_[0]" . ".mln";
    }
    $SPAWNED_REMOTELY = 1 if $_[3];
    if ( $_[3]){
#	print "spawned remotely activated\n";
    }
    $REMOVE = 1 if $_[1];
    $VERBOSE = 1 if $_[2];
    
    my $manager = $_[4];
    my @hosts;    # All hostnames are stored here
#    print "configfile set to: $CONFIGFILE\n";
#################################################################

    $DATA_ROOT =  buildDataTree($CONFIGFILE);

    buildGlobalConfig();
    out( "+---> (BETA) RECONFIGURING $PROJECT\n", "green" ) unless $SPAWNED_REMOTELY;
    out("Disabling persistence\n");
    setPersistent($PROJECT,'off',1);        
    assignHostsToSwitches();

    # we run all the plugins postParse-phase. 
    runPostParsePlugins();

    
#######################
    #

    checkKernels();

    getImages();

    

    if ( not $SPAWNED_REMOTELY ){
	printNetwork();

	printHosts();

	printGlobal();
    }

    if ( $SIMULATE ){
	out("Simulaion only, exiting\n");
	exit;
    }

    checkCowFilesystems();

#    checkTemplates();   
    
#    checkMLNstatus();

#    checkIfExists();
#    verifyDirectories("$PROJECT_PATH/$PROJECT",$IMAGEDIR,$NETDIR,$PIDDIR);   
    system("$shell{'CHMOD'} 777 $NETDIR");
#    saveConfig();

    my @service_hosts;
    if ( not $SPAWNED_REMOTELY ){ 
#		print "I SHOULD NOT BE REMOTELY SPAWNED!\n";
	@service_hosts = startRemoteBuilds("reconfigure");
	storeServiceHosts(\@service_hosts);
    }
#    setProjectManager($manager);    
    buildNetwork();
    
    buildMLNhosts();
    
#    writeExtraScripts();
#    print "writing extra scripts\n";
    writeExtraScripts();
#    print "done\n";
    if ( not $SPAWNED_REMOTELY ){
	collectTickets();
    }
    setProjectVersion();
    foreach my $host ( keys %RESTART_ME ){
	print "starting $host\n";
	my $service_host = getScalar("/host/$host/service_host");
	if ( $SERVICE_HOST and $service_host eq $SERVICE_HOST ){
	    startHost($host);
	}
    }
    
    out( "+---> PROJECT $PROJECT FINISHED \n", "green" ) unless $SPAWNED_REMOTELY;

}

sub setProjectManager {
    open(FILE,">$PROJECT_PATH/$PROJECT/manager");
    print FILE $_[0] . "\n";
    close(FILE);
}

sub storeServiceHosts {
    my $tm = $_[0];
    my @service_hosts = @$tm;
    
    open(FILE,">$PROJECT_PATH/$PROJECT/service_hosts");
    foreach (@service_hosts){
#	print "storing service_host $_\n";
	print FILE $_ ."\n";
    }
    close (FILE);    
}

sub checkMLNstatus {
    
    my $amountTested = 0;
    my $amountOK;
    my @return;       

    
    out("Collecting Status information for $PROJECT\n");
    my $key;
    ($amountTested,$amountOK,@return) 
      = getStatus($PROJECT,"",1,0,$QUIET,0,not $SPAWNED_REMOTELY);
#	print "at: $amountTested, hosts: " . getHosts($OLD_DATA_ROOT) . " switches " . getBlockKeys("/switch",$OLD_DATA_ROOT) . "\n";
    if ( $amountTested != getHosts($OLD_DATA_ROOT) ) {
	foreach $key ( getHosts($OLD_DATA_ROOT) ){
	    if ( not grep(/host $key /,@return)){
		my $server = getScalar("/host/$key/service_host",$OLD_DATA_ROOT);
		out("Could not verify the status of $key at $server\n","red");
		$DOWN_SERVERS{$server} = 1;
	    }
	}
	
	out("\nFATAL: One or more hosts in this project could not be verified.\nThis might be that the MLN daemon is not running on the service_host,\nor that the project does not exist on it.\nUse the -r opion to override if you really want to continue.\n","red");
	exit (1) unless $REMOVE;
    }
    my $warning;
    foreach $key ( getHosts($DIFF) ) {
	my $old_sh = getScalar("/host/$key/service_host",$OLD_DATA_ROOT);	    
	
	my $new_sh = getScalar("/host/$key/service_host",$DIFF);
#	    print "checking $key ( $old_sh , $new_sh )\n";
	if ( not $old_sh and $SERVICE_HOST ){
	    $old_sh = $SERVICE_HOST;
	}
	if ( $new_sh and $old_sh ne $new_sh ){
	    out("- $key will migrate from $old_sh to $new_sh\n");
	    
	    if ( not daemonIsRunning($new_sh) ){
		$warning = 1;
		out("Could not make contact with MLN daemon at $new_sh\n","red");
		$DOWN_SERVERS{$new_sh} = 1;
	    }
	}	    
    }
    if ( $warning ){
	out("\nFATAL: One or more MLN daemons could not be verified on remote servers.\nThis might be that the MLN daemon is not running on the service_host,\nor that it does not allow connection from this host.\nUse the -r opion to override if you really want to continue.\n","red");
	exit (1) unless $REMOVE;
    }
    
#	print "before checkIfAnyAreUp()\n";
    # Just to be sure, I'll check if the host is really down, before we thrash it
    
    createHostsFile();
    print "\nParsing complete\n" and exit if $SIMULATE;

    my $amountTested;
    my $amountOK;
    my @return;
    
    
    if ( stat("$PROJECT_PATH/$PROJECT/${PROJECT}.mln") and $USER_MODE_REC ){
	$OLD_DATA_ROOT = buildDataTree("$PROJECT_PATH/$PROJECT/${PROJECT}.mln");
	if ( not SPAWNED_REMOTELY and isDistributed($OLD_DATA_ROOT) ){
	    out("Collecting Status information for $PROJECT\n");
	    if ( not $RECONFIGURE  ) {
		($amountTested,$amountOK,@return) 
		  = getStatus($PROJECT,"",1,0,$QUIET,0,not $SPAWNED_REMOTELY);
		if ( $amountOK > 0 ){
		    out(
			"DANGER: A host in this project is still up!\nYou probarbly want to upgrade instead.\n",
			"red"
		    );
		    exit 1;
		} 
		
		if ( $amountTested != getHosts($OLD_DATA_ROOT) and not $SPAWNED_REMOTELY){
		    
		    my $key;
		    foreach $key ( getHosts($OLD_DATA_ROOT) ){
			if ( not grep(/host $key /,@return)){
			    out("Could not verify the status of $key at " . getScalar("/host/$key/service_host",$OLD_DATA_ROOT)."\n","red");
			}
		    }
		    out(
			"\nDANGER: All service hosts did not respond to the status query,\nit is not safe to continue.\nUse the -r option to override.\n",
			"red"
		    );
		    exit 1 unless $REMOVE;
		}
	    }
	}
    }
    
    if (  isDistributed() ){
	out("Checking if all MLN daemons are running on new service hosts\n");
	
	my $key;
	my $warning;
	foreach $key ( getHosts($DATA_ROOT) ){
	    my $sh = getScalar("/host/$key/service_host",$DATA_ROOT);
	    my $old_sh = getScalar("/host/$key/service_host",$OLD_DATA_ROOT);
#		print "sh: $sh, old: $old_sh\n";
	    if ( $sh ne $old_sh ){
		if ( not daemonIsRunning($sh) ){		
		    out("Could not verify the status of $key at $sh\n","red");
		    $warning = 1;
		}
	    }
	}
	if ( $warning ){
	    out("\nDANGER: Some service hosts where this project is supposed to be buildt did not\nanswer. Either the host is down or the MLN daemon is not running on it. It is\nnot safe to continue.\nUse the -r option to override\n","red");
	    exit 1 unless $REMOVE;
	}
    }
}

#####################################
# A quick check if the host is registered before
######################################################

sub checkForHost {
    my $i;
    my $name = $_[0];

    if ( $HOSTS{"$name"} ) {
        debug("Host with name $name allready exists. Ignoring");
        return 1;
    }

    return 0;
}

####################################
# Initialize the stop script

sub initializeStopScript {
    open( STOP, ">$STOP_SCRIPT" ) or die "Failed to open $STOP_SCRIPT\n";

    print STOP
      "#!/bin/sh\n\# Stop script\necho \"Stopping all networking devices\"\n";

    #    print STOP "PIDDIR=$PIDDIR\n";

    print STOP "for net in \$(find $NETDIR -type s -print); do\n";
    print STOP "pkill -u \${USER} -f \"\\-unix \$net\"\n";
    print STOP "rm \$net\n";
    print STOP "done\n\n";

    close(STOP);
    system("$shell{'CHMOD'} +x $STOP_SCRIPT");

}

#################################
# Print the upgrade details for a host
#

sub printUpgradeDetails {

    my $hostname = $_[0];
    my $each;
    my $tm   = $UPGRADE_LIST{$hostname};
    my %hash = %$tm;

    foreach $each ( keys %hash ) {

        print "   $each\n";

    }

}

sub assumeXenKernelVersion {
    # if nothing else is specified, we will assume that 
    # the modules we should copy are the same as the running kernel
    my $kernel = `uname -r`;
    chomp $kernel;
    return $kernel;
}

sub assumeXenInitrd {
    my $version = $_[0];
#    print "assumeXenInitrd was called\n";
    opendir(DIR, "/boot");
    my @files = grep { /initrd/ && /$version/ } readdir(DIR);
    closedir DIR;
#    foreach (@files){
    print "found suitable initrd file: $files[0]\n";
 #   }
#    return "/boot/". $files[0];
}

sub getXenInitrd {
    my $version = $_[0];
#    print "assumeXenInitrd was called\n";
    opendir(DIR, "/boot");
    my @files = grep { /initrd/ && /$version/ } readdir(DIR);
    closedir DIR;
#    foreach (@files){
    print "found suitable initrd file: $files[0]\n";
 #   }
    return "/boot/". $files[0];
}

########################################################
# Configure the network interfaces for regular machines
# Busybox filesystems are forwarded to another subroutine.
#

sub networkConfig {

    my $hostname = $_[0];
    my $i        = 0;
    my $netw     = $_[1];
    my %network  = getHash("/host/$hostname/network");
    my $each;
    return unless %network;

    
    my $family = determineFamily($hostname);
    $family = $DEFAULTS{FAMILY} unless ($family);
#    print "family: $family\n";
    if ( $family =~ /busybox/ ) {
        networkConfigBusybox( $hostname, \%network );
        return;
    }


    # DEBIAN SPECIFIC:

    if ( $family eq "debian" ) {
#	print "family is $family\n";
	if (stat("$MOUNTDIR/etc/iftab")){
	    system("rm $MOUNTDIR/etc/iftab");
	}
        open( NETCONF, ">$MOUNTDIR/etc/network/interfaces" )
          or ( verbose("Failed to open file $MOUNTDIR/etc/network/interfaces\n") and return);

        print NETCONF "auto lo\n";
        print NETCONF "iface lo inet loopback\n\n";

        foreach $each ( keys %network ) {
	    out("Adding interface $each ($network{$each}{'address'})\n");

            if ( $network{$each}{"slirp"} ) {

                #		  print "slirp detected\n";
                print NETCONF "auto ", $each, "\n" if not $network{$each}{"auto"};
                print NETCONF "iface ", $each, " inet static\n";

                if ( $network{$each}{"address"} ) {

                    print NETCONF "address ", $network{$each}{"address"}, "\n";
                }
                else {
                    print NETCONF "address $DEFAULTS{SLIRP_IF_ADDR}\n";
                    addNameserver( $hostname, $DEFAULTS{SLIRP_DNS} );
                }

                if ( $network{$each}{"netmask"} ) {
                    print NETCONF "netmask ", $network{$each}{"netmask"}, "\n";
                }
                else {
                    print NETCONF "netmask 255.255.255.255\n";
                }
                print NETCONF "up route add default dev " . $each . "\n";

            }
            elsif ( $network{$each}{"address"} =~ /\d+\.\d+\.\d+\.\d+/ ) {
                print NETCONF "auto ", $each, "\n" if not $network{$each}{"auto"};
                print NETCONF "iface ", $each,   " inet static\n";
                print NETCONF "address ", $network{$each}{"address"}, "\n"
                  if $network{$each}{"address"};
                print NETCONF "netmask ", $network{$each}{"netmask"}, "\n"
                  if $network{$each}{"netmask"};
                print NETCONF "broadcast ", $network{$each}{"broadcast"}, "\n"
                  if $network{$each}{"broadcast"};
                print NETCONF "gateway ", $network{$each}{"gateway"}, "\n"
                  if $network{$each}{"gateway"};
		# print NETCONF "hwaddress ether ",$network{$each}{"mac"},"\n"
		#  if $network{$each}{"mac"};
            }
            elsif ( $network{$each}{"address"} =~ /^dhcp$/ ) {		
                print NETCONF "auto ", $each, "\n" if not $network{$each}{"auto"};
                print NETCONF "iface ", $each, " inet dhcp\n";
		print NETCONF "hwaddress ether ",$network{$each}{"mac"},"\n"
		  if $network{$each}{"mac"};

            }
	    if ($network{$each}{"mac"}){
		open(IFTAB,">$MOUNTDIR/etc/iftab");
		print IFTAB "$each mac " . $network{$each}{"mac"} . "\n";
		close(IFTAB);
	    }

        }
        close(NETCONF);
#	system("cat $MOUNTDIR/etc/network/interfaces");

    }
    elsif ( $family eq "redhat" ) {

        # REDHAT

        foreach $each ( keys %network ) {
	out("Adding interface $each ($network{$each}{'address'})\n");
            my @netconf;
            my $counter;

 #	      my $iface-path = "/etc/sysconfig/network-scripts/ifcfg-". $each->iface;

            if ( $network{$each}{"address"} =~ /\d+\.\d+\.\d+\.\d+/ ) {
                $netconf[ $counter++ ] = "DEVICE=" . $each;
                $netconf[ $counter++ ] = "BOOTPROTO=none";
                $netconf[ $counter++ ] = "IPADDR=" . $network{$each}{"address"};
                $netconf[ $counter++ ] = "NETMASK=" . $network{$each}{"netmask"};
                if ( $network{$each}{"broadcast"} ) {
                    $netconf[ $counter++ ] = "BROADCAST=" . $network{$each}{"broadcast"};
                }
                if ( $network{$each}{"gateway"} ) {
                    my @tmp_gw;

                    $tmp_gw[0] = "GATEWAY=" . $network{$each}{"gateway"};
                    addToFile( $hostname, "/etc/sysconfig/network", \@tmp_gw );
                }
            }
            elsif ( $network{$each}{"address"} =~ /^dhcp$/ ) {
                $netconf[ $counter++ ] = "DEVICE=" . $each;
                $netconf[ $counter++ ] = "BOOTPROTO=dhcp";
            }
	    # INSERT interface -> auto, assume yes
            $netconf[ $counter++ ] = "ONBOOT=yes";
            $netconf[ $counter++ ] = "USERCTL=no";
            $netconf[ $counter++ ] = "TYPE=Ethernet";

            writeToFile( $hostname,
                "/etc/sysconfig/network-scripts/ifcfg-" . $each,
                \@netconf );
            writeToFile( $hostname,
                "/etc/sysconfig/networking/devices/ifcfg-" . $each,
                \@netconf );
            writeToFile(
                $hostname,
                "/etc/sysconfig/networking/profiles/default/ifcfg-"
                  . $each,
                \@netconf
            );

        }
        close(NETCONF);
    }
}

###################################
# execute lvm commands on a server. 
# This is useful if the VG is on a AoE, ISCSI or other SAN

sub lvm_execute {
    if ($_[0] eq "lock" ){
	my $path = $_[1];
	$path =~ s/^(\/dev\/\S+)\/.*$/$1/;
	out("lvm_execute path is $path, server is: $LVM_EXECUTE_SERVER{$path}\n");
	if ( $LVM_EXECUTE_SERVER{$path} ){
	    my $sock = connect_to_server($LVM_EXECUTE_SERVER{$path});
	    print $sock "execute:$_[2]\n";
	    my $line;
	    while ( $line = <$sock> ){
		last if $line eq "OUTPUT-END\n";
		out($line);
	    }
	    close($sock);
	    system("vgscan; vgchange -ay")
	} else {
	    die ("No lvm_execute_server specified in mln.conf for $path, dying...\n");
	    
	}
    } else {
	system("$_[2]");
    }
}


###################################
# Set the hostname for the current image
#

sub setHostname {

    my $hostname = $_[0];
    my $family = determineFamily($hostname);
    if ( $family eq "redhat" ) {

        my @tmp_hst;
        $tmp_hst[0] = "HOSTNAME=$hostname";
        addToFile( $hostname, "/etc/sysconfig/network", \@tmp_hst );

    }
    elsif ( $family eq "debian" or $family eq "busybox" ) {

        #	  system ("$shell{'MOUNT'} -o loop $IMAGEDIR/$hostname $MOUNTDIR");
        open( HOSTNAME, ">$MOUNTDIR/etc/hostname" )
          or return;

        #	  print "mounting: $IMAGEDIR/$hostname on $MOUNTDIR\n";
        #	  print "opening: $MOUNTDIR/etc/hostname\n";
        #         print "Setting hostname $hostname\n";
        print HOSTNAME "$hostname\n";
        close(HOSTNAME);

        #	  print "Hostname: ";
        #	  system("cat $MOUNTDIR/etc/hostname");
        #	  system ("$shell{'UMOUNT'} $MOUNTDIR");
    }
}

###################################
# Write down the shell scripts that are
# to be executed before and after and such

sub writeExtraScripts {
    
    my @scripts = ( "beforeProjectStart",
	"beforeProjectStop",
	"afterProjectStart",
	"afterProjectStop",
	"beforeHostsStart",
	"beforeHostsStop",
	"afterHostsStart",
	"afterHostsStop" );
    
    my $each;
    foreach $each (@scripts){
#	print "testing $each\n";
	if (stat("$PROJECT_PATH/$PROJECT/$each.sh")){
	    verbose("removing $PROJECT_PATH/$PROJECT/$each.sh\n");
	    system("$shell{'RM'} $PROJECT_PATH/$PROJECT/$each.sh");
	}
	my @commands = getArray("/global/$each");
#	print "got commands\n";
	if ( @commands ){
	    open (SCRIPT,">$PROJECT_PATH/$PROJECT/$each.sh") or warn("failed to open $PROJECT_PATH/$PROJECT/$each.sh : $!");
	    if (SCRIPT) {
		print SCRIPT "#!/bin/bash\n";
		foreach (@commands){
#		    print "adding commands: $_\n";
		    print SCRIPT "$_\n";  
		}
		close(SCRIPT);
		system("$shell{'CHMOD'} +x $PROJECT_PATH/$PROJECT/$each.sh");
	    }
	}
    }
}

###################################
# Set the nameserver for the current
# image.

sub setNameserver {
    my $hostname   = $_[0];
    my $nameserver = $_[1];

	open( RESOLV, ">$MOUNTDIR/etc/resolv.conf" )
	  or return;
    
	print RESOLV "nameserver $nameserver\n";
	close RESOLV;

}

sub addNameserver {
    my $hostname   = $_[0];
    my $nameserver = $_[1];

    open( RESOLV, ">>$MOUNTDIR/etc/resolv.conf" )
      or return;

    print RESOLV "nameserver $nameserver\n";
    close RESOLV;


}

###################################
# Set the root password for the current
# image.

sub setRootPassword {
    my $hostname      = $_[0];
    my $root_password = $_[1];

    # a change suggested by David Byers
    system(
"$shell{'ECHO'} 'root:$root_password' | $shell{'CHROOT'} $MOUNTDIR chpasswd -c MD5 "
    );
#    system(
# "$shell{'ECHO'} 'root:$root_password' | $shell{'CHROOT'} $MOUNTDIR chpasswd "
#    );

#      system("$shell{CHROOT} $MOUNTDIR")
#      system("$shell{'ECHO'} \"echo \\\"root:$root_password\\\" | chpasswd -e \" > $MOUNTDIR/tmp/pass.sh");
#      system("$shell{'CHROOT'} $MOUNTDIR sh /tmp/pass.sh");
#      system("$shell{'RM'} $MOUNTDIR/tmp/pass.sh");
}

###################################
# Copy the kernel modules into the image.
# This is only done right now if somme modules
# are specified

sub copyModules {
    debug("copy modules called\n");
    
    my $hostname = $_[0];
    return if ( getScalar("/host/$hostname/hvm"));
    my $mod;

    $mod = $MODULESDIR . $KERNEL_VERSION_TABLE{$hostname};

    if ( not stat("$mod") ) {
        print STDERR "ERROR: Failed to find modules directory: $mod\n";
        return;
    }
    my $space = `df -m $MOUNTDIR/lib/modules | tail -1`;
    chomp $space;
    $space =~ s/^\S+\s+\d+\s+\d+\s+(\d+).*$/$1/;
    print "size was '$space'\n";


    my $size = `du -sm $mod`;
    $size =~ s/(\S+).*/$1/;
    out("Importing modules from: $mod\n"); # (${size}MB), free space: ${space}MB\n");
    if ( $size < $space){
	system("$shell{'CP'} -r $mod $MOUNTDIR/lib/modules/");
    } else {
	out("WARNING: There is not enough space on the VM to copy the modules.\nSpace on VM: ${space}MB, Size of modules: ${size}MB\n","red");
    }
}

#########################################
# Lets try to figure out what family this
# Filesystem belongs to:

sub determineFamily {

    my $answer;
    my $hostname = $_[0];

    #    system ("$shell{'MOUNT'} -o loop $IMAGEDIR/$hostname $MOUNTDIR");
    $answer = "busybox" if ( stat("$MOUNTDIR/$BUSYBOX_HINT") );
    $answer = "debian" if ( stat("$MOUNTDIR/$DEBIAN_HINT") );
    $answer = "redhat" if ( stat("$MOUNTDIR/$REDHAT_HINT") );
    
    $answer = "windows" if ( stat("$MOUNTDIR/$WINDOWS_HINT") );
    $answer = "suse" if ( stat("$MOUNTDIR/$SUSE_HINT") );
    verbose("determineFamily: $answer\n");
    return $answer;
}

###################################
# Write a list of modules to be loaded
# into the file /etc/modules

sub copyModuleList {
    my $hostname    = $_[0];
    my $i           = 0;
    my $temp        = $_[1];
    my @modulesList = @$temp;
    my $family      = determineFamily($hostname);

    if ( $family eq "debian" ) {
        writeToFile( $hostname, "/etc/modules", \@modulesList );
    }
    elsif ( $family eq "redhat" ) {
        my @tmp_mod;

        for ( my $i = 0 ; $i <= $#modulesList ; $i++ ) {
            $tmp_mod[$i] = "modprobe $modulesList[$i]";

        }
        addToFile( $hostname, "/etc/rc.local", \@tmp_mod );

    }

    print $#modulesList + 1, " modules registered\n";
}

###################################
# Write the startup commands into the file
# /etc/init.d/startup and make a link to it

sub setStartupCommands {
#    print "setStartupCommands called\n";
    my $hostname = $_[0];
    my $temp     = $_[1];
    my $family   = determineFamily($hostname);
    
    my @params = @$temp;
    unshift(@params,"echo \"MLN startup commands\"\n");
    unshift(@params,"#!/bin/bash\n");

    my $i = 0;

    if ( $family eq "busybox" ) {
        addToFile( $hostname, "/etc/init.d/rcS", \@params );
    }
    elsif ( $family eq "redhat" ) {
        addToFile( $hostname, "/etc/init.d/startup", \@params );

        system(
"$shell{'CHROOT'} $MOUNTDIR ln -s /etc/init.d/startup /etc/rc3.d/S99startup"
        );
	system(
"$shell{'CHROOT'} $MOUNTDIR ln -s /etc/init.d/startup /etc/rc4.d/S99startup"
        );

        system("$shell{'CHMOD'} +x $MOUNTDIR/etc/init.d/startup");

    }
    elsif ( $family eq "debian" ) {
#	print "inside debian family\n";
        addToFile( $hostname, "/etc/init.d/startup", \@params );

        system(
"$shell{'CHROOT'} $MOUNTDIR ln -s /etc/init.d/startup /etc/rc2.d/S99startup"
        );
        system(
"$shell{'CHROOT'} $MOUNTDIR ln -s /etc/init.d/startup /etc/rc4.d/S99startup"
        );
        system("$shell{'CHMOD'} +x $MOUNTDIR/etc/init.d/startup");
	system("cat $MOUNTDIR/etc/init.d/startup");

    }

    out($#params + 1 . " startup commands written to file\n");
}
###################################
# Write the shutdown commands into the file
# /etc/init.d/shutdown and make a link to it

sub setShutdownCommands {
#    print "setStartupCommands called\n";
    my $hostname = $_[0];
    my $temp     = $_[1];
    my $family   = determineFamily($hostname);
    
    my @params = @$temp;
    unshift(@params,"echo \"MLN startup commands\"\n");
    unshift(@params,"#!/bin/bash\n");

    my $i = 0;

    if ( $family eq "busybox" ) {
        addToFile( $hostname, "/etc/init.d/rc0", \@params );
    }
    elsif ( $family eq "redhat" ) {
        addToFile( $hostname, "/etc/init.d/shutdown", \@params );

        system(
"$shell{'CHROOT'} $MOUNTDIR ln -s /etc/init.d/shutdown /etc/rc0.d/K01shutdown"
        );
	system(
"$shell{'CHROOT'} $MOUNTDIR ln -s /etc/init.d/shutdown /etc/rc6.d/K01shutdown"
        );

        system("$shell{'CHMOD'} +x $MOUNTDIR/etc/init.d/shutdown");

    }
    elsif ( $family eq "debian" ) {
#	print "inside debian family\n";
        addToFile( $hostname, "/etc/init.d/shutdown", \@params );

        system(
"$shell{'CHROOT'} $MOUNTDIR ln -s /etc/init.d/shutdown /etc/rc0.d/K01shutdown"
        );
        system(
"$shell{'CHROOT'} $MOUNTDIR ln -s /etc/init.d/shutdown /etc/rc6.d/K01shutdown"
        );
        system("$shell{'CHMOD'} +x $MOUNTDIR/etc/init.d/shutdown");
	system("cat $MOUNTDIR/etc/init.d/shutdown");

    }

    out($#params + 1 . " startup commands written to file\n");
}

######################################
# This method is able to move the filesystem back and fourth 
# between LVM and an image file

sub replaceFilesystem { 
    my $hostname = $_[0];
#    print "Attempting to move the filesystem\n";
    my $old = getScalar("/host/$hostname/lvm",$OLD_DATA_ROOT);
    my $new = getScalar("/host/$hostname/lvm",$DATA_ROOT);
    my $vg = getScalar("/host/$hostname/lvm_vg",$OLD_DATA_ROOT);
    my $vg = $DEFAULTS{"MLN_VG"} if not $vg;
    # we must figure out the old size
    my $quiet = "&>/dev/null";
    $quiet = "" if $VERBOSE;
    if ( $old ) {
	# we go from lvm to an image
#	$size = `/sbin/lvs --noheadings --nosuffix --units b -o lv_name,lv_size | grep $hostname.$PROJECT`;
	my $return = system("dd if=/dev/$vg/$hostname.$PROJECT of=$IMAGEDIR/$hostname &>/dev/null");
	if ($return == 0){
	    print "Filesystem moved to $IMAGEDIR/$hostname\n";
	    print "Removing old version at /dev/$vg/$hostname.$PROJECT\n";
	    if ( $old eq "lock" ){
		lvm_execute($old,"/dev/$vg/$hostname.PROJECT","lvremove -f $vg/$hostname.$PROJECT");
	    } else {
		system("$shell{LVREMOVE} -f $vg/$hostname.$PROJECT $quiet");	
	    }
	    return 0;
	}
    } elsif ( $new ) {
	# we go from file to lvm
	# we need to get the size of the filesystem
	my @stat = stat("$IMAGEDIR/$hostname");

#	print "stat gave me size: $stat[7] and blocks: $stat[12]\n";
	my $size = int($stat[7] / 1024) + 1;
	

	my $return = lvm_execute($new,"/dev/$vg/$hostname.$PROJECT","$shell{LVCREATE} -n $hostname.$PROJECT --size ${size}K $vg ");
	if ( $return == 0 ){
	    $return = system("dd if=$IMAGEDIR/$hostname of=/dev/$vg/$hostname.$PROJECT bs=2048 &>/dev/null");
	    if ($return == 0 ) {
		system("$shell{'FSCK'} -y -f /dev/$vg/$hostname.$PROJECT &>/dev/null");
		if ($return == 0){
		    print "Filesystem moved to /dev/$vg/$hostname.$PROJECT\n";
		    print "Removing old version at $IMAGEDIR/$hostname\n";
		    system("$shell{RM} $IMAGEDIR/$hostname");
		    return 0;
		}
	    }
	}
    }
    return 1;
}

###################################
# Build filesystem
# The commands are copied from the user-mode linux page

sub buildFilesystem {
    
#    out("buildFilesystem\n");
    my $hostname = $_[0];
    my $template = $_[1];
    my $size     = $_[2];
    my $resize   = $_[3];

    
    my $hvm = getScalar("/host/$hostname/hvm");
    my $lvm_snapshot = getScalar("/host/$hostname/lvm_snapshot");
    my $filepath = getScalar("/host/$hostname/filepath");
    if ( not $lvm_snapshot ){
	out( "Filesystem size: " . int( $size / 1024 / 1024 ) . "M\n" );
    }
    my $quiet = "1>/dev/null";
#    my $quiet = "";
    my $lvm = getScalar("/host/$hostname/lvm");
    
    
#    die("Failed to stat $template is it really there?")
 #     unless stat("$TEMPLATEDIR/$template");

    my $silent = " 2>/dev/null 1>/dev/null" if not $VERBOSE;
#  my $silent = "";
    if ( $lvm ) {
	my $vg = getScalar("/host/$hostname/lvm_vg");
	$vg = $DEFAULTS{'MLN_VG'} if not $vg;

	my $options; 
	$options = $lvm if ( $lvm != 1 );
	if ( not $resize ){
	    if ( $lvm_snapshot ){
		if (stat("/dev/$vg/$template")){
		    out("Creating snapshot of /dev/$vg/$template, ");
		    my $lvout = `lvdisplay -c /dev/$vg/$template`;
		    my @snap_size = split /:/,$lvout;
		    lvm_execute($lvm,"/dev/$vg/$template","$shell{'LVCREATE'} -s -L " . int($snap_size[6]/2/1024). "M -n $hostname.$PROJECT /dev/$vg/$template ");
		}
	    } else {
		# denne kan vi gjoere litt mer sikker
		out("Building filesystem: lvcreate, ");
		verbose("$shell{'LVCREATE'} $options -n $hostname.$PROJECT --size $size $vg ");
		$size = int($size / 1024);
		lvm_execute($lvm,"/dev/$vg/$hostname.$PROJECT","$shell{'LVCREATE'} -n $hostname.$PROJECT --size ${size}K $vg ");
		out("copying template,\n");
#		system("ls /dev/$vg");
		system("vgchange -ay /dev/$vg ");
#		system("ls /dev/$vg");
		
		# this is just a simple precaution againsed slow AoE
		for ( my $i=0; $i < 3; $i++){
		    if ( not stat("/dev/$vg/$hostname.$PROJECT")  ){
			sleep(1);
			system("vgchange -a y /dev/$vg ");
		    } else {
			last;
		    }
		}
		if ( not stat("$TEMPLATEDIR/$template") ) {
		    print STDERR
		      "ERROR: Could not find template $template in $TEMPLATEDIR\n";
		    exit 2;
		}

		if ( stat("/dev/$vg/$hostname.$PROJECT")  ){
		    system("$shell{'DD'} if=$TEMPLATEDIR/$template of=/dev/$vg/$hostname.$PROJECT bs=2048 $silent");
		} else {
		    out("ERROR: Logical volume has no link at /dev/$vg/$hostname.$PROJECT\n");
		    return 1; 
		}
		
	    }
	} elsif ( $resize ){
	    $size = int($size / 1024);
	    out("Resizing filesystem: lvresize, ");
	    verbose("$shell{'LVRESIZE'} $options -n --size ${size}K /dev/$vg/$hostname.$PROJECT $quiet");
	    lvm_execute($lvm,"/dev/$vg/$hostname.$PROJECT","$shell{'LVRESIZE'} -n --size ${size}K /dev/$vg/$hostname.$PROJECT &>/dev/null");
	}
	if ( not $hvm and not $lvm_snapshot ){
	    out("fsck, ");
	    system("$shell{'FSCK'} -y -f /dev/$vg/$hostname.$PROJECT $silent");
	    
	    out("resizing, ");
	    if ( $template =~ /\.ext\d$/ ){
		system("$shell{'RESIZE2FS'} /dev/$vg/$hostname.$PROJECT $silent");
	    } elsif ( $template =~ /\.fat32$/ ){    
#	    out("Using Parted to resize the partition:\nPress \"I\" and ENTER");
#	    use Expect;
#	    my $exp = Expect->spawn("/sbin/parted /dev/$vg/$hostname.$PROJECT resize 1 32kB 100%");
#	    $exp->send("I\n");
#	    $exp->soft_close();
#		if ( not stat("/usr/bin/expect")){
#		    out("ERROR: Could not stat /usr/bin/expect. HVM disk cannot be resized\n");
#		}
		
		# system("/usr/bin/expect -c \"spawn /sbin/parted /dev/$vg/$hostname.$PROJECT resize 1 32kB 100%; expect 'Ignore/Cancel? ';send I\\r; send I\\r; interact\" &>/dev/null");
		system("/sbin/parted /dev/$vg/$hostname.$PROJECT resize 1 32kB 100%");
	    }
	}
    
    
    } else {
	out("Building filesystem: ");
	my $ret;
	my $destination = "$IMAGEDIR/$hostname";
	if ( $filepath ){
	    $destination = "$filepath/$hostname.$PROJECT";
	} 
	
	if ( not $resize ) {
	    out(" copying,");
	    system("$shell{'CP'} $TEMPLATEDIR/$template $destination");
	    
	}	
	out(" growing,");
	system(
	    "$shell{'DD'} if=/dev/zero of=$destination bs=1 count=0 seek=$size $silent"
	);
	
	out(" fsck,");
#	print"$shell{'FSCK'} -y -f $IMAGEDIR/$hostname\n";
	system("$shell{'FSCK'} -y -f $destination $silent");
	
	out(" resize, ");

	if ( $template =~ /\.ext\d$/ ){
	    system("$shell{'RESIZE2FS'} $destination $silent");
	} elsif ( $template =~ /\.fat32$/ ){    
	    out("\nDue to lack of understanding of parted, you must now type \"I\" and press enter:\n");
	    system("/usr/bin/expect -c \"spawn /sbin/parted $destination resize 1 32kB 100%; expect 'Ignore/Cancel? ';send I\\r; send I\\r; interact\" &>/dev/null");
	}

    } 

    out("done\n");
}

##################################
# Create the swap space for the vm (if any).
# This should be default?

sub makeSwap {
    my $hostname  = $_[0];
    my $size      = $_[1];
    my $megabytes = ( $size / 1024 ) / 1024;

    out("Creating ${megabytes}M swap file\n");
    my $silent = " &> /dev/null" if not $VERBOSE;

    system(
"$shell{'DD'} if=/dev/zero of=$IMAGEDIR/${SWAP_PREFIX}$hostname bs=1 count=1 seek=$size $silent"
    );
    system("$shell{'MKSWAP'} $IMAGEDIR/${SWAP_PREFIX}$hostname $silent");
}

###################################
# Check that all commands are available
# before we start. Return false if not found.

sub checkForAllCommands {
    my $command;
    foreach $command ( keys %shell ) {
        if ( not stat( $shell{"$command"} ) ) {
            print STDERR "ERROR: command $shell{$command} not found\n";
            return 0;
        }
    }

    print "All commands correct\n";
    return 1;
}

sub usage {
    print STDERR "The command was not understood. Check the documentation or run 'mln usage'\n";
}

sub importMLNprojectHandler {
    my $opt_string = 'p:d:ozsr:q';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
    my $project = $opt{p};
    my $directory = $opt{d};
    my $overwrite = $opt{o};
    my $compress = $opt{z};
    my $shutdown = $opt{s};
    die "i need a project\n" if not $project;
    die "i need a directory\n" if not $directory;
    if ( stat($directory)){
	if ( $directory =~ /(\.tar\.gz$|\.tgz$)/ ){
	    out("uncompressing $directory\n");
	    system("tar xzvf $directory");
	    $directory =~ s/^(.*)(\.tar\.gz$|\.tgz$)/$1/;
	}	
    } else {
	die("Not found: $directory\n"); 
    }    

    
    if ( stat("$PROJECT_PATH/$project/$project.mln")){
	
	out("Project allready exists\n");
	$DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/$project.mln");    

	(my $amountTested,my $amountOK,my @return) 
	  = getStatus($PROJECT,"",1,0,$QUIET,0,not $SPAWNED_REMOTELY);
	@XM_LIST_CACHE = ();
	if ( $amountOK > 0 ){
	    if ( not $shutdown ){
		out("Some hosts in this project are still up. Rerun this command with the -s option to shut them down or take down the project manually\n");
		exit 1;
	    } else {
		out("$project is still up, shutting down...\n");
		stopProject($project,"","","","i");	    
	    }
	}
    }

    importMLNproject($project,$directory,$overwrite,$compress,$shutdown);
} 

sub importMLNproject {
    my $project = $_[0];
    my $directory = $_[1];
    my $overwrite = $_[2];
    my $compress = $_[3];
    my $shutdown = $_[4];
    my $project_file = $_[5];
    my $server = $_[6];
    
    # check if project allready exists and is running
    if ( not $SPAWNED_REMOTELY ){
	out( "+---> IMPORTING $project\n", "green" );
	  # if directory is compressed, unpack it
	$DATA_ROOT = buildDataTree("$directory/$project.mln");
    } else {
	$DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/$project.mln");
    }
    
    buildGlobalConfig();

    assignHostsToSwitches();

    checkKernels();

#    getImages();

#    out("Project is not installed\n");
    verifyDirectories("$PROJECT_PATH/$project",$IMAGEDIR,$NETDIR,$PIDDIR);   
    system("$shell{'CHMOD'} 777 $NETDIR");		
 
    
    saveConfig();
     
    if ( $server ){
	setProjectManager($server);
    } else {
	setProjectManager($SERVICE_HOST);
    }
    buildNetwork();
       
    # copy all the filesystems into place
    my $host;
    my %contacted_service_hosts;
    foreach $host (getHosts()){
	# silly hack and my own fault: 
	$LIVE_LIST{$host} = 1;
	
	
	my $service_host = getScalar("/host/$host/service_host");
	
	if ($SERVICE_HOST and $service_host and $service_host ne $SERVICE_HOST and not $SPAWNED_REMOTELY  ) {
	    
	    # host is remote, we need to push the filesystem

	    if ( not $contacted_service_hosts{$service_host} ){
		out("Fetching remote filesystems from $service_host\n");
		importMLNRemoteProject($service_host,$project,$directory);
		$contacted_service_hosts{$service_host} = 1;
	    } 
	} else { 
	    # host is local
	    my $handled_by_plugin = 0;
	    if ( not $SPAWNED_REMOTELY ){
		# - get device access if neccesary	    
		if ( %PLUGIN_LIST ){
		    
		    my $plugin;
		    foreach $plugin (keys %PLUGIN_LIST){
			my $subcall = $plugin . "_importFilesystem"; 
			my $return = &$subcall($host,$project,"$directory/images") if defined(&$subcall);
			if ($return) {
			    $handled_by_plugin = 1;
			    last;
			}
		    }
		}
		if ( not $handled_by_plugin ){
		    if ( getScalar("/host/$host/lvm")){
			my $vg = getScalar("/host/$host/lvm_vg");
			$vg = $DEFAULTS{'MLN_VG'} if not $vg;
			
			# check if LVM filesystem is present
			if ( stat("/dev/$vg/$host.$project")){
			    # - remove filesystem
			    system("lvremove -f /dev/$vg/$host.$project");
			}
		    
			# get size of image
			my $size = (stat("$directory/images/$host"))[7];
			$size = int(($size / 1024) / 1024);
			print "Size is ${size}M\n";


			# create filesystem
			system("lvcreate -L ${size}M -n $host.$project $vg");
			
			
			out("Transferring from $directory/images/$host to /dev/$vg/$host.$project\n");
			system("dd of=/dev/$vg/$host.$project if=$directory/images/$host bs=2048 status=noxfer");
		
		    } else {
#		    out("Copying image:\n");
			system("cp -v $directory/images/$host $PROJECT_PATH/$project/images/$host");
		    }
		}
	    }
	    # create startStop switches
	}
	# this method is outdated. There should be a Xen plugin!
	if (getScalar("/host/$host/xen")){
	    configure_host_XEN($host);
	} else {
#	configure_host_UML($hostname);
	}

	my $each;
	foreach $each (keys %PLUGIN_LIST){ 
	    my $call = $each . "_createStartStopScripts";
	    if ( defined(&$call) ){
		verbose("Calling plugin method $call\n");
		&$call($host);
	    }
	}
	
    }
    
}

sub importMLNRemoteProject {
    my $server = $_[0];
    my $project = $_[1];
    my $directory = $_[2];
    
    my $sock = new IO::Socket::INET(
	PeerAddr => $server,
	PeerPort => 34001,
	Proto    => 'tcp');
    
    if ( $sock ){
	print $sock "import:$project\n";
	my $line = <$sock>;
	
	# send config
	if ( $line eq "GET-CONFIG\n" ){
	    sendFile("$directory/${project}.mln",$sock);
	} else {
	    out("Danger, wrong response from server: $line\n");
	    return;
	}
	
	# service_host will ask for files
	
	$line = <$sock>;
	while ( $line ne "DONE\n" ){
#	    print "Response: $line\n";
	    if ( $line =~ /FILE:(.*)\n/ ){
		my $file = $1;
		verbose("Sending file: $file\n");
		my $target = "$directory/images/$file";
		print $sock "SEND-FILE\n";
		sendFile($target,$sock);
#		print "File transfer done\n";
	    } 
	    $line = <$sock>;
#	    print "Read: $line";
	    last if $line eq "";
	}
	
	# get import output
	$line = <$sock>;
	while ( $line ne "OUTPUT-END\n" ){
	    out($line);
	    $line = <$sock>;
	}
	verbose("$server: Done\n");
    } else {
	out("No socket to the remote server $server\n");
    }
    close($sock);    
}

sub exportMLNRemoteProject {

    my $server = $_[0];
    my $project = $_[1];
    my $directory = $_[2];
    
    my $sock = new IO::Socket::INET(
	PeerAddr => $server,
	PeerPort => 34001,
	Proto    => 'tcp');
    
    if ( $sock ){
	print $sock "export:$project\n";
	my $line = <$sock>;
	while ( $line ne "DONE\n" ){
#	    print "Response: $line\n";
	    if ( $line =~ /FILE:(.*)\n/ ){
		my $file = $1;
#		out("Receiving file: $file\n");
		my $target = "$directory/images/$file";
		print $sock "SEND-FILE\n";
		recieveFile($target,$sock);
#		print "File transfer done\n";
	    } 
	    $line = <$sock>;
#	    print "Read: $line";
	    last if $line eq "";
	}		
    } else {
	out("No socket to the remote server $server\n");
    }
    close($sock);

    
}

sub exportMLNproject {
    my $opt_string = 'p:d:ozsr:q';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
    my $project = $opt{p};
    my $directory = $opt{d};
    my $overwrite = $opt{o};
    my $compress = $opt{z};
    my $shutdown = $opt{s};

    # 2. Read the project file
    if ( not stat("$PROJECT_PATH/$project/$project.mln")){
	die "Failed to find file $PROJECT_PATH/$project/$project.mln: $!\n";
    }
    $DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/$project.mln");
    $PROJECT = $project;
    if ( $directory =~ /(^\.$)|(^\.\.)/ ){
	$directory = $directory ."/" . $project;
    }
    # 0. Check if project is up
#    out("Checking if any hosts are up.\n");
    (my $amountTested,my $amountOK,my @return) 
      = getStatus($PROJECT,"",1,0,$QUIET,0,not $SPAWNED_REMOTELY);
     @XM_LIST_CACHE = ();
    if ( $amountOK > 0 ){
	if ( not $shutdown ){
	    out("Some hosts in this project are still up. Rerun this command with the -s option to shut them down or take down the project manually\n");
	    exit 1;
	} else {
	    out("$project is still up, shutting down...\n");
	    stopProject($project,"","","","i");
#	    print "Stop project is done\n";
	}
    }
    # 1. See if folder is present or try to create it
    if ( stat("$directory/$project.mln") ){
	if ( $overwrite ){
#	    out("Removing old exported directory\n");
#	    system("rm -r $directory");

	} else {
	    out("$directory is non-empty. Use the -o option if you want to overwrite it.\n");
	    exit 1;
	}
    }
    
    if ( not stat("$directory/$project.mln") ){
	system("mkdir -p $directory");
	system("mkdir -p $directory/images");
    }
    
    # 3. Copy the project file
    system("cp $PROJECT_PATH/$project/$project.mln $directory");
        
    # 4. Copy all the filesystems
    my $host;
    my %contacted_service_hosts;
    foreach $host (getHosts()){
	my $service_host = getScalar("/host/$host/service_host");

	if ($SERVICE_HOST and $service_host and $service_host ne $SERVICE_HOST ) {
	    
	    # host is remote, we need to fetch the filesystem

	    if ( not $contacted_service_hosts{$service_host} ){
		out("Fetching remote filesystems from $service_host\n");
		exportMLNRemoteProject($service_host,$project,$directory);
		$contacted_service_hosts{$service_host} = 1;
	    } 
	} else { 
	    # host is local
	    my $handled_by_plugin = 0;
	    if ( %PLUGIN_LIST ){
		
		my $plugin;
		foreach $plugin (keys %PLUGIN_LIST){
		    my $subcall = $plugin . "_exportFilesystem"; 
		    my $return = &$subcall($host,$project,"$directory/images") if defined(&$subcall);
		    if ($return) {
			$handled_by_plugin = 1;
			last;
		    }
		}
	    }
	    if ( not $handled_by_plugin ){
		if ( getScalar("/host/$host/lvm")){
		    my $vg = getScalar("/host/$host/lvm_vg");
		    $vg = $DEFAULTS{'MLN_VG'} if not $vg;
		    out("Transferring from /dev/$vg/$host.$project\n");
		    system("dd if=/dev/$vg/$host.$project of=$directory/images/$host bs=2048 status=noxfer");
		
		} else {
#		    out("Copying image:\n");
		    system("cp -v $PROJECT_PATH/$project/images/$host $directory/images");
		}
	    }
	}
	
    }
	
    # 4.1 copy all start/stop scripts?
    
    # 5. Compress the directory
    if ( $compress ){
	out("Compressing $directory\n");
	system("tar czfv $directory.tar.gz $directory");
	system("rm -r $directory");
    }
}

sub printUsage {
    print "

USAGE: mln [ global-options ] command [ command-options ]

global options:    These options will work for every following command:
		   NOTE: use absolute path here.
 
       -T <dir>    Override the templates directory 
       -P <dir>    Override the projects directory 
       -F <dir>    Override the files directory         

       Example: mln -P /path/to/other/projects list


Commands: 	
	setup		    - configure MLN, download UML, and download default templates
	write_config	    - print the current configuration

	download_templates  - download file system image templates
	list_templates	    - list the templates which have been downloaded
        register_template   - add a manually created/downloaded template to the mln registry

	build		    - Given an mln description file, build a project
	upgrade		    - Given an mln description file, alter a project
        diff                - Print the diff from two projects         
        export              - Save a project into a directory
        import              - Import a saved project

	start		    - Start a host or a group of hosts in a project
	stop		    - stop a running host or group of hosts  
	list		    - list the current projects defined
        status              - Display what hosts are running or down

	enable_bridge	    - Enable a bridge on the network interface (for UML)
	disable_bridge	    - disable the bridge on the network interface (experimental)
	remove		    - remove a project
	version		    - print the version of mln

        parse               - write out the data structure from a project file and 
                              issue queries.
  
        daemon              - run the mln daemon for distributed management. Note, in order
                              to accept incoming connections, you need to define:
                              daemon_allow XX.XX.XX.XX in your mln.conf.
  
        daemon_status       - query a running mln daemon for status information. Note, 
                              you need to specify the hosts you wish to query as lines, i.e:
                              daemon_status_query hostname in your mln.conf.
 
        check_persistent    - Automatically boot projects which are supposed to be up 
                              all the time

command details:
        ./mln build [-u] [-s] [-d] [-v] [-r] -f config-file
	      Build a new project 

        -s         Simulate only.     
        -d         Debug mode.     
        -u         User mode. This avoids the mount command. 
        -r         Remove any earlier projects with the same name  
        -v         More output while building.
    

        ./mln export -p project -d directory [-o] [-z] [-s]
        
        -p         Name of project
        -d         Directory to store project
        -o         Overwrite existing
        -z         Create tarball
        -s        Shutdown virtual machines first

        ./mln import -p project -d directory[.tar.gz] [-s]
        
        -p         Name of project
        -d         Directory/tarball containing stored project
        -s        Shutdown virtual machines first

        ./mln upgrade [-S] [-k] [-u] [-s] [-d] -f config-file
              upgrade an existing project. 
               
        -S         Start the respective host after a rebuild 
        -k         Keep the old filesystems of machines that are deleted
    
        ./mln start -p project [ -h host ] [ -s seconds ]
	      Start a project

	-p          Project name
        -h          The name of a host in this project.
        -s          Sleep a number of seconds between each boot
 
        ./mln stop -p project [ -H ] [ -h host ] [ -s seconds ] [-w seconds]
	      Stop a host or a project
	-p          Project name      
        -h          The name of a host in this project.
        -s          Sleep a number of seconds between each shutdown
        -H          Force halt, terminates the hosts instantly
        -w          Wait a given ammount of time before the virtual machines are
                    shut down the hard way. This is useful if you have to take
                    a project down within a timespan. Example: -w 120 will 
                    give the virtual machines 120 seconds to shut down before
                    they are killed. '-w i' will in practice wait indefinatly,
                    and the mln stop command will not return untill all VMs are
                    down. 
 
        ./mln clean -p project [ -c ]
              Removes residual sockets from crashed UML VMs and switches. 
        -c    Perform an fsck on the filesystems too


        ./mln download_templates [ -u ] [ -t <templates local mirror dir> ]
              Download filesystem templates 
         -u   Only notify about templates that you don't have or
              newer versions of templates that you have.
         -t   Directory path to local UML binaries mirror

         ./mln register_template [ -m \"message\" ] -t template-name

         ./mln setup [ -l <UML local mirror dir> ] [ -t <templates local mirror dir> ]
	       Configure MLN, download UML, and download default templates.

         -l	    Directory path to local UML binaries mirror
         -t	    Directory path to local templates mirror
                
         ./mln write_config  -  Print your current configuration
 
         ./mln list	     -  Lists current projects.
                
         ./mln remove p	     -  Removes the project p.
 
         ./mln enable_bridge [ -e ethernet ] [ -t tap ] [ -b bridge ]
                
               Build an ethernet bridge between a tun/tap device and
	       an ethernet interface. Use this to make virtual network
	       will become a part of your LAN. 
                
         -e    Ethernet interface. Default is eth0.
         -b    Bridge device. Default is br0.
         -t    Tap device. Default is tap0.
          
         ./mln parse -f projectfile.mln [ -S query | -A query | -H query ]
               Print the data-tree structure after parsing a configuration file.
  
          -S path    Perform a query on the data according to getScalar(path)
                     Example: -S /host/jumbo/memory 

          -A path    Perform a query on the data according to getArray(path)
                     Example: -A /host/jumbo/modules 

          -H path    Perform a query on the data according to getHash(path)
                     Example: -S /host/jumbo 

         ./mln disable_bridge [ -e ethernet ] [ -t tap ] [ -b bridge ]
                Works opposite of enable_bridge. (EXPERIMENTAL)

         ./mln diff file1.mln file2.mln
               Writes the diff from two projects. Typically used before an upgrade
               to check that all is as intended. Example:
               mln diff myproject.mln myproject_new.mln
  
         ./mln daemon [ -D pidfile]
               Start the mln daemon. Warning: this software is still in beta and 
               should be used with caution.
  
         ./mln check_persistent
               MLN can monitor the status of projects which are supposed to be up
               constantly. Those projects need to be listed in /etc/mln/admin:
                           persistent project1
                           persistent project2
               The command needs to be rerun at the interval which suits you.
";
}

###################################
# Copy the files to be copied
# into the image.

sub copyFiles {
    my $hostname = $_[0];
    my $i;
#    my $temp   = $_[1];
    my @files  = getArray("/host/$hostname/files");
    my $target = $MOUNTDIR;
    verbose("copyFiles called\n");
    
    
    for ( $i = 0 ; $i <= $#files ; $i++ ) {
	
	my @file_line = split /\s+/, $files[$i];
        my $tmp_path = $FILES_PATH . "/" . $file_line[0];

	my $file_path = getValue($tmp_path);
        #	    sleep 4;
        my $pwd = `pwd`;
        chomp $pwd;
	my $target_file = getValue($file_line[1]);
	
        #	    print "copyFile $pwd/$file_path\n";
        if ( stat("$file_path") ) {

            my $temp_target = $target;
            verifyPath($temp_target . $target_file);
            verbose("cp -fr $file_path $temp_target" . $target_file . "\n");
            system(
                "$shell{'CP'} -fr $file_path $temp_target" . $target_file );
	    if ( $file_line[2] ){
		system( "$shell{'CHMOD'} -R "
		    . $file_line[2]
		    . " $temp_target"
		    . $target_file );
	    }
        }
        else {
            print STDERR "ERROR: file $file_path not found\n";
        }

    }

}


sub setProjectName {
    $PROJECT = $_[0];
#    $GLOBAL = new Global unless $GLOBAL;
#    $GLOBAL->project("$PROJECT");

    #      print "Project name: $PROJECT\n";
    $IMAGEDIR     = $PROJECT_PATH . "/" . $PROJECT . "/" . $IMAGEDIR_NAME;
    $PIDDIR       = $PROJECT_PATH . "/" . $PROJECT . "/" . $PIDDIR_NAME;
    $NETDIR       = $PROJECT_PATH . "/" . $PROJECT . "/" . $NETDIR_NAME;
    $START_SCRIPT = $PROJECT_PATH . "/" . $PROJECT . "/" . $START_SCRIPT;
    $STOP_SCRIPT  = $PROJECT_PATH . "/" . $PROJECT . "/" . $STOP_SCRIPT;

}


##################
#
#
#
##################

sub parse_mln_config_file {

    #      print "parsing file $_[0]\n";
    my $CONF = $_[0];

    #      if ( not $STDIN_MODE ) {
    #      open (CFILE,"$CONF") or die "Failed to open file $CONF\n";
    #      }
    if ( $STDIN_MODE ) {
	$CONF = STDIN;
    }
    my @line;
    @line = getCLine( $CONF );

    while ( not $line[0] eq "MLN_END" ) {

        debug("parser: @line");

        #	  @line = split /\s+/, $l;

        if ( $line[2] =~ /\{/ or $line[1] =~ /\{$/ ) {
            if ( $line[0] =~ /^switch$/ ) {

                # We found a switch and call the appropriate handler
                my $temp = switchParser( $line[1] );
                my $name = $temp->name;
                $SWITCHES{$name} = $temp;
            }
            elsif ( $line[0] =~ /^host$/ ) {

                # We found a host, and call the appropriate handler
                debug("Found a host $line[1]\n");

                # strip an eventual '{' that clings to the hostname
                $line[1] =~ s/\{$//;
                my %temp = hostParser( getValue( $line[1] ), 'host' );
                my $name = $temp{"hostname"};
                $HOSTS{$name} = \%temp;
            }
            elsif ( $line[0] =~ /^global/ ) {

                # We found a switch and call the appropriate handler
                debug("Parsing global settings\n");
                my $temp = globalParser();
                $GLOBAL = $temp;
                debug( "got global with name ", $GLOBAL->project, "\n" );

                #	    exit 1 if not checkForAllCommands();
            }
            elsif ( $line[0] =~ /^superclass/ ) {

                # We found a switch and call the appropriate handler
                #		  debug("Parsing global settings\n");
                my %temp = hostParser( getValue( $line[1] ), 'superclass' );
                my $name = $temp{'hostname'};
                $HOSTS{$name} = \%temp;

                #	    exit 1 if not checkForAllCommands();
            }
            elsif ( $line[0] =~ /^virtual_site/ ) {
                debug("Calling virtualSiteParser");
                virtualSiteParser();

            }

        }

        @line = getCLine();
    }
}

sub debug {
    print "DEBUG: $_[0]\n" if ( $DEBUG == 1 );
}

#########################

# sub hostParser {
#     my $NetDevices = 0;
#     my %host;
#     my @line;
#     $host{"hostname"} = $_[0];
#     $host{"type"}     = $_[1];

#     if ( $host{'type'} eq "superclass" ) {
#         $SUPERCLASS_COUNTER++;
#     }
#     else {
#         $HOST_COUNTER++;
#     }

#     debug("########################################");
#     debug("Parsing host named $host{'hostname'}");
#     debug("########################################");

#     while ( @line = getCLine() ) {

#         #	  chomp $l;

#         #	  $l =~ s/^\s*//;

#         #	  @line = split /\s+/, $l;

#         debug("hostParser: Reading @line");
#         last if $line[0] =~ /\}/;

#         if ( $line[0] =~ /^template/ ) {
#             $host{"template"} = getValue( $line[1] );
#         }
#         elsif ( $line[0] =~ /^(cow_filesystem|cow)$/ ) {
#             $host{"cow_filesystem"} = getValue( $line[1] );
#             debug("Cow_Filesystem: $host{'cow_filesystem'}");
#         }
#         elsif ( $line[0] =~ /root_password/ ) {
#             $host{"root_password"} = getValue( $line[1] );
#             debug "Root password: $host{'root_password'}\n";
#         }
#         elsif ( $line[0] =~ /service_host/ ) {
#             $host{"service_host"} = getValue( $line[1] );
#             debug "Service host: $host{'service_host'}\n";
#         }
#         elsif ( $line[0] =~ /size/ ) {
#             $host{"size"} = getValue( $line[1] );
#             debug("Size: $host{'size'}");

#         }
#         elsif ( $line[0] =~ /swap/ ) {
#             $host{"swap"} = getValue( $line[1] );
#             debug("Swap: $host{'swap'}");

#         }
#         elsif ( $line[0] =~ /nameserver/ ) {
#             $host{"nameserver"} = getValue( $line[1] );
#             debug(
#                 "hostParser: nameserver is assigned value $host{'nameserver'}");
#         }
#         elsif ( $line[0] =~ /owner/ ) {
#             $host{"owner"} = getValue( $line[1] );
#             debug("hostParser: owner is assigned value $host{'owner'}");
#         }
#         elsif ( $line[0] =~ /^group$/ ) {
#             $host{"group"} = getValue( $line[1] );
#             debug("hostParser: group is assigned value $host{'group'}");
#         }
#         elsif ( $line[0] =~ /sudo/ ) {
#             $host{"sudo"} = getValue( $line[1] );
#             debug("hostParser: sudo is assigned value $host{'sudo'}");
#         }
#         elsif ( $line[0] =~ /color/ ) {
#             $host{"color"} = getValue( $line[1] );
#             debug("Color: $host{'color'}");
#         }
#         elsif ( $line[0] =~ /free_space/ ) {
#             $host{"free_space"} = getValue( $line[1] );
#             debug("Free space: $host{'free_space'}");
#         }

#         elsif ( $line[0] =~ /memory/ ) {
#             $host{"memory"} = getValue( $line[1] );

#             debug("Memory: $host{'memory'}");
#         }
#         elsif ( $line[0] =~ /boot_order/ ) {
#             $host{"boot_order"} = getValue( $line[1] );
#             debug("boot_order: $host{'boot_order'}");
#         }
#         elsif ( $line[0] =~ /term/ ) {
#             $host{"term"} = getValue( $line[1] );
#             debug("Term for this host is: $host{'term'}");
#         }
#         elsif ( $line[0] =~ /superclass/ ) {
#             $host{"superclass"} = getValue( $line[1] );
#             debug("Superclass for this host is: $host{'superclass'}");
#         }
#         elsif ( $line[0] =~ /kernel/ ) {
#             $host{"kernel"} = getValue( $line[1] );
#             debug("Kernel for this host is: $host{'kernel'}");
#         }
#         elsif ( $line[0] =~ /nice/ ) {
#             $host{"nice"} = getValue( $line[1] );
#             debug("nice-value for this host is: $host{'nice'}");
#         }
#         elsif ( $line[0] =~ /devfs/ ) {
#             $host{"devfs"} = getValue( $line[1] );
#             debug("Devfs option for this host is: $host{'devfs'}");
#         }
#         elsif ( $line[0] =~ /modules_dir/ ) {
#             $host{"modules_dir"} = getValue( $line[1] );
#             debug("Modules_dir for this host is: $host{'modules_dir'}");
#             push( @MODULE_DIRS, $host{'modules_dir'} );
#         }
#         elsif ( $line[0] =~ /family/ ) {
#             $host{"family"} = getValue( $line[1] );
#             debug("family for this host is: $host{'family'}");
#         }
#         elsif ( $line[2] =~ /\{/ or $line[1] =~ /\{/ ) {
#             debug("hostParser: block found: $line[0]");
#             if ( $line[0] =~ /network/ ) {
#                 debug( "Found network: ", $line[1], "\n" );
#                 my $netd = networkParser( getValue( $line[1] ) );
#                 $host{"network"}{ $netd->iface } = $netd;

#             }
#             elsif ( $line[0] =~ /modules/ ) {
#                 $host{"copy_modules"} = "yes";
#                 my @my_modules = moduleParser();
#                 $host{"modules"} = \@my_modules;

#                 my $test  = $host{"modules"};
#                 my @array = @$test;


#             }
#             elsif ( $line[0] =~ /^startup$/ ) {
#                 my @startup = startupParser();
#                 $host{"startup"} = \@startup;
#             }
# 	    elsif ( $line[0] =~ /^groups$/ ) {
# 		my %groups = groupsParser();
# 		$host{"groups"} = \%groups;
# 		debug("hostParser: groups block detected");
# 	    }

#             elsif ( $line[0] =~ /^mount$/ ) {
#                 my @mount = mountParser();
#                 $host{"mount"} = \@mount;
#             }
#             elsif ( $line[0] =~ /^dyndns$/ ) {
#                 my $dyndns = dyndnsParser();
#                 $host{"dyndns"} = $dyndns;
#             }
#             elsif ( $line[0] =~ /^users$/ ) {
#                 my @users = usersParser();
#                 $host{"users"} = \@users;
#             }
#             elsif ( $line[0] =~ /^roles$/ ) {
#                 my @roles = rolesParser();
#                 $host{"roles"} = \@roles;
#             }
#             elsif ( $line[0] =~ /files/ ) {
#                 my @files = filesParser();
#                 $host{"files"} = \@files;

#             }
#             elsif ( $line[0] =~ /vtun/ ) {
#                 my @vtun = vtunParser();
#                 $host{"vtun"} = \@vtun;
#             }
#         }
#     }

#     my $tm;

#     foreach $tm ( keys %host ) {
#         $USED_VARIABLES{$tm} = 1;
#     }

#     return %host;

# }

# This is
sub pluginParser {

    debug("PluginParser called\n");
    my %plugin;
    my $bracket_stack = 0;
    my $l;
    my $line_counter  = 1;
    my $block_counter = 1;

    while ( $l = getInputItem() ) {

        chomp $l;
        debug("read: '$l'\n");
        $l =~ s/^(\s*)//g;
        last if ( $l =~ /\}/ );

        if ( $l =~ /(.*)(\w*)\{$/ ) {

            # we are dealing with a block
            $bracket_stack++;
            debug("New block: $1\n");
            my $block_name = $1;
            my %block      = pluginParser();

            $plugin{"block_${block_counter}_${block_name}"} = \%block;

            #	    $block_counter++;
        }
        else {

            if ($l) {
                debug("New line: '$l'\n");
                $plugin{"line_${line_counter}"} = $l;
                $line_counter++;
            }
        }
    }

    return %plugin;
}

sub checkKernels {

    my $each;

    foreach $each ( getHosts() ) {

        my $kernel_version;

        my $kernel = getScalar( "/host/$each/kernel");

        if ($kernel) {

            $kernel_version = `$kernel --version`;
            chomp $kernel_version;
        }
        else {
            $kernel_version = $DEFAULTS{KERNEL_VERSION};
            $HOSTS{$each}{'kernel'} = $DEFAULTS{KERNEL};
        }

        $HOSTS{$each}{'kernel_version'} = $kernel_version;
    }

}


sub registerInputFiles {

}

sub getInputItem {

    if (@PARSE_STACK) {
        debug("returning from stack");
        return pop(@PARSE_STACK);
    }
    my $input_buffer;
    my $char;
    $char = getc($CURRENT_INPUT);
    while ( not eof($CURRENT_INPUT) ) {

        #	  print "GIL READ: '$char'\n";
        if ( $char eq "}" and not $input_buffer =~ /#/ ) {

            # end character detected
            if ( $input_buffer ne "" ) {
                push( @PARSE_STACK, $char );

                #	      print "1. GIL: $input_buffer\n";
                return $input_buffer;
            }
            else {
                return $char;
            }

        }
        elsif ( $char eq "\n" or $char eq "{" ) {

            $input_buffer .= $char;

            #	      print "2. GIL: $input_buffer\n";
            return $input_buffer;

        }
        elsif ( $char eq ";" ) {

            #	      print "3. GIL: $input_buffer\n";
            return $input_buffer . "\n";

        }
        elsif ( $char eq "\\" ) {

            $input_buffer .= getc($CURRENT_INPUT);

        }
        else {
            $input_buffer .= $char;
        }

        $char = getc($CURRENT_INPUT);
    }
}

sub getCLine {
    my @line;
    my $l;
    my $config;
    my $item;
#	print "getCLine: $_[0]\n"; 
    # check if the main file is not opened:
     if ( $_[0] ) {
#        	print "config was supplied: $_[0]\n";
        $config = $_[0];
    }
    else {
        $config = $CONFIGFILE;
    }

    if ( not $MAIN_FILE_OPENED ) {

#        	print "opening file $config\n";
	if ( not $STDIN_MODE ) {
	    $INPUT_STACK[0] = new IO::File;
	    $INPUT_STACK[0]->open("$config")
	      or warn "FATAL: Failed to open project file $config: $!\n";
	    $CURRENT_INPUT    = $INPUT_STACK[0];
	} else {
#	    $INPUT_STACK[0] = new IO::File;
	    $INPUT_STACK[0] = STDIN;
	    $CURRENT_INPUT    = $INPUT_STACK[0];
	}
        $MAIN_FILE_OPENED = 1;
    }

    $l = getInputItem();
    while (1) {
        debug("getCLine: in: '$l'");
        if ( not $l and not @INPUT_STACK ) {
            debug("getCLine: No more input\n");
	    if( not $STDIN_MODE ){
		$CURRENT_INPUT->close if $CURRENT_INPUT;
	    }
            # print "MLN_END\n";
            # if ($CONFIGURE_HOSTS_ONLY ) {
            # 	  exit 1;
            # }
#
            return "MLN_END";

        }
        elsif ( $l =~ /#include (.*)\n/ ) {

            my $file = new IO::File;
            my $filename;

            $filename = $1;

            #	      print "getCLine: opening include file: $filename\n";
            $file->open("$filename")
              or die "FATAL: Failed to open include file: $filename, $!\n";

            #	      push(@INPUT_FILES,$filename);
            push( @INPUT_STACK, $CURRENT_INPUT );
            $CURRENT_INPUT = $file;
            $l             = getInputItem();
            next;

        }
        elsif ( not $l ) {
            debug("getCLine: pop-ing old file from input stack\n");
	    if ( not $STDIN_MODE ) { 
		$CURRENT_INPUT->close;
	    }
            $CURRENT_INPUT = pop(@INPUT_STACK);
            $l             = getInputItem();
            next;
        }

#        push( @CONFIG_FILE_TRANSCRIPT, $l );
        chomp $l;
        debug("getCLine: in: $l");
	
#	$l =~ s/(\S*)(\{)/$1 $2/;
        $l =~ s/\s*#.*$//;
        $l =~ s/^\s*//;
        $l =~ s/\s*$//;
        debug("getCLine: pruned ,$l,");

        last if $l;
        $l = getInputItem();
    }

    #   print "returning: $l\n";
    @line = split /\s+/, $l;
    debug("getCLine: returning @line");

    return @line;

    # if ($l)
    # {
    # 	chomp $l;
    # }
}

sub getRestAsString {
    my $start = $_[0];
    my $temp  = $_[1];
    my $delimiter = $_[2];
    my @array = @$temp;

    $delimiter = " " if ( not $delimiter );

    my $i;
    my $string;

#    debug("my array is $#array long");

    for ( $i = $start ; $i <= $#array ; $i++ ) {
        $string .= $array[$i];
	if ( not $i == $#array ) {
	    $string .= $delimiter;
	}
    }
    debug("getRestAsString returning '$string'");
    return $string;

}

 sub printGlobal {
 #    if ($GLOBAL) {
 #        out("\n");
         #	    out ("############################ \n","cyan");
#         out( "++ printing global settings ++\n", "cyan" );

         #	    out ("############################\n","cyan");
#         out("Project:\t". $PROJECT ."\n");

         #	    print "local:\t" , $LOCAL , "\n";
 #        out( "Default uml kernel:  $DEFAULTS{KERNEL} ($DEFAULTS{KERNEL_VERSION})\n ");
  #       out("Default module path: $DEFAULTS{MODULE_PATH}\n");

#        my $vars = $GLOBAL->variables;
#         my $i;
#         my $key;
#         if ( keys %$vars ) {
#             print "--> Variables:\n";
#             foreach $key ( keys %$vars ) {
#                 print "var:\t$key\t$$vars{$key}\n";
#             }
#         }

# #        if ( keys %PLUGIN_LIST ) {
# #
# #            my $each;
# #            out( "Registered plugins:\n", "blue" );
# #            foreach $each ( keys %PLUGIN_LIST ) {
# #
#  #               out("$each: $PLUGIN_LIST{$each}\n");

# #            }

#  #       }

#         if ( $GLOBAL->virtual_site ) {

#             out("--> Virtual Site settings:\n");

#             #		print "# keys:\n";
#             #		my $key;
#             #		foreach $key ( keys %VIRTUALSITE )
#             #		  {
#             #		      print "# -> $key\n";
#             #		  }

#             if ( $VIRTUALSITE{'adminusers'} ) {

#                 #		print "Test: $VIRTUALSITE{'test'}\n";

#                 print "# AdminUsers: \n";

#                 my $tm    = $VIRTUALSITE{'adminusers'};
#                 my @array = @$tm;
#                 my $au;
#                 foreach $au (@array) {
#                     print "#      -> $au\n";
#                 }
#             }
#             if ( $VIRTUALSITE{'dnsforwarders'} ) {

#                 #		print "Test: $VIRTUALSITE{'test'}\n";

#                 print "# DNS forward to: \n";

#                 my $tm    = $VIRTUALSITE{'dnsforwarders'};
#                 my @array = @$tm;
#                 my $df;
#                 foreach $df (@array) {
#                     print "#      -> $df\n";
#                 }
#             }

#             if ( $VIRTUALSITE{'policyhost'} ) {
#                 print "# policyhost: \n   -> $VIRTUALSITE{'policyhost'}\n";
#             }

#             if ( $VIRTUALSITE{'domain'} ) {
#                 print "# domain: \n   -> $VIRTUALSITE{'domain'}\n";
#             }

#         }
#     }
}


# sub networkParser {
#     my $l;
#     my @line;

#     my $netd = new NetDevice;
#     $netd->iface( getValue( $_[0] ) );
#     $netd->auto(1);

#     while ( @line = getCLine() ) {

#         last if $line[0] =~ /\}/;

#         #	    $l =~ s/^\s*//;

#         #	    @line = split /\s+/, $l;
#         #	    print "0: $line[0] 1: $line[1]\n";

#         if ( $line[0] =~ /switch/ ) {
#             if ( $line[$1] =~ /tap./ ) {

# #		      print "Iface ",$netd->iface," is connected to a tun/tap device: $line[1]\n";

#             }
#             else {

#              #		      print "Iface ",$netd->iface," is connected to $line[1]\n";
#                 $netd->switch( getValue( $line[1] ) );
#             }
#         }
#         elsif ( $line[0] =~ /^address$/ ) {
#             $netd->address( getValue( $line[1] ) );
#         }
#         elsif ( $line[0] =~ /^tun_iface$/ ) {
#             $netd->tun_iface( getValue( $line[1] ) );
#         }
#         elsif ( $line[0] =~ /^tun_address$/ ) {
#             $netd->tun_address( getValue( $line[1] ) );
#         }

#         elsif ( $line[0] =~ /netmask/ ) {
#             $netd->netmask( getValue( $line[1] ) );
#         }
#         elsif ( $line[0] =~ /^mac$/ ) {
#             $netd->mac( getValue( $line[1] ) );
#         }
#         elsif ( $line[0] =~ /gateway/ ) {
#             $netd->gateway( getValue( $line[1] ) );
#         }
#         elsif ( $line[0] =~ /broadcast/ ) {
#             $netd->broadcast( getValue( $line[1] ) );
#         }
#         elsif ( $line[0] =~ /slirp/ ) {
#             if ( $line[1] ) {
#                 $netd->slirp( getValue( $line[1] ) );
#             }
#             else {
#                 $netd->slirp( $DEFAULTS{SLIRP} );
#             }
#         }
#         elsif ( $line[0] =~ /auto/ ) {
#             if ( getValue( $line[1] ) =~ /yes|y|on|auto|enable/i ) {
#                 $netd->auto(1);
#             }
#             else {
#                 $netd->auto(0);
#             }
#         }

#     }

#     return $netd;
# }


sub setGroups {
    print "setGroups called\n";
    my $hostname = $_[0];
    my $FAILOVER;
    my %hash = getHash("/host/$hostname/groups");
    
    
    my $each;
    foreach $each (keys %hash) {
	out("creating group: $each\n");
        system("$shell{'CHROOT'} $MOUNTDIR groupadd $each");
	
	my $tm = $hash{$each};
	
	my @users = getArray("/host/$hostname/groups/$each");
	if (@users){
	    out("Adding users to group: \n");
	    my $user;
	    foreach $user ( @users){
#		out("$user ");
		chomp($user);
#		print "$shell{'CHROOT'} $MOUNTDIR usermod -G $each $user\n";
		system("$shell{'CHROOT'} $MOUNTDIR usermod -G $each $user");
		if ( $FAILOVER or ( stat("$MOUNTDIR/home") and not stat("$MOUNTDIR/home/$user")) ){
		    out("MLN needs to add the user using a start-script\n");
		    $FAILOVER = 1;
		    open(STARTUP,">>$MOUNTDIR/etc/init.d/startup_once"); 
		    print STARTUP "usermod -G $each $user\n";
		    close(STARTUP);
		}

	    }
	    system("sync");
	    out("\n");	    
	}
    }    
}

# sub groupsParser {
    
#     my %groups;
#     my @line;
#     my $i;
#     my $j;
#     while ( @line = getCLine() ) {
# 	last if $line[0] =~ /\}/;
# #	print "adding group $line[0]\n";
# 	if ( $line[1] =~ /\{/ ){
# 	    debug("new group $line[0]\n");
# 	    my $group = getValue($line[0]);
# 	    my @groups_array;
# 	    $j = 0;
# 	    while( @line = getCLine() ) {
# 		last if $line[0] =~ /\}/;
# 		for($i = 0; $i <= $#line; $i++ ){
# 		    $groups_array[$j++] .= " " . getValue($line[$i]);
# 		    debug("adding $line[$i] to $group\n");
# 		}
# 	    }
# 	    $groups{$group} = \@groups_array;
# 	}


#     }

#     # my $each;
#     # foreach $each (@groups_array) {
#     # 	print "$each\n";
#     # }

#     verbose("added " - length(%groups) . " groups\n");
#     return %groups;
# }

# sub switchParser {
#     my $switch = new Switch;
#     my @line;

#     $switch->name( $_[0] );
#     while ( @line = getCLine() ) {

#         #	    print "switchParser: $line[0]\n";
#         last if $line[0] =~ /\}/;
#         if ( $line[0] =~ /type/ ) {
#             $switch->type( getValue( $line[1] ) );
#         }
#         elsif ( $line[0] =~ /socket/ ) {
#             $switch->sock( getValue( $line[1] ) );

#             #		print "Setting socket to: ", $switch->sock , "\n";
#         }
#         elsif ( $line[0] =~ /group/ ) {
#             $switch->group( getValue( $line[1] ) );

#             #		print "Setting socket to: ", $switch->sock , "\n";
#         }
#         elsif ( $line[0] =~ /owner/ ) {
#             $switch->owner( getValue( $line[1] ) );

#             #		print "Setting socket to: ", $switch->sock , "\n";
#         }
#         elsif ( $line[0] =~ /sudo/ ) {
#             $switch->sudo( getValue( $line[1] ) );

#             #		print "Setting socket to: ", $switch->sock , "\n";
#         }
#         elsif ( $line[0] =~ /tap/ ) {
#             $switch->tap( getValue( $line[1] ) );

#             #		print "Setting tap to: ", $switch->tap , "\n";
#         }
#         elsif ( $line[0] =~ /service_host/ ) {
#             $switch->service_host( getValue( $line[1] ) );

#             #		print "Setting tap to: ", $switch->tap , "\n";
#         }
#     }
#     return $switch;

# }

# sub moduleParser {
#     my @modules;
#     my $i;
#     my $l;
#     my @line;
#     debug("moduleParser: called");
#     while ( @line = getCLine() ) {

#         #	  $l =~ s/^\s*//;
#         #	  @line = split /\s+/, $l;

#         last if $line[0] =~ /\}/;

#         $modules[ $i++ ] = getValue( $line[0] )
#           and debug("moduleParser: reading field $line[0]")
#           unless $line[0] =~ /\{/;

#     }

#     return @modules;

# }

sub printHosts {

    my $i;
    my $xml;

    my @superclasses = getSuperclasses();

    if ( @superclasses ){
    out( "++ printing Superclasses ++\n", "cyan" );
    
        foreach $i ( @superclasses ) {

                printHost($i,$xml,"superclass");
        }
    }

    out( "++ printing Hosts ++\n", "cyan" );
    
    foreach $i ( getHosts() ) {
	printHost($i,$xml,"host");
    }
    $HOST_COUNTER = 0;
}

sub printHost {
    my $i    = $_[0];
    my $xml  = $_[1];
    my $type = $_[2];
    my $xen = getScalar("/$type/$i/xen");
    
    if ( $type =~ /superclass/ ) {
        out("--> Superclass ");
        out( $i . "\n", "blue" );
    }
    else {       
        out("--> Host ");
        out( $i, "lightgreen" );
	out (" (XEN)") if $xen;
	out("\n");
    }
    my $lvm = getScalar("/host/$i/lvm");
    if ( $lvm) {
	my $vg = getScalar("/host/$i/lvm_vg");
	$vg = $DEFAULTS{'MLN_VG'} if not $vg;
	out("LVM: /dev/$vg/$i.$PROJECT\n");
    }
    printScalarVariable( $i, 'nameserver',     $xml );
    printScalarVariable( $i, 'kernel',         $xml );
    printScalarVariable( $i, 'kernel_version', $xml );
    printScalarVariable( $i, 'modules_dir',    $xml );
    printScalarVariable( $i, 'superclass',     $xml );
    printScalarVariable( $i, 'term',           $xml );
    printScalarVariable( $i, 'swap',           $xml );
    printScalarVariable( $i, 'sudo',           $xml );
    printScalarVariable( $i, 'owner',          $xml );
    printScalarVariable( $i, 'group',          $xml );
    printScalarVariable( $i, 'root_password',  $xml );
    printScalarVariable( $i, 'service_host',   $xml );
    printScalarVariable( $i, 'boot_order',     $xml );
    printScalarVariable( $i, 'memory',         $xml );
    printScalarVariable( $i, 'color',          $xml );
    printScalarVariable( $i, 'family',         $xml );
    printScalarVariable( $i, 'size',           $xml );
    printScalarVariable( $i, 'free_space',     $xml );
    printScalarVariable( $i, 'nice',           $xml );
    printScalarVariable( $i, 'devfs',          $xml );

    verbose("$i: This image exists from before\n")
      if getScalar( "/host/$i/exists" );
    my $template = getScalar("/$type/$i/template");

    $template = $DEFAULTS{TEMPLATE} if ( not $template );
    my $latest = getLatestTemplate($template);
    print "$i: template = $latest\n";
    printScalarVariable( $i, 'cow_filesystem' );

    my $tm;
    my $temp;
#    $temp = getScalar("/host/$i/dyndns");
#    if ($temp) {
#        print "$i: dyndns user: " . $temp->user . "\n";
#        print "$i: dyndns password: " . $temp->password . "\n";
#        print "$i: dyndns hostname: " . $temp->hostname . "\n";

#    }

    my @array = getArray("/$type/$i/modules");

    if (@array) {
        my $number = $#array + 1;
        my $each;
        print "Number of modules: $number\n";
        foreach $each (@array) {
            print "module $each\n";
        }
    }

    my @array = getArray("/host/$i/startup" );

    if (@array) {
        my $each;
        foreach $each (@array) {
            print "startup: $each\n";
        }
    }

    my %hash = getHash("/$type/$i/groups");

    if (%hash) {
        my $each;
        foreach $each (keys %hash) {
#	    print "- @groups\n";
            print "groups: $each ";
	    
	    my @users = getArray("/$type/$i/groups/$each");
	    
	    foreach $user (@users){
		print "$user ";
	    }
	    print "\n";
        }
    }

   
    my @array = getArray("/host/$i/mount");

    if (@array) {
        my $each;
	print "mount:\n";
        foreach $each (@array) {
	    my @line = split /\s+/,$each;
	    print "disk: $line[0], mount-point: $line[1], type: $line[2]";
	    if ( $line[3] ){
		print " options: $line[3]";
	    } 
	    print "\n";
        }
    }

    
    my @array = getArray("/host/$i/vtun");

    if (@array) {
        my $each;
        foreach $each (@array) {
            print "vtun: $each\n";
        }
    }

    my %network = getHash("/$type/$i/network");

    if (%network) {
	print "printing network\n";
        print "$i: Network interfaces\n";
        my $each;
        foreach $each ( keys %network ) {

            print "Interface " . $each ."\n";
            if ( $network{$each}{"address"} ) {
                print " address: " . $network{$each}{"address"} . "\n";
            }
            elsif ( $network{$each}{"slirp"} ) {
                print " address: $DEFAULTS{SLIRP_IF_ADDR}\n";
            }
            if ( $network{$each}{"netmask"} ) {
                print "  netmask: " . $network{$each}{"netmask"} . "\n";
            }
            if ( $network{$each}{"tun_iface"} ) {
                print "  tun iface: " . $network{$each}{"tun_iface"} . "\n";
            }
            if ( $network{$each}{"tun_address"} ) {
                print "  tun address: " . $network{$each}{"tun_address"} . "\n";
            }
            if ( $network{$each}{"gateway"} ) {
                print "  gateway: " . $network{$each}{"gateway"} . "\n";
            }
            if ( $network{$each}{"broadcast"} ) {
                print "  broadcast: " . $network{$each}{"broadcast"} . "\n";
            }
            if ( $network{$each}{"mac"} )   { print "  MAC: " . $network{$each}{"mac"} . "\n"; }
            if ( $network{$each}{"auto"} )   { print "  auto: " . $network{$each}{"auto"} . "\n"; }
            if ( $network{$each}{"slirp"} ) {
                print " slirp enabled " . $network{$each}{"slirp"} . "\n";
            }
        }

    }

    my @array = getArray("/host/$i/users");
    if (@array) {
        print "### users:\n";
        my $each;
        foreach $each (@array) {
	    print $each . "\n";
        }

    }
    my @array = getArray("/host/$i/files");
    if (@array) {
        print "$i: files:\n";
        my $each;
        foreach $each (@array) {
            print "$each\n";
        }

    }
    if ( %PLUGIN_LIST ){

	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    my $subcall = $plugin . "_printHost"; 
	    &$subcall($i) if defined(&$subcall);
	}
    }
}

sub printPlugin {

    my $pl     = $_[0];
    my %plugin = %$pl;
    my $each;
    my $print_xml = $_[1];
    my @xml       = ();
    my $i;

    foreach $each ( keys %plugin ) {
        if ( $each =~ /line_(\d+)/ ) {

            if ($print_xml) {
                my @line_array = split /\s+/, $plugin{$each};
                my $row = $1;
                my $element;
                my $i = 1;

                push( @XML_DOC, "<plugin_line row=\"$row\">" );
                foreach $element (@line_array) {
                    push( @XML_DOC,
                        "<line_element index=\"" . $i
                          ++ . "\">$element</line_element>" );
                }
                push( @XML_DOC, "$plugin{$each}" );
                push( @XML_DOC, "</plugin_line>" );

                push( @XML_DOC, "  " );

            }
            else {
                out("$plugin{$each}\n");
            }
        }
        elsif ( $each =~ /block_(\d+)_(.*)/g ) {
            if ($print_xml) {

                push( @XML_DOC, "<plugin_block name=\"$2\">" );
            }
            else {
                out("$2 {\n");
            }
            $pl = $plugin{$each};
            my %plug = %$pl;
            printPlugin( \%plug, $print_xml );

            if ($print_xml) {

                push( @XML_DOC, "</plugin_block>" );
            }
            else {
                out("}\n");
            }
        }
    }

}

sub getValue {
    my $value = $_[0];
    my $root = $_[2];
    my $path = $_[1];
    my $result = $value;

     while ( $value =~ s/(.*)(\$(\[|)([a-zA-Z0-9\_]+)(\]|))(.*)/$1 $6/) {    
	my $var = '$' . $4;
	 verbose("Looking for variable: $var\n");
	 if ( $var eq '$hostname' ){
	     verbose("Variable calls for hostname in path: $path\n");
	     # get hostname
	     verbose("Hostname is $CURRENT_HOSTNAME\n");
	     $var =~ s/^\$//;
	     if ( $CURRENT_HOSTNAME ){
		 $result =~ s/\$(\[|)$var(\]|)/$CURRENT_HOSTNAME/g;
		 verbose("Returning: $result\n");
		 next;
	     } elsif ( $path =~ /^\/host\/([^\/]+)/ ){
		 my $tempname = $1;
		 verbose("Guessing $tempname as hostname\n");
		 $result =~ s/\$(\[|)$var(\]|)/$tempname/g;
		 verbose("Returning: $result\n");
		 next;
	     }
#	     return $result;
	 }
	 if ( $var eq '$project' ){
	     verbose("Variable calls for project ($PROJECT) in path: $path\n");
	     # get hostname
	     $var =~ s/^\$//;
	     $result =~ s/\$(\[|)$var(\]|)/$PROJECT/g;
	     verbose("Returning: $result\n");
	     next;
#	     return $result;
	 }
	 
	 my $exp;
	 while ($path and $path =~ /(\/superclass|\/host)/) {
	     if ($root){
		 $exp = getScalar("$path/$var",$root);
	     } else {
		 $exp = getScalar("$path/$var");
	     }
	     last if $exp;
	     $path =~ s/\/([a-zA-Z0-9]+)$//;
	 }
	 if ( not $exp ) {
	     if ($root){
		 $exp = getScalar("/global/$var",$root);
	     } else {
		 $exp = getScalar("/global/$var");
	     }
	 }
	 if($exp){
#	     print "found $var = ($exp)\n";
	     $var =~ s/^\$//;
	     $result =~ s/\$(\[|)$var(\]|)/$exp/g;
	 } else {
#	     print "not found\n";
	 }
	 
     }
#    print "getValue returning: $result\n";
    return $result;
}

sub getVariable {
    verbose("Warning: getVariable called and is no longer supported\n");
    my $host     = $_[0];
    my $variable = $_[1];
    my $old      = $_[2];

 }

sub printNetwork {
    my $key;
    debug("printNetwork called");

    foreach $key ( getBlockKeys("/switch")) {
        printSwitch($key);
    }
}

sub assignHostsToSwitches {
#    print "assign Hosts called\n";
#    my %hosts = getHash("/host");
# print "getHash finished\n";
    my $host;
    my %switches = getHash("/switch");
    return unless keys( %switches );
    
    foreach $host (getHosts()){
#	print "checking $host\n";
	my $if;
	my %ifs = getHash("/host/$host/network");
	foreach $if (keys %ifs) { 
#		print "checking $host $if\n";
	    my $switch = getScalar("/host/$host/network/$if/switch");
		if ( $switch ) {
#		    print "switch $switch found\n";
		    setScalar("/switch/$switch/hosts/$host",$if);
		    if ( getScalar("/host/$host/xen")) {
			setScalar("/switch/$switch/xen",1);
		    }
		}
	}
    }
    

    my $switch;
    my $project = getScalar("/global/project");
    foreach $switch (keys %switches){
#	print "switch $switch\n";
	my $bridge = $switches{$switch}{'bridge'};
	$bridge = "$switch.$project" unless $bridge;
#	print "bridge name: $bridge " . length($bridge) ."\n";
	if ( length($bridge) > 16 and not $switches{$switch}{'bridge'} ){
	    my $rest = 15 - length($switch);
	    my $crop = $project;
	    $crop =~ s/^(.*)(\S{$rest})$/$2/;
	    $bridge = "$switch.$crop";
#	    print "new bridge name: $bridge\n";
	}
	if (getScalar("/switch/$switch/xen")){
	    setScalar("/switch/$switch/bridge",$bridge);
	}
    }
}

#########################
#
# This function builds a UMLs filesystem
#
########################

sub buildMLNHost {
    my $hostname = $_[0];
    $CURRENT_HOSTNAME = $hostname;
    out( "---> $hostname\n", "cyan" );

    # 1. Create the filesystem
    if ( not $RECONFIGURE or ( $RECONFIGURE and $RECONFIGURE_REBUILD )){
	if ( $RECONFIGURE_REBUILD ){
	    stopHost($hostname,$PROJECT,"",15);
	    if ( $RESTART_UPGRADED ){
		$RESTART_ME{$hostname} = 1;
	    }
	    
	    removeHost($hostname);
	}
	createMLNFilesystem($hostname);
    }
    
    # 2. Configure the filesystem

    configureMLNFilesystem($hostname);
    
    # 3. Run plugins
    
    my $each;
    foreach $each (keys %PLUGIN_LIST){ 
	my $call = $each . "_postBuild";
	if ( defined(&$call) ){
	    verbose("Calling plugin method $call\n");
	    &$call($hostname);
	}
    }    

    
    # 4. Create the start/stop-scripts (also runs plugins)
    
    
}



sub createMLNFilesystem {

    my $hostname = $_[0];
    
    # we try all plugins first, and check if there is exclusiveness
    
    my $each;
    foreach $each (keys %PLUGIN_LIST){ 
	my $call = $each . "_createFilesystem";
	if ( defined(&$call) ){
	    verbose("Calling plugin method $call\n");
	    my $return = &$call($hostname);
	    if ( $return ){
		verbose("$call did filesystem creation\n");
		return;
	    }
	}
    }    

    
    my $cow_filesystem = getScalar( "/host/$hostname/cow_filesystem");
    my $lvm            = getScalar("/host/$hostname/lvm");
    my $tem            = getScalar("/host/$hostname/template");
    my $filesystem     = getScalar("/host/$hostname/filesystem");
    my $swap           = getScalar("/host/$hostname/swap");
    my $size           = getScalar("/host/$hostname/size");
    my $free_space     = getScalar("/host/$hostname/free_space");
    my $group           = getScalar("/host/$hostname/group");
    my $owner           = getScalar("/host/$hostname/owner");
    my $sudo           = getScalar("/host/$hostname/sudo");
    my $filepath       = getScalar("/host/$hostname/filepath");
    my $swap_size;
    my $vg;
    my $cow_path;
    my $resize;
    if ( $UPGRADE ){
	$resize = getScalar("/host/$hostname/size",$DIFF);
	$resize = getScalar("/host/$hostname/free_space",$DIFF) if not $resize;
    }

    $size       = $DEFAULTS{FILESYSTEM_SIZE} unless $size;
    $tem        = $DEFAULTS{TEMPLATE}        unless $tem;
    
    if ( $lvm) {
	$vg = getScalar("/host/$hostname/lvm_vg");
	$vg = $DEFAULTS{'MLN_VG'} if not $vg;
    }
    
    if ( not $filesystem ) {
        $filesystem = "$IMAGEDIR_NAME/$hostname";
    }

    if ($cow_filesystem) {
        $cow_path = "$IMAGEDIR_NAME/$cow_filesystem";
    }

    my $template = getLatestTemplate($tem);    
    out("Template $template\n");
    my $multiplier  = 1;
    my %BLOCK_UNITS = (
	'b'  => 512,
	'kB' => 1000,
	'KB' => 1000,
	'K', => 1024,
	'MB' => 1000 * 1000,
	'M'  => 1024 * 1024,
	'GB' => 1000 * 1000 * 1000,
	'G'  => 1024 * 1024 * 1024,
    );

    if ($swap) {
	$swap =~ /^(\d+)([A-Za-z]*)/;
	$multiplier = $BLOCK_UNITS{$2} if $2;
	if ( not $multiplier ) {
	    out("ERROR: bad units or swap size: $swap");
	    return;
	}
	$swap_size = $1 * $multiplier;
    }

    my $t_size      = getTemplateSize($template);
    
    $size =~ /^(\d+)([A-Za-z]*)/;
    $multiplier = $BLOCK_UNITS{$2} if $2;
    if ( not $multiplier ) {
	out("ERROR: bad units or template size: $size");
	return;
    }
    my $temp_size = $1 * $multiplier;
    
    if ($free_space) {
	$free_space =~ /^(\d+)([A-Za-z]*)/;
	$multiplier = $BLOCK_UNITS{$2} if $2;
	$temp_size = int( ( $t_size + ( $1 * $multiplier ) ) );	
    }
    
    if ( $t_size > $temp_size ) {
	out("Template size:\t$t_size\nNew size:\t$temp_size\n");
	out(
	    "WARNING: Template is larger then new filesystem!\nAdjusting size to fit template.\n",
	    "red"
		);
	$temp_size = $t_size + 1024;
		
    }
	    

	    # this is for a system with a cow-file
    if ($cow_filesystem and not getScalar("/host/$hostname/xen")) {
	if ( stat("$IMAGEDIR/$cow_filesystem") ) {
	    
	    # it is already buildt, so there is no need to build it
	}
	else {
	    print "Building cow_filesystem base: $cow_filesystem\n";
	    buildFilesystem( $cow_filesystem, $template, $temp_size );
	}
    }
    else {
		
	if ($UPGRADE and getScalar("/host/$hostname/lvm",$DIFF)){
	    replaceFilesystem($hostname);
	}
	
		
	if ( ( $UPGRADE and ( $resize or getScalar("/host/$hostname/template",$DIFF) or not getScalar("/host/$hostname",$OLD_DATA_ROOT)) )
	    or not $UPGRADE )
	{
	    if ( not getScalar("/host/$hostname",$OLD_DATA_ROOT) ){
		# new host, we cannot grow
		buildFilesystem( $hostname, $template, $temp_size, "" );
	    } else {
		buildFilesystem( $hostname, $template, $temp_size, $resize );
	    }
	}
	
    }

    if ($swap) {
	makeSwap( $hostname, $swap_size );
    }
    
    # If this is run by root and we want a different owner:
    
    if (   ( $group and not( $owner or $sudo ) )
	or ( not $USER_MODE and $ENV{UID} == 0 and ( $owner or $sudo ) ) )
    {
	my $ch_user;
	if ($group) {
	    $group = ":" . $group;
	}
	if ( $sudo and $owner ) {
	    out(
		"WARNING: both owner AND sudo are defined. sudo takes precedence",
		"red"
	    );
	    $ch_user = $sudo;
	}
	elsif ($sudo) {
	    $ch_user = $sudo;
	}
	else {
	    $ch_user = $owner;
	}

	system("$shell{'CHOWN'} $ch_user$group $IMAGEDIR/$hostname");
	system("$shell{'CHOWN'} $ch_user$group $PIDDIR/$hostname ");
	
    }
    

}

sub configureMLNFilesystem {
    my $hostname = $_[0];
#    out("configureMLNFilesystem\n");
    $CURRENT_HOSTNAME = $hostname;
    
    
    my $each;
    foreach $each (keys %PLUGIN_LIST){ 
	my $call = $each . "_configureEntireFilesystem";
	if ( defined(&$call) ){
	    verbose("Calling plugin method $call\n");
	    return if &$call($hostname);
	}
    }    

    
    #########################################
    # This section will mount the filesystem for configuration either through a plugin, or manually
    
    verifyDirectories("$NO_UML_MOUNTDIR");
    $MOUNTDIR = $NO_UML_MOUNTDIR;

    
    
    # get the filesystem
    my $filesystem     = getScalar("/host/$hostname/filesystem");    
    my $lvm            = getScalar("/host/$hostname/lvm");
    my $hvm            = getScalar("/host/$hostname/hvm");
    my $filepath = getScalar("/host/$hostname/filepath");
    my $vg;
    
    my $filesystem_was_mounted;
    my $each;
    foreach $each (keys %PLUGIN_LIST){ 
	my $call = $each . "_mountFilesystem";
	if ( defined(&$call) and not $filesystem_was_mounted ){
	    verbose("Calling plugin method $call\n");
	    $filesystem_was_mounted = &$call($hostname);
	}
    }    

    
    if ( not $filesystem_was_mounted ) { 
	if ( $lvm) {
	    $vg = getScalar("/host/$hostname/lvm_vg");
	    $vg = $DEFAULTS{'MLN_VG'} if not $vg;
	}
	
	if ( not $filesystem ){
	    if ($lvm){
		$filesystem = "/dev/$vg/$hostname.$PROJECT";
	    } elsif ( $filepath ){
	    $filesystem = "$filepath/$hostname.$PROJECT";
	    } else {
		$filesystem = "$IMAGEDIR/$hostname";
	    }
	    
	}
	
	# lvm or no lvm
	my $options;
	if ($lvm ){
	
	} else {
	    $options = "-o loop";
	}
	verbose("$shell{'MOUNT'} $options $filesystem $MOUNTDIR 2>&1\n");
#	system("cat /proc/filesystems");
	my $return = `$shell{'MOUNT'} $options $filesystem $MOUNTDIR 2>&1`;
	
#	print "mount return: $return\n";
	if ( not $return ){
#	    out("Filesystem mounted successfully\n");
	} else {
	    out("Mounting HVM disk: ");
	    my $ret = system(
		"$shell{'MOUNT'} -o offset=32256  $filesystem  $MOUNTDIR"
	    );
	    if ( $ret == 0 ){
		out("success\n");
	    } else {
		out("FALIURE\n");
		
		out("Mounting HVM disk with NTFS-3g disc: ");
		my $ret = system(
		    "$shell{'MOUNT'} -o offset=32256 -t ntfs-3g  $filesystem  $MOUNTDIR"
		);
		if ( $ret == 0 ){
		    out("success\n");
		} else {
		    out("FALIURE\n");
		    out("Mounting HVM disk with NTFS-3g disc (win 2008 style): ");
		    my $ret = system(
			"$shell{'MOUNT'} -o offset=105906176 -t ntfs-3g  $filesystem  $MOUNTDIR"
		    );
		    if ( $ret == 0 ){
			out("success\n");
		    } else {
			out("FALIURE\n");
			out("Mounting HVM disk with Linux style disk: ");
			my $ret = system(
			    "$shell{'MOUNT'} -o offset=1048576 $filesystem  $MOUNTDIR"
			);
			if ( $ret == 0 ){
			    out("success\n");
			} else {
			    out("FALIURE\n");
			    out("Mounting RAW image with kpartx: ");
			    my $loopdev = `losetup -f`;
			    chomp $loopdev;
			    system("losetup $loopdev $filesystem");
	
			    # use kpartx something
			    system("kpartx -av $loopdev >/dev/null");	
			    
			    # mount the partition
			    my $loopnum = $loopdev;
			    $loopnum =~ s/^[^0-9]*(\d+)$/$1/;
			    my $partition = "p1";
			    my $command = "mount /dev/mapper/loop${loopnum}$partition $MOUNTDIR";
			    out("$command\n");
			    my $ret =  system("$command");
			    if ( $ret == 0 ){
				out("Success\n");
				system("df -h");
			    } else {
				out("Failure\n");
			    }
#	system("cat $MOUNTDIR/etc/fstab");
			    
			    
			   
			}
			
		    }
		    
		}
	    }
	}    
    }
    # From here on, the filesystem is mounted in $MOUNTDIR
    ######################################
    
    
    
    my $family = determineFamily($hostname);
    $family = $DEFAULTS{FAMILY} unless $family;

#        copyFiles( $hostname, \@files ) if (@files);

#    print "family = $family\n";
    if ( $family ne "windows"){
    setHostname($hostname);

    my @users = getArray("/host/$hostname/users");
    setUsers( $hostname, \@users ) if (@users);

    my %groups = getHash("/host/$hostname/groups");
    setGroups( $hostname, \%groups) if (%groups);

	my %network = getHash("/host/$hostname/network");
	if (%network) {
	    networkConfig( "$hostname", \%network );
	    setHostsFile($hostname);
	}
	
        my $format     = "ext2";
	
        if ( not $hvm and  detectExt3Journal("$filesystem") ) {
            verbose("Ext3 filesystem detected.");
            $format = "ext3";
        }

	my @mount = getArray("/host/$hostname/mount");
	setMount( $hostname, \@mount, $format );

	
	my $nameserver = getScalar("/host/$hostname/nameserver");
	verbose("checking for nameserver\n");
	setNameserver( $hostname, $nameserver ) if ($nameserver);

#	copyMLNmodules($hostname);
	copyFiles($hostname);
	
	my @modules = getArray("/host/$hostname/modules");
	verbose("preparing to copy modules");
	copyModuleList( $hostname, \@modules ) if (@modules);
	
	
	my @startup = getArray("/host/$hostname/startup");
	verbose("setting startup commands\n");
	setStartupCommands( $hostname, \@startup ) if (@startup);

	my @shutdown = getArray("/host/$hostname/shutdown");
	verbose("setting shutdown commands\n");
	setShutdownCommands( $hostname, \@shutdown ) if (@shutdown);

	my $root_password = getScalar("/host/$hostname/root_passwd");
	verbose("setting root password\n");
	setRootPassword( $hostname, $root_password ) if ($root_password);
	
#	my $hvm = getScalar("/host/$hostname/hvm");
	
	verbose("done with MLN-specific configurations\n");
    }

    # this is not a good way to do it. 
    # There should be something like a default VM technology 
    # question in the install and we should fallback to that.
    
    if (getScalar("/host/$hostname/xen")){
	configure_host_XEN($hostname);
    } elsif (not getScalar("/host/$hostname/vmware") ) {
	configure_host_UML($hostname);
    }

    
    
    # last, we run all the plugins:
    my $each;
    foreach $each (keys %PLUGIN_LIST){ 
	my $call = $each . "_configure";
	if ( defined(&$call) ){
	    verbose("Calling plugin method $call\n");
	    &$call($hostname);
	}
    }    

    my $filesystem_was_unmounted;
    my $each;
    foreach $each (keys %PLUGIN_LIST){ 
	my $call = $each . "_unmountFilesystem";
	if ( defined(&$call) and not $filesystem_was_unmounted ){
	    verbose("Calling plugin method $call\n");
	    $filesystem_was_unmounted = &$call($hostname);
	}
    }    
    if ( not $filesystem_was_unmounted ){
	system("$shell{'UMOUNT'} $MOUNTDIR");
    }
    my $each;
    foreach $each (keys %PLUGIN_LIST){ 
	my $call = $each . "_createStartStopScripts";
	if ( defined(&$call) ){
	    verbose("Calling plugin method $call\n");
	    &$call($hostname);
	}
    }
    
}

sub configure_host_UML {

    
    my $hostname = $_[0];
    
    umlifyInittab($hostname);

    my $term           = getScalar("/host/$hostname/term");
    
    my $color          = getScalar("/host/$hostname/color");
    my %network        = getHash("/host/$hostname/network");
   # printHash(\%network);
    my $filesystem     = getScalar("/host/$hostname/filesystem");
    my $size           = getScalar("/host/$hostname/size");

    my $free_space     = getScalar("/host/$hostname/free_space");
#    my $hvm            = getScalar("/host/$hostname/hvm");
    my $cow_filesystem = getScalar( "/host/$hostname/cow_filesystem");
#    print "cow_filesystem: $cow_filesystem\n";
    my $memory         = getScalar("/host/$hostname/memory");
    my $tem            = getScalar("/host/$hostname/template" );
    my $lvm            = getScalar("/host/$hostname/lvm");
    
    # INSERT: copy_modules

    my @files         = getArray("/host/$hostname/files");
    my $root_password = getScalar( "/host/$hostname/root_password");
    my $nameserver    = getScalar( "/host/$hostname/nameserver");
    my @startup = getArray("/host/$hostname/startup");
    my $boot_order = getScalar("/host/$hostname/boot_order" );
    my @modules = getArray("/host/$hostname/modules");
    my $copy_modules = 1 if  @modules; # getScalar("/hostname/$hostname/copy_modules" );
#    print "copy modules set to $copy_modules\n";
    my $pwd     = `pwd`;
    chomp $pwd;
    my $owner = getScalar("/host/$hostname/owner");
    my $group = getScalar("/host/$hostname/group");
    my $sudo  = getScalar("/host/$hostname/sudo");
    my $nice  = getScalar("/host/$hostname/nice");
    my $tun_owner      = $owner;
 #   my $temp_array = getVariable( $hostname, 'mount' );
    my @mount = getArray("/host/$hostname/mount");

    my $command;
#    my $dyndns = getScalar("/host/$hostname/dyndns");

#    $temp_array = getVariable( $hostname, 'users' );
    my @users = getArray("/host/$hostname/users");

    my %groups = getHash( "/host/$hostname/groups" );

#    $temp_array = getVariable( $hostname, 'vtun' );
    my @vtun = getArray("/host/$hostname/vtun");

#    my $family = getScalar("/host/$hostname/family");
    my $use_filesystem = getScalar("/host/$hostname/filesystem");

    my $kernel = getScalar("/host/$hostname/kernel" );
    $kernel = $DEFAULTS{KERNEL} unless ($kernel);

    my $cow_path;
    my $devfs = getScalar("/host/$hostname/devfs" );
    my $swap  = getScalar("/host/$hostname/swap");
    my $vg;
    if ( $lvm) {
		$vg = getScalar("/host/$hostname/lvm_vg");
		$vg = $DEFAULTS{'MLN_VG'} if not $vg;
    }
    
    if ( $devfs =~ /(yes|on|enable|mount)/i ) {
        $devfs = "devfs=mount";
    }
    else {
        $devfs = "";
    }

    # Checking for default values:
    #
    $size       = $DEFAULTS{FILESYSTEM_SIZE} unless $size;
    $tem        = $DEFAULTS{TEMPLATE}        unless $tem;
    $term       = $DEFAULTS{TERM}            unless $term;
    $memory     = $DEFAULTS{MEMORY}          unless $memory;
    $boot_order = 99                         unless $boot_order;
    my $swap_size;

    if ( not $filesystem ) {
        $filesystem = "$IMAGEDIR_NAME/$hostname";
    }

    if ($cow_filesystem) {
        $cow_path = "$IMAGEDIR_NAME/$cow_filesystem";
#	print "setting cow_path to: $cow_path\n";
        # if ( $resize or ( $task eq "rebuild" ) ) {
        #     print "Rebuild and resize not yet supported for this version\n";
        #     return;
        # }

    }
    
    if ($nice) {
	$command .= " nice -n $nice ";
    }
    
    if ($cow_filesystem) {
	$command .= " $kernel $devfs \\\n ubd0=$filesystem,$cow_path \\\n";
#	    print "setting command to $command\n";
	  }
    else {
	if ( $lvm ){
	    $command .= " $kernel $devfs  \\\n ubd0=/dev/$vg/$hostname.$PROJECT \\\n";
	} else {
	    $command .= " $kernel $devfs  \\\n ubd0=$filesystem \\\n";
	}
    }
    
    if ($swap) {
	$command .= "ubd1=$IMAGEDIR_NAME/${SWAP_PREFIX}$hostname \\\n";
    }
    
    #      print "buildHost: $#network devices present\n";
    my $net;
    foreach $net (keys %network ) {
#            print "adding command for $net\n";
	my $iface  = $net;
	my $switch = $network{$net}{"switch"};
	my $mac_address;
	
	if ( $network{$net}{"mac"} ) {
	    $mac_address = $network{$net}{"mac"};
	}
	else {
	    my $mac_suff =
	      sprintf( "%x", int( rand(256) ) ) . ":"
	      . sprintf( "%x", int( rand(256) ) );
	    verbose("Mac suffix: $mac_suff\n");
	    $mac_address = "$DEFAULTS{MAC_BASE}$mac_suff";
	}
	
	if ( $network{$net}{"tun_iface"} ) {
	    $command .=
	      " $iface=tuntap," . $network{$net}{"tun_iface"} . ",$mac_address \\\n";
	}
	elsif ( $switch =~ /^\// ) {
	    $command .= " $iface=daemon,$mac_address,unix,$switch \\\n";
	}
	elsif ( getScalar("/switch/$switch/socket")) {
	    $command .=
	      " $iface=daemon,$mac_address,unix,"
	      . getScalar("/switch/$switch/socket") . " \\\n";
	}
	elsif ( $network{$net}{"slirp"} ) {
	    $command .=
	      " $iface=slirp,$mac_address," . $network{$net}{"slirp"} . "  \\\n";
	}
	else {
	    $command .=
	      " $iface=daemon,$mac_address,unix,$NETDIR_NAME/$switch \\\n";
	}
    }
    
    my $disk;
    
    # we start all disks at 2, and reserve /dev/ubd/1 for swap.
    
    my $disk_counter = 2;
    foreach $disk (@mount) {
#	    print "adding $disk\n";
	# This check is removed, since people may have their own filetypes.
	#	      if ( $disk->type =~ /(ext2|ext3|reiserfs|none)/ ){
	my @line = split /\s+/,$disk;
	$command .= "ubd${disk_counter}=" . $line[0] . " \\\n";
#            $disk->device("$disk_counter");
	$disk_counter++;
	
	#	      }
	
    }
    
    $command .=
      "mem=$memory umid=$hostname uml_dir=$PIDDIR_NAME/$hostname ";
    
    # we add this variable in the hope that TLS will be disabled:
    
    $command .= " LD_ASSUME_KERNEL=2.4.1 ";
    
    $command .= " &";
    
    my $xterm_command  = "echo \"Starting $hostname in xterm\"\n";
    my $screen_command = "echo \"Starting $hostname.$PROJECT in screen\"\n";
    
    if ($sudo) {
	
	$xterm_command  .= "sudo -u $sudo ";
	$screen_command .= "sudo -u $sudo ";
    }
    
    if ($color) {
	$xterm_command .= $DEFAULTS{TERM_COMMAND} . " -fg $color \\\n";
    }
    else {
	$xterm_command .=
	  $DEFAULTS{TERM_COMMAND} . "-fg $DEFAULTS{COLOR} \\\n";
    }
    $xterm_command .= "-T $hostname.$PROJECT -e ";
    
    $screen_command .= "$DEFAULTS{SCREEN_COMMAND} $hostname.$PROJECT ";
    
    $screen_command .= $command;
    $xterm_command  .= $command;
    
    
    my $boot_order = getScalar("/host/$hostname/boot_order");
    $boot_order = 99 unless $boot_order;
    open( HOSTSTART,
        ">$PROJECT_PATH/$PROJECT/start_${boot_order}_$hostname.sh" )
      or die "failed to open start_$hostname\n";
    if ($term !~ m/(screen|xterm)/) {
	$term = "xterm"; # Make the default an xterm, per documentation
    }
    print HOSTSTART "#!/bin/sh\n";
    print HOSTSTART "type=\$1\n";
    print HOSTSTART
      "mco=\$(find $PIDDIR_NAME -type s | grep \"/$hostname/\" )\n";
    print HOSTSTART "if [ -n \"\$mco\" ]; then\n";
    print HOSTSTART "echo \"Host $hostname seems to be up already\"\n";
    print HOSTSTART "exit 1\n";
    print HOSTSTART "fi\n\n";
    
    
	    my %net = getHash("/host/$hostname/network");

	    my $each;
	    my $tun    = 0;
	    my $bridge = 0;
	    foreach $each ( keys %net ) {
		$tun = 1 if ( $net{$each}{"tun_iface"} );
	    }

	    if ($tun) {
		
		print HOSTSTART "if [ \$UID == 0 ]; then\n";
		
		foreach $each ( keys %net ) {
#	    print "checking $each\n";
		    if ( getScalar("/host/$hostname/network/$each/tun_iface") ) {
			print HOSTSTART "TUN_DEVICE=" . $net{$each}{"tun_iface"} . "\n";
			print HOSTSTART "TUN_ADDRESS=" . $net{$each}{"tun_address"} . "\n";
			print HOSTSTART "NETMASK=" . $net{$each}{"netmask"} . "\n";
			if ($tun_owner) {
			    print HOSTSTART "OWNER=$tun_owner\n";
			}
			print HOSTSTART
			  "if ! /sbin/ifconfig \$TUN_DEVICE &> /dev/null ; then\n";
			if ($tun_owner) {
			    print HOSTSTART "tunctl -t \$TUN_DEVICE -u \$OWNER\n";
			}
			else {
			    print HOSTSTART "tunctl -t \$TUN_DEVICE\n";
			}
                print HOSTSTART
			  "/sbin/ifconfig \$TUN_DEVICE \$TUN_ADDRESS netmask \$NETMASK up\n";
			print HOSTSTART "fi\n";
		    }
		}
		print HOSTSTART "fi\n";
	    }
    print HOSTSTART "default=$term\n";
    
    print HOSTSTART "if [ -z \$type ]; then\n";
    print HOSTSTART "type=\$default\n";
    print HOSTSTART "fi\n";
    
    print HOSTSTART "if [ \"\$type\" = \"screen\" ]; then\n";
    print HOSTSTART "$screen_command\n";
    print HOSTSTART "elif [ \"\$type\" = \"xterm\" ]; then\n";
    print HOSTSTART "$xterm_command\n";
    print HOSTSTART "fi\n";
	    
    close(HOSTSTART);
    open( STOP, ">$PROJECT_PATH/$PROJECT/stop_${boot_order}_$hostname.sh" )
      or die "Failed to open $STOP_SCRIPT\n";
    print STOP "#!/bin/sh\n";
    print STOP "STOP=cad\n";
    
    print STOP "if \[ \$1 \]; then\n";
    print STOP "STOP=halt\n";
    print STOP "echo \"Brute force on $hostname\"\n";
    print STOP "fi\n";
    
    print STOP "mco=\$(find $PIDDIR_NAME -type s | grep \"/$hostname/\" )\n";
    
    #
    print STOP "if \[ \$mco \]; then\n";
    print STOP "echo -n \"$hostname... \"\n";
    
    print STOP "$shell{'UML_MCONSOLE'} \$mco \$STOP 2>/dev/null\n";
    
    print STOP "else\n";
    print STOP "echo \" Console for $hostname not found. Alreaddy off?\"\n";
    print STOP "exit 1\n";
    print STOP "fi\n";
    
    if ($tun) {
	
        print STOP "if [ \$UID == 0 ]; then\n";
	
        foreach $each ( values %net ) {
            if ( $net{$each}{"tun_iface"} ) {
                print STOP
                  "echo \"I need to wait for $hostname to shutdown before "
                  . $net{$each}{"tun_iface"}
		. " can be removed\"\n";
            }
        }
        print STOP "while [ -w \$mco ]; do sleep 2 ; done\n";
	
        foreach $each ( values %net ) {
            if ( $net{$each}{"tun_iface"} ) {
                print STOP "echo \"removing " . $net{$each}{"tun_iface"} . "\"\n";
                print STOP "TUN_DEVICE=" . $net{$each}{"tun_iface"} . "\n";
                print STOP "/sbin/ifconfig \$TUN_DEVICE down\n";
                print STOP "tunctl -d \$TUN_DEVICE\n";
            }
        }
        print STOP "fi\n\n";
    }
    
    close(STOP);
    system(
	"$shell{'CHMOD'} +x $PROJECT_PATH/$PROJECT/stop_${boot_order}_$hostname.sh"
    );    
    system(
	"$shell{'CHMOD'} +x $PROJECT_PATH/$PROJECT/start_${boot_order}_$hostname.sh"
    );    
    
}


sub configure_host_XEN {
    my $hostname = $_[0];
    my $hvm = getScalar("/host/$hostname/hvm");
    out("Configure host Xen\n");
    # 1. copy the modules
    
    # 2. xenify inittab
    
    # 3. write xen startscript
    
    # 4. write xen config
    
    if( not $LIVE_LIST{$hostname} and not $hvm ){
    # 1.
	my $default_modules = $DEFAULTS{XEN_MODULES};
	$default_modules = "/lib/modules/" . assumeXenKernelVersion() unless $DEFAULTS{XEN_MODULES};
	
#    system("df -m $MOUNTDIR/lib/modules | tail -1");
	my $space = `df -m $MOUNTDIR/lib/modules | tail -1`;
	chomp $space;
#	print "space: '$space'\n";
	$space =~ s/^\S+\s+\d+\s+\d+\s+(\d+)\s+.*$/$1/g;
#	print "after: '$space'\n";
	my $size = `du -sm $default_modules`;
	$size =~ s/(\S+).*/$1/;
	out("Importing modules from: $default_modules\n"); # (${size}MB), free space: ${space}MB\n");
	if ( $size < $space){
	    system("$shell{'CP'} -r $default_modules $MOUNTDIR/lib/modules/");
	} else {
	    out("WARNING: There is not enough space on the VM to copy the modules.\nSpace on VM: ${space}MB, Size of modules: ${size}MB\n","red");
	}
	
	# 2.
	xenifyInittab($hostname);
    }
    # 3.
    
    my $boot_order = getScalar("/host/$hostname/boot_order");
    $boot_order = 99 unless $boot_order;
    
    # first: remove any old boot order script:
    my $old_order = getScalar( "/host/$hostname/boot_order",$OLD_DATA_ROOT );
    
    if ( $old_order and $old_order != $boot_order ) {
	
        verbose("Removing old start and stop script\n");
        system(
	    "$shell{'RM'} $PROJECT_PATH/$PROJECT/start_${old_order}_$hostname.sh"
        );
        system(
            "$shell{'RM'} $PROJECT_PATH/$PROJECT/stop_${old_order}_$hostname.sh"
        );
    }
    
    my $term = getScalar("/host/$hostname/term");
    $term = $DEFAULTS{TERM} unless $term;
    my $color = getScalar("/host/$hostname/color");
    
     my $noterm_command = "echo \"Starting $hostname in xm-managed mode\"\n";
    my $xterm_command  = "echo \"Starting $hostname in xterm\"\n";
    my $screen_command = "echo \"Starting $hostname.$PROJECT in screen\"\n";
    $screen_command .= "$DEFAULTS{SCREEN_COMMAND} $hostname.$PROJECT ";
    
    if ($color) {
	$xterm_command .= $DEFAULTS{TERM_COMMAND} . " -fg $color \\\n";
    }
    else {
	$xterm_command .=
	  $DEFAULTS{TERM_COMMAND} . "-fg $DEFAULTS{COLOR} \\\n";
    }
    
    $xterm_command .= "-T $hostname.$PROJECT -e ";
    
    my $command = "xm console $hostname.$PROJECT";
    $screen_command .= $command;
    $xterm_command .= "$command &";
    
    
    open( HOSTSTART,
        ">$PROJECT_PATH/$PROJECT/start_${boot_order}_$hostname.sh" )
      or die "failed to open start_$hostname\n";
    
    print HOSTSTART "#!/bin/sh\n";
    print HOSTSTART "type=\$1\n";

    print HOSTSTART "if /usr/sbin/xm list $hostname.$PROJECT 2>/dev/null 1>/dev/null ; then\n";
    print HOSTSTART "echo \"Host $hostname seems to be up already\"\n";
    print HOSTSTART "exit 1\n";
    print HOSTSTART "fi\n\n";
    print HOSTSTART "default=$term\n";
    
    print HOSTSTART "if [ -z \$type ]; then\n";
    print HOSTSTART "type=\$default\n";
    print HOSTSTART "fi\n";
    
    if ( getScalar("/host/$hostname/hvm") ){
	print HOSTSTART "command=\"create ${hostname}_xen.hvm\"\n";
	print HOSTSTART "echo Starting HVM ${hostname}\n";
	print HOSTSTART "/usr/sbin/xm \$command 1>/dev/null";
    } else {
	print HOSTSTART "command=\"create ${hostname}_xen.cfg\"\n";
	
	print HOSTSTART "if [ -f $hostname.ram ]; then\n";
	print HOSTSTART "command=\"restore $hostname.ram\"\n";
	print HOSTSTART "echo \"Restoring $hostname from $hostname.ram\"\n";
	print HOSTSTART "fi\n";
	
	print HOSTSTART "if [ \"\$type\" = \"screen\" ]; then\n";
	print HOSTSTART "if /usr/sbin/xm \$command 1>/dev/null; then \n";
	print HOSTSTART "sleep 1; $screen_command\n";
	print HOSTSTART "fi\n";
	
	print HOSTSTART "elif [ \"\$type\" = \"xterm\" ]; then\n";
	print HOSTSTART "if /usr/sbin/xm \$command 1>/dev/null; then \n";
	print HOSTSTART "sleep 1; $xterm_command\n";
	print HOSTSTART "fi\n";
	
	print HOSTSTART "elif [ \"\$type\" = \"none\" ]; then\n";
	print HOSTSTART "if /usr/sbin/xm \$command 1>/dev/null; then \n";
	print HOSTSTART "sleep 1; $noterm_command\n";
	print HOSTSTART "fi\n";
	print HOSTSTART "fi\n";
	print HOSTSTART "if [ -x $hostname.ram ]; then rm $hostname.ram; fi\n";	
    }
    close(HOSTSTART);
    system("chmod +x $PROJECT_PATH/$PROJECT/start_${boot_order}_$hostname.sh" );

    open( STOP, ">$PROJECT_PATH/$PROJECT/stop_${boot_order}_$hostname.sh" )
      or die "Failed to open $STOP_SCRIPT\n";
    print STOP "#!/bin/sh\n";
    
    
    print STOP "STOP=shutdown\n";
    
    print STOP "if \[ \$1 \]; then\n";
    print STOP "if \[ \$1 = \"save\" \]; then\n";
    print STOP "echo \"Saving $hostname in $PROJECT_PATH/$PROJECT/$hostname.ram\"\n";
    print STOP "xm save $hostname.$PROJECT $PROJECT_PATH/$PROJECT/$hostname.ram\n";
    print STOP "exit\n";
    print STOP "fi\n";
    print STOP "fi\n";
    
    print STOP "if \[ \$1 \]; then\n";
    print STOP "STOP=destroy\n";
    print STOP "echo \"Brute force on $hostname\"\n";
    print STOP "fi\n";

    print STOP "echo \"$hostname... OK\"\n";
    
    print STOP "xm \$STOP $hostname.$PROJECT 2>/dev/null\n";
    close(STOP);
    system("chmod +x $PROJECT_PATH/$PROJECT/stop_${boot_order}_$hostname.sh" );
    # 4.
    writeXenConfig($hostname);
}

#"; 

sub buildHostFilesystem {
    my $hostname = $_[0];
    # INSERT: type 

###
    # I'll return here, if this is a superclass:
    #
#    return if $type =~ /superclass/;

###
    # I'll return here, if I'm not supposed to build this host
    my $xen = getScalar("/host/$hostname/xen");
    my $service_host = getScalar("/host/$hostname/service_host") ;
    return if ( $service_host and $SERVICE_HOST and $service_host ne $SERVICE_HOST );

    return if ( $UPGRADE and not getScalar("/host/$hostname",$DIFF));
    
    my $tag = "UML host $hostname";
    $tag = "XEN host $hostname" if $xen;
    
    if ( $RECONFIGURE_REBUILD ){
        out( "---> Rebuilding $tag\n", "cyan" );
    }
    elsif ($CONFIGURE_HOSTS_ONLY  ) {
        out( "---> Configuring $tag\n", "cyan" );
    }
    else {
        out( "---> Building $tag\n", "cyan" );
    }

    $HOST_COUNTER++;

    my $resize;
    my $term           = getScalar("/host/$hostname/term");

    my $color          = getScalar("/host/$hostname/color");
    my %network        = getHash("/host/$hostname/network");
   # printHash(\%network);
    my $filesystem     = getScalar("/host/$hostname/filesystem");
    my $size           = getScalar("/host/$hostname/size");

    my $free_space     = getScalar("/host/$hostname/free_space");
    my $hvm            = getScalar("/host/$hostname/hvm");
    my $cow_filesystem = getScalar( "/host/$hostname/cow_filesystem");
#    print "cow_filesystem: $cow_filesystem\n";
    my $memory         = getScalar("/host/$hostname/memory");
    my $tem            = getScalar("/host/$hostname/template" );
    my $lvm            = getScalar("/host/$hostname/lvm");
    
    # INSERT: copy_modules

#    my @files         = getArray("/host/$hostname/files");
    my $root_password = getScalar( "/host/$hostname/root_password");
    my $nameserver    = getScalar( "/host/$hostname/nameserver");
    my @startup = getArray("/host/$hostname/startup");
    my @shutdown = getArray("/host/$hostname/shutdown");
    my $boot_order = getScalar("/host/$hostname/boot_order" );
    my @modules = getArray("/host/$hostname/modules");
    my $copy_modules = 1 if $xen or @modules; # getScalar("/hostname/$hostname/copy_modules" );
#    print "copy modules set to $copy_modules\n";
    my $pwd     = `pwd`;
    chomp $pwd;
    my $owner = getScalar("/host/$hostname/owner");
    my $group = getScalar("/host/$hostname/group");
    my $sudo  = getScalar("/host/$hostname/sudo");
    my $nice  = getScalar("/host/$hostname/nice");

 #   my $temp_array = getVariable( $hostname, 'mount' );
    my @mount = getArray("/host/$hostname/mount");

    my $command;
#    my $dyndns = getScalar("/host/$hostname/dyndns");

#    $temp_array = getVariable( $hostname, 'users' );
    my @users = getArray("/host/$hostname/users");

    my %groups = getHash( "/host/$hostname/groups" );

#    $temp_array = getVariable( $hostname, 'vtun' );
    my @vtun = getArray("/host/$hostname/vtun");

#    my $family = getScalar("/host/$hostname/family");
    my $use_filesystem = getScalar("/host/$hostname/filesystem");

    my $kernel = getScalar("/host/$hostname/kernel" );
    $kernel = $DEFAULTS{KERNEL} unless ($kernel);

    my $cow_path;
    my $devfs = getScalar("/host/$hostname/devfs" );
    my $swap  = getScalar("/host/$hostname/swap");
    my $vg;
    if ( $lvm) {
		$vg = getScalar("/host/$hostname/lvm_vg");
		$vg = $DEFAULTS{'MLN_VG'} if not $vg;
    }
    
    if ( $devfs =~ /(yes|on|enable|mount)/i ) {
        $devfs = "devfs=mount";
    }
    else {
        $devfs = "";
    }

    ##
    # We turn devfs off by default from 0.73
    ##

#    my $task   = $HOSTS{$hostname}{'task'};
    if ( $UPGRADE ){
		$resize = getScalar("/host/$hostname/size",$DIFF);
		$resize = getScalar("/host/$hostname/free_space",$DIFF) if not $resize;
    }
    # print "Resize is $resize\n";
    # print "Old root:\n";
    # printBlock($OLD_DATA_ROOT);
    # print "new root:\n";
    # printBlock($DATA_ROOT);
    # print "DIFF:\n";
    # printBlock($DIFF);
###
    # Checking for default values:
    #
    $size       = $DEFAULTS{FILESYSTEM_SIZE} unless $size;
    $tem        = $DEFAULTS{TEMPLATE}        unless $tem;
    $term       = $DEFAULTS{TERM}            unless $term;
    $memory     = $DEFAULTS{MEMORY}          unless $memory;
    $boot_order = 99                         unless $boot_order;
    my $swap_size;

    if ( not $filesystem ) {
        $filesystem = "$IMAGEDIR_NAME/$hostname";
    }

    if ($cow_filesystem) {
        $cow_path = "$IMAGEDIR_NAME/$cow_filesystem";
#	print "setting cow_path to: $cow_path\n";
        # if ( $resize or ( $task eq "rebuild" ) ) {
        #     print "Rebuild and resize not yet supported for this version\n";
        #     return;
        # }

    }

############ This part builds the command line for the host

    # If this mln runs inside a virtual machine, then we'll skip all this
    # and go directly to configuring the filesystem.

	if ( not $CONFIGURE_HOSTS_ONLY ) {
        my $template = getLatestTemplate($tem);

      if ( not $xen ) {
	  if ($nice) {
	      $command .= " nice -n $nice ";
	  }
	  
	  if ($cow_filesystem) {
	      $command .= " $kernel $devfs \\\n ubd0=$filesystem,$cow_path \\\n";
#	    print "setting command to $command\n";
	  }
	  else {
	      if ( $lvm ){
		  $command .= " $kernel $devfs  \\\n ubd0=/dev/$vg/$hostname.$PROJECT \\\n";
	      } else {
		  $command .= " $kernel $devfs  \\\n ubd0=$filesystem \\\n";
	      }
	  }
	  
	  if ($swap) {
	      $command .= "ubd1=$IMAGEDIR_NAME/${SWAP_PREFIX}$hostname \\\n";
	  }
	  
	  #      print "buildHost: $#network devices present\n";
	  my $net;
	  foreach $net (keys %network ) {
#            print "adding command for $net\n";
	      my $iface  = $net;
	      my $switch = $network{$net}{"switch"};
	      my $mac_address;
	      
	      if ( $network{$net}{"mac"} ) {
		  $mac_address = $network{$net}{"mac"};
	      }
	      else {
		  my $mac_suff =
                    sprintf( "%x", int( rand(256) ) ) . ":"
		    . sprintf( "%x", int( rand(256) ) );
		  verbose("Mac suffix: $mac_suff\n");
		  $mac_address = "$DEFAULTS{MAC_BASE}$mac_suff";
	      }
	      
	      if ( $network{$net}{"tun_iface"} ) {
		  $command .=
		    " $iface=tuntap," . $network{$net}{"tun_iface"} . ",$mac_address \\\n";
	      }
	      elsif ( $switch =~ /^\// ) {
		  $command .= " $iface=daemon,$mac_address,unix,$switch \\\n";
	      }
	      elsif ( getScalar("/switch/$switch/socket")) {
		  $command .=
		    " $iface=daemon,$mac_address,unix,"
		    . getScalar("/switch/$switch/socket") . " \\\n";
	      }
	      elsif ( $network{$net}{"slirp"} ) {
		  $command .=
		    " $iface=slirp,$mac_address," . $network{$net}{"slirp"} . "  \\\n";
	      }
	      else {
		  $command .=
		    " $iface=daemon,$mac_address,unix,$NETDIR_NAME/$switch \\\n";
	      }
	  }
	  
	  my $disk;
	  
	  # we start all disks at 2, and reserve /dev/ubd/1 for swap.
	  
	  my $disk_counter = 2;
	  foreach $disk (@mount) {
#	    print "adding $disk\n";
	      # This check is removed, since people may have their own filetypes.
	      #	      if ( $disk->type =~ /(ext2|ext3|reiserfs|none)/ ){
	      my @line = split /\s+/,$disk;
	      $command .= "ubd${disk_counter}=" . $line[0] . " \\\n";
#            $disk->device("$disk_counter");
	      $disk_counter++;
	      
	      #	      }
	      
	  }
	  
	  $command .=
	    "mem=$memory umid=$hostname uml_dir=$PIDDIR_NAME/$hostname ";
	  
	  # we add this variable in the hope that TLS will be disabled:
	  
	  $command .= " LD_ASSUME_KERNEL=2.4.1 ";
	  
	  $command .= " &";
	  
	  my $xterm_command  = "echo \"Starting $hostname in xterm\"\n";
	  my $screen_command = "echo \"Starting $hostname.$PROJECT in screen\"\n";
	  
	  if ($sudo) {
	      
	      $xterm_command  .= "sudo -u $sudo ";
	      $screen_command .= "sudo -u $sudo ";
	  }
	  
	  if ($color) {
	      $xterm_command .= $DEFAULTS{TERM_COMMAND} . " -fg $color \\\n";
	  }
	  else {
	      $xterm_command .=
		$DEFAULTS{TERM_COMMAND} . "-fg $DEFAULTS{COLOR} \\\n";
	  }
	  $xterm_command .= "-T $hostname.$PROJECT -e ";
	  
	  $screen_command .= "$DEFAULTS{SCREEN_COMMAND} $hostname.$PROJECT ";
	  
	  $screen_command .= $command;
	  $xterm_command  .= $command;
	  
	  createHostStartScript( $hostname, $term, $boot_order,
	      $screen_command, $xterm_command );
	  createHostStopScript( $hostname, $boot_order );
	  
      }
	    elsif ( $xen ) {
   	my $noterm_command = "echo \"Starting $hostname in xm-managed mode\"\n";
	   my $xterm_command  = "echo \"Starting $hostname in xterm\"\n";
	   my $screen_command = "echo \"Starting $hostname.$PROJECT in screen\"\n";
	   $screen_command .= "$DEFAULTS{SCREEN_COMMAND} $hostname.$PROJECT ";
	   
	   if ($color) {
	       $xterm_command .= $DEFAULTS{TERM_COMMAND} . " -fg $color \\\n";
	   }
	   else {
	       $xterm_command .=
		 $DEFAULTS{TERM_COMMAND} . "-fg $DEFAULTS{COLOR} \\\n";
	   }
	   
	   $xterm_command .= "-T $hostname.$PROJECT -e ";
	   
	   my $command = "xm console $hostname.$PROJECT";
	   $screen_command .= $command;
	   $xterm_command .= "$command &";
	   
	   createHostStartScript( $hostname, $term, $boot_order,
	       $screen_command, $xterm_command, $noterm_command );

	   createHostStopScript( $hostname, $boot_order );
	   
	   writeXenConfig($hostname);
	   
	}
############# Here we build and modify the filesystem: 

	
   # template size
   my $multiplier  = 1;
	my %BLOCK_UNITS = (
            'b'  => 512,
            'kB' => 1000,
            'KB' => 1000,
            'K', => 1024,
            'MB' => 1000 * 1000,
            'M'  => 1024 * 1024,
            'GB' => 1000 * 1000 * 1000,
            'G'  => 1024 * 1024 * 1024,
        );

        
	if ($swap) {
            $swap =~ /^(\d+)([A-Za-z]*)/;
            $multiplier = $BLOCK_UNITS{$2} if $2;
            if ( not $multiplier ) {
                out("ERROR: bad units or swap size: $swap");
                return;
            }
            $swap_size = $1 * $multiplier;
	    
            #	      print "Swap size: $swap_size\n";
   }

	
	# we only create a new filesystem if we are building, not when reconfiguring
	if ( not $RECONFIGURE or ( $RECONFIGURE and $RECONFIGURE_REBUILD ) ){
	    if ( $RECONFIGURE_REBUILD ){
#		stopHost(
		
		removeHost($hostname);
	    }
	    
	    my $t_size      = getTemplateSize($template);
	    
	    $size =~ /^(\d+)([A-Za-z]*)/;
	    $multiplier = $BLOCK_UNITS{$2} if $2;
	    if ( not $multiplier ) {
		 	out("ERROR: bad units or template size: $size");
			return;
	    }
	    my $temp_size = $1 * $multiplier;


	   if ($free_space) {
			$free_space =~ /^(\d+)([A-Za-z]*)/;
			$multiplier = $BLOCK_UNITS{$2} if $2;
			$temp_size = int( ( $t_size + ( $1 * $multiplier ) ) );

	   }

	   if ( $t_size > $temp_size ) {
			out("Template size:\t$t_size\nNew size:\t$temp_size\n");
			out(
		    "WARNING: Template is larger then new filesystem!\nAdjusting size to fit template.\n",
		    "red"
			);
			$temp_size = $t_size + 1024;
		
	   }
	    
	    
	   # this is for a system with a cow-file
	   if ($cow_filesystem and not getScalar("/host/$hostname/xen")) {
			if ( stat("$IMAGEDIR/$cow_filesystem") ) {
		   	# it is already buildt, so there is no need to build it
		   }
			else {
		   	print "Building cow_filesystem base: $cow_filesystem\n";
		   	buildFilesystem( $cow_filesystem, $template, $temp_size );
			}
		}
	   else {
		
			# This is for a regular system:
#	   	print "resize is set to: $resize\n";
			if ($UPGRADE and getScalar("/host/$hostname/lvm",$DIFF)){
		   	replaceFilesystem($hostname);
			}
		
		
			if ( ( $UPGRADE and ( $resize or getScalar("/host/$hostname/template",$DIFF) or not getScalar("/host/$hostname",$OLD_DATA_ROOT)) )
		    or not $UPGRADE )
			{
		   	 buildFilesystem( $hostname, $template, $temp_size, $resize );
			}
		
		}
	}
   if ($swap) {
   	makeSwap( $hostname, $swap_size );
   }
	
   # We need a directory to store the uml_mconsole socket
	
   mkdir("$PIDDIR/$hostname");
	
   # If this is run by root and we want a different owner:

   if (   ( $group and not( $owner or $sudo ) ) or ( not $USER_MODE and $ENV{UID} == 0 and ( $owner or $sudo ) ) )
   {
   	my $ch_user;
      if ($group) {
      	$group = ":" . $group;
      }
      if ( $sudo and $owner ) {
      	out("WARNING: both owner AND sudo are defined. sudo takes precedence","red");
         $ch_user = $sudo;
      }
      elsif ($sudo) {
      	$ch_user = $sudo;
      }
      else {
      	$ch_user = $owner;
      }

      system("$shell{'CHOWN'} $ch_user$group $IMAGEDIR/$hostname");
      system("$shell{'CHOWN'} $ch_user$group $PIDDIR/$hostname ");

	}
   }

##############################################
    # This is the split-point between USER_MODE_REC, and CONFIGURE_HOSTS_ONLY
    # If this is a USER_MODE build, then we drom everything that has to do
    # with the configurations of the filesystems

    if ( not $USER_MODE_REC ) {


	
        # we break early if we want to avoid a rebuild of the entire system


 # From version 0.73, we'll mount the filesystem once and unmount it in the end.

        #	  if ( $cow_filesystem ) {
        my $ubd        = getUbdDevice( $BATCH_NUMBER, $hostname );
        my $device_num = $MOUNT_OFFSET * $ubd;
        my $format     = "ext2";
        if ( detectExt3Journal("/dev/ubd$device_num") ) {
            verbose("Ext3 filesystem detected.");
            $format = "ext3";
        }

        #	      print "MOUNT($BATCH_NUMBER): /dev/ubd/$ubd $MOUNTDIR\n";
        verbose("$shell{'MOUNT'} -t $format /dev/ubd$device_num $MOUNTDIR\n");
#	system("cat /proc/filesystems");
	my $return = `$shell{'MOUNT'} -t $format -o defaults /dev/ubd$device_num $MOUNTDIR`;

#	print "mount return: $return\n";
        if ( $return eq "" ){
	    out("Filesystem mounted successfully\n");
	} else {
	    out("Mounting HVM disc: '$return'");
	    system("df -h");
	    my $ret = system(
		"$shell{'MOUNT'} -o offset=32256 /dev/ubd$device_num $MOUNTDIR"
	    );
	    if ( $ret == 0 ){
		out("success\n");
	    } else {
		out("FALIURE\n");
	    }
	    out("Mounting HVM disk with NTFS-3g disc (win 2008 style): ");
	    my $ret = system(
		"$shell{'MOUNT'} -o offset=1048576 -t ntfs-3g  $filesystem  $MOUNTDIR"
	    );
	    if ( $ret == 0 ){
		out("success\n");
	    } else {
		out("FALIURE\n");
	    }

	}
#	system("df -h");

	my $family = determineFamily($hostname);
	$family = $DEFAULTS{FAMILY} unless $family;
#	setScalar("/host/$hostname/family",$family);
	#	  } else {
       #	      system ("$shell{'MOUNT'} -o loop $IMAGEDIR/$hostname $MOUNTDIR");
       #	  }

        # determining the hosts family
#        $HOSTS{$hostname}{"family"} = determineFamily($hostname);
	
	print "\nCOPYFILES!\n\n";
        copyFiles( $hostname );

#        saveConfigFile( $hostname, $CONFIGFILE );

        setHostname($hostname);

        setUsers( $hostname, \@users ) if (@users);

	setGroups( $hostname, \%groups) if (%groups);
#	print "family is $family\n";
	if ( $family ne "windows" ){
#	    print "Family is not windows\n";
	    if (%network) {
		networkConfig( "$hostname", \%network );
		setHostsFile($hostname);
	    }
	    setMount( $hostname, \@mount, $format );
	    setNameserver( $hostname, $nameserver ) if ($nameserver);
	    copyModules($hostname) if ($copy_modules);
	    copyModuleList( $hostname, \@modules ) if (@modules);
	    setStartupCommands( $hostname, \@startup ) if (@startup);
	    setShutdownCommands( $hostname, \@shutdown ) if (@shutdown);
	    setRootPassword( $hostname, $root_password ) if ($root_password);
	    if ( not $hvm ){
		if ($xen){
		    xenifyInittab($hostname);
		} else {
		    umlifyInittab($hostname);
		}
	    }
	}
	# last, we run all the plugins:
	my $each;
	foreach $each (keys %PLUGIN_LIST){ 
	    my $call = $each . "_configure";
#	    print "checking if $call is defined\n";
	    if ( defined(&$call) ){
		debug("Calling plugin method $call\n");
		&$call($hostname);
	    }
	}
        system("$shell{'UMOUNT'} $MOUNTDIR");

    }
}

sub getXenVersion {
    
    open(XENINFO,"xm info |");
    my $xen_major;
    my $xen_minor;
    while ( my $line = <XENINFO> ){
	if ( $line =~ /xen_minor\s*: (\d+)/ ){
	    $xen_minor = $1;
	    next;
	} 
	if ( $line =~ /xen_major\s*: (\d+)/ ){
	    $xen_major = $1;
	    next;
	} 	
    }
    verbose("Xen version is $xen_major,$xen_minor\n");
    return $xen_major,$xen_minor;
}

sub writeXenConfig {
    my $host = $_[0];
    
    my %network = getHash("/host/$host/network");
    my $memory = getScalar("/host/$host/memory");
    my $hvm = getScalar("/host/$host/hvm");
#    my $family = determineFamily($host);
    my $filepath = getScalar( "/host/$host/filepath" );
    if (not $memory) {
	$memory = $DEFAULTS{MEMORY};	
    }
    $memory =~ s/M//g;
    my $cpus = getScalar("/host/$host/cpus");
    my $vcpus = getScalar("/host/$host/vcpus");
    my $ramdisk = getScalar("/host/$host/ramdisk");
    my @mounts = getArray("/host/$host/mount");
    my $swap = getScalar("/host/$host/swap");
    my $lvm = getScalar("/host/$host/lvm");
    my $kernel = getScalar("/host/$host/kernel");
    my $vncdisplay = getScalar("/host/$host/vncdisplay");
    my $vncpasswd = getScalar("/host/$host/vncpasswd");
    my $vnckeymap = getScalar("/host/$host/vnckeymap");
    my @xen_extra = getArray("/host/$host/xen_extra");
    my $version;
#    print "Default: $DEFAULTS{XEN_KERNEL}, " . assumeXenKernelVersion() . "\n";
    my $initrd;
    $kernel = $DEFAULTS{XEN_KERNEL} unless $kernel;
    
    if (not $kernel ){
	$version = assumeXenKernelVersion();
	$kernel = "/boot/vmlinuz-" . $version;
    }
    
    my $xen_version;
    my ( $xen_major,$xen_minor ) = getXenVersion();
    
    $ramdisk = $DEFAULTS{XEN_RAMDISK} unless $ramdisk;
    my $vg;
    if ( $lvm ){
	$vg = getScalar("/host/$host/lvm_vg");
	$vg = $DEFAULTS{'MLN_VG'} if not $vg;
    }

    if ( $hvm ){
	# we will add HVM specific lines to the config
	out("Writing XEN/HVM configuration file for $host, ");
	open (XEN_CONF,">$PROJECT_PATH/$PROJECT/${host}_xen.hvm") or die "Sorry, i could not open $PROJECT_PATH/$PROJECT/${host}_xen.hvm\n";    
	print XEN_CONF '#  -*- mode: python; -*-' . "\n";
	if ( $xen_major eq 4 ){
	    print XEN_CONF 'import os, re' . "\n";
	    print XEN_CONF  "arch = os.uname()[4]\n";
	    print XEN_CONF "if re.search('64', arch):\n";
	    print XEN_CONF  "\tarch_libdir = 'lib64'\n";
	    print XEN_CONF  "else:\n";
	    print XEN_CONF "\tarch_libdir = 'lib'\n";
	    print XEN_CONF "acpi=1\n";
	    print XEN_CONF "apic=1\n";
 	}
	print XEN_CONF 'kernel = "/usr/lib/xen/boot/hvmloader"' . "\n";

# The domain build function. HVM domain uses 'hvm'.
	print XEN_CONF "builder='hvm'" . "\n";
	print XEN_CONF "usb=1" . "\n";
	print XEN_CONF "usbdevice='tablet'" . "\n";
	print XEN_CONF "boot = 'c'" . "\n";
	if ( $xen_major eq 4 ){
	    
	    print XEN_CONF "vfb = [ 'type=vnc' ]\n";
	    
	} 
	    
	print XEN_CONF "vnc=1" . "\n";
	print XEN_CONF "vncviewer=0" . "\n";	
	print XEN_CONF "vncunused=0" . "\n";
	print XEN_CONF "device_model = '/usr/lib/xen/bin/qemu-dm'" . "\n";	    	    	
	
    } else {
	out("Writing XEN configuration file for $host, ");
	open (XEN_CONF,">$PROJECT_PATH/$PROJECT/${host}_xen.cfg") or die "Sorry, i could not open $PROJECT_PATH/$PROJECT/${host}_xen.cfg\n";    
	print XEN_CONF '#  -*- mode: python; -*-' . "\n";
	print XEN_CONF "kernel = \"$kernel\"\n";
	if ( $ramdisk ){
	    print XEN_CONF "ramdisk = \"$ramdisk\"\n";
	} 
    }
    if ( $vncdisplay or $vncpasswd or vnckeymap ){ 
	print XEN_CONF "vnc=1" . "\n";
	print XEN_CONF "vncviewer=0" . "\n";	
	print XEN_CONF "vncunused=0" . "\n";
	
	if ( $vncdisplay ){
	    print XEN_CONF "vncdisplay=$vncdisplay\n";
	}
	if ( $vncpasswd ){
	    print XEN_CONF "vncpasswd='$vncpasswd'\n";
	}
	if ( $vnckeymap ){
	    print XEN_CONF "keymap='$vnckeymap'\n";   
	}		
    }
    foreach ( @xen_extra ){
	print XEN_CONF "$_\n";
    }
    
    print XEN_CONF "memory = $memory\n";
    my $hda;
    if ( $hvm and $xen_major ne 4 ) {
	$hda = "ioemu:hda"; 
    } elsif ( $hvm and $xen_major eq 4 ) {
	$hda = "hda"; 	
    } elsif( $xen_major eq 4 ){
	$hda = "xvda1"
    } else {
	$hda = "hda1";
    }
    
    my $other_location;
    if ( %PLUGIN_LIST ){
	
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    
	    my $subcall = $plugin . "_getFilesystemPath"; 
	    verbose("calling $subcall\n");
	    if ( defined(&$subcall) and not $other_location ){
		$other_location = &$subcall($host);
	    }
	    
	}
    }    

    
    my $file = "file:";
    # my $xen_minor = `xm info | grep xen_minor 2>/dev/null`;
    # if ( $xen_minor =~ /: 2/ ){
    # 	# this is aparently not used everywhere....
    # 	# $file = "tap:aio:";
    # }
    
    if ( $lvm ){
	if ( $xen_major eq 4 and $hvm ){
	    print XEN_CONF "disk = [ 'tap:aio:/dev/$vg/$host.$PROJECT,$hda,w'";
	} else {
	    print XEN_CONF "disk = [ 'phy:/dev/$vg/$host.$PROJECT,$hda,w'";
	}
    } elsif ( $filepath ) {
	print XEN_CONF "disk = [ '${file}/$filepath/$host.$PROJECT,$hda,w'";    
    } elsif ( $other_location ){
	my $prefix = $file;
	if ( $other_location =~ /^\/dev\// ){
	    $prefix = "phy:";
	    if ( $xen_major eq 4 ){
		$prefix = "tap:aio:";
	    }
	}
	print XEN_CONF "disk = [ '${prefix}$other_location,$hda,w'";
    } else {
	print XEN_CONF "disk = [ '${file}/$PROJECT_PATH/$PROJECT/images/$host,$hda,w'";
    }
    if ( $swap and not $hvm ) {
	print XEN_CONF ",'${file}/$PROJECT_PATH/$PROJECT/images/swap_${host},hda2,w'";
    }
    
    if ( @mounts ) {
	my $hd_counter = 3;
	my $each;
	foreach $each ( @mounts ){
	    my @line = split /\s+/, $each;
	    if ( $line[0] =~ /^\/dev\// ){
		verbose("Assuming a device to be mounted, using 'phy:$line[0]'\n");
		print XEN_CONF ",'phy:$line[0],hda$hd_counter,w'";
	    } else {
		print XEN_CONF ",'file:$line[0],hda$hd_counter,w'";
	    }
	    $hd_counter++;
	}
    }
    
    print XEN_CONF " ]\n";
    if ( not $hvm ){
	print XEN_CONF "root = '/dev/$hda'\n";
	if ( $xen_major == 3 and $xen_minor == 2 ){
	    print XEN_CONF "extra = '2 xencons=tty'\n";
	} else {
	    print XEN_CONF "extra = '2'\n";
	}
    }
    print XEN_CONF "name = '$host.$PROJECT'\n";
    print XEN_CONF "cpus = $cpus\n" if $cpus;
    print XEN_CONF "vcpus = $vcpus\n" if $vcpus;
    
    my $if;
    
    if ( %network) {
	my $type = "type=ioemu," if $hvm and $xen_major ne 4;
	print XEN_CONF "vif = [ ";
	# this is stupid, but i need to get the order right or else.
	# i should probarbly sort instead
	my @interfaces = keys %network;
	my $i;
	for ($i = 0; $i <= $#interfaces; $i++ ) {
	    $if = "eth" .$i;
	    if ( $network{$if} ){
		if ( $i > 0 ){
		    print XEN_CONF ",";
		}
		print XEN_CONF "'";
		if ( $network{$if}{"bridge"} ) {
		    print XEN_CONF "${type}bridge=$network{$if}{'bridge'}";
		    if ( $network{$if}{"mac"}) {
			print XEN_CONF ",mac=$network{$if}{'mac'}";
		    } else {
			# i need to generate a MAC address.
			
		    }
		} elsif ($network{$if}{"switch"}) {
		    print XEN_CONF "${type}bridge=". getScalar("/switch/$network{$if}{'switch'}/bridge");
		    if ( $network{$if}{"mac"}) {
			print XEN_CONF ",mac=$network{$if}{'mac'}";
		    }
		} else {
		    # We will attempt to detect the default bridge
		    my $bridge = detectXenBridge();
		    $bridge = $DEFAULTS{XEN_BRIDGE} unless $bridge;
		    print XEN_CONF "${type}bridge=$bridge";
		    if ( $network{$if}{"mac"}) {
		    print XEN_CONF ",mac=$network{$if}{'mac'}";
		    }
		}
		print XEN_CONF "'";
	    }
	}
	print XEN_CONF "]\n";
    }
    close(XEN_CONF);
    system("cat $PROJECT_PATH/$PROJECT/${host}_xen.cfg") if $VERBOSE;
    out("done\n");
}

sub detectXenBridge {
    # detection through brctl
    open(BRCTL,"brctl show |");
    while( my $line = <BRCTL> ){
	if ( $line =~ /^(\S+).*peth\d/ ){
	    my $br = $1;
	    chomp $br;
	    close(BRCTL);
	    return $br;
	    
	}
    }
    close(BRCTL);

}

sub xenifyInittab {
#    out("attempting xenification\n");
    my $hostname = $_[0];
    
    open(INITTAB,"$MOUNTDIR/etc/inittab");
    my @inittab = <INITTAB>;
    close(INITTAB);
    my $changed;
    my $i; 
    for ( $i = 0; $i <= $#inittab ; $i++ ) {
	if ( $inittab[$i] =~ /^0:2345:.* tty0/ ){ 
	    $changed = 1;
	    $inittab[$i] = "1:2345:respawn:/sbin/getty 38400 tty1";
	}
    }
    out("Adjusting /etc/inittab for XEN\n") if $changed;
    writeToFile( $hostname, "/etc/inittab", \@inittab );
}

sub umlifyInittab {
#    out("attempting xenification\n");
    
    my $hostname = $_[0];
    return if getScalar("/host/$hostname/hvm");
    open(INITTAB,"$MOUNTDIR/etc/inittab");
    my @inittab = <INITTAB>;
    close(INITTAB);
    my $changed;
    my $i; 
    for ( $i = 0; $i <= $#inittab ; $i++ ) {
	if ( $inittab[$i] =~ /^1:2345:.* tty1/ ){ 
	    $changed = 1;
	    $inittab[$i] = "0:2345:respawn:/sbin/getty 38400 tty0";
	}
    }
    out("Adjusting /etc/inittab for UML\n") if $changed;
    writeToFile( $hostname, "/etc/inittab", \@inittab );
}

sub buildSwitch {
    my $name = $_[0];
    my $tap;
    my $place;

    if ( %PLUGIN_LIST ){
	
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    
	    my $subcall = $plugin . "_buildSwitch"; 
#	    print "calling $subcall\n";
	    verbose("calling $subcall\n");
	    if ( defined(&$subcall) ){
		return if &$subcall($name);
	    }
	    
	}
    }    
    
    my %switch = getHash("/switch/$name");
    
    my $hub = getScalar("/switch/$name/hub");
    my $type_hub = getScalar("/switch/$name/type");
    
    return if ( $switch{"socket"} =~ /external/ );
    
    
    open( START, ">$PROJECT_PATH/$PROJECT/start_$name.sh" )
      or die "Failed to open $PROJECT_PATH/$PROJECT/start_$name.sh\n";
    print START "#!/bin/sh \n";
    print START "\necho \"Setting up ", $name, "\"\n";

    if ( $switch{'xen'} ) {
	print START "brctl addbr $switch{'bridge'}\n";
	print START "ifconfig $switch{'bridge'} up\n";
    } else {
	my $be_a_hub = "-hub" if ( $hub or $type_hub eq "hub" );
	
	$place = "../$PROJECT/$NETDIR_NAME/$name";
	
	$place = $switch{"sock"} if $switch{"sock"};
	
	$tap = "-tap " . $switch{"tap"} if $switch{"tap"};
	
	print START "if [ -s $place ]; then\n";
	print START "echo \"Socket is occupied. Switch running already?\"\n";
	print START "exit 1\n";
	print START "fi\n\n";
	my $sudo;
	if ( $switch{"sudo"} ) {
	    $sudo = "sudo -u " . $switch{"sudo"} . " ";
	}
	print START
	  "$sudo$shell{'UML_SWITCH'} $be_a_hub -unix $place -daemon $tap < /dev/null > /dev/null &\n";
	
	if (   $switch{"owner"}
        or $switch{"group"}
	    or $switch{"sudo"} )
	{
	    my $ch_group;
	    my $ch_user = $switch{"owner"};
	    $ch_user = $switch{"sudo"} if ( $switch{"sudo"} );
	    
	    if ( $switch{"group"} ) {
		$ch_group = ":" . $switch{"group"};
	    }
	    
	    # I add one second of sleep, because the socket might not be there yet.
	    print START "sleep 1 ; chown $ch_user$ch_group $place\n";
	    print START "chmod 664 $place\n";
	}
    }
    close(START);
    
    system("$shell{'CHMOD'} +x $PROJECT_PATH/$PROJECT/start_$name.sh");

    open( STOP, ">$PROJECT_PATH/$PROJECT/stop_$name.sh" )
      or die "Failed to open $PROJECT_PATH/$PROJECT/start_$name.sh\n";
    print STOP "#!/bin/sh \n\n";
    print STOP "\necho \"Stopping swich ", $name, "\"\n";
    if ( $switch{'xen'} ) {
	print STOP "ifconfig $switch{'bridge'} down\n";
	print STOP "brctl delbr $switch{'bridge'}\n";
	} else {
	    print STOP "# killing th process\n";
	    print STOP "pkill -u \${USER} -f \"\\-unix $place\"\n";
	    print STOP "# Removing the socket\n";
	    print STOP "if [ -S $place ]; then rm $place; fi\n";
	}
    close(STOP);
	    
    system("$shell{'CHMOD'} +x $PROJECT_PATH/$PROJECT/stop_$name.sh");

    if ( %PLUGIN_LIST ){
	
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    
	    my $subcall = $plugin . "_configureSwitch"; 
#	    print "calling $subcall\n";
	    verbose("calling $subcall\n");
	    if ( defined(&$subcall) ){
		&$subcall($name);
	    }
	    
	}
    }    

}

sub buildNetwork {
    my $key;
    
    foreach $key ( getBlockKeys("/switch") ) {
	my $sh = getScalar("/switch/$key/service_host");
#	print "checking sh: $sh Vs SH: $SERVICE_HOST\n";
	if ( $SERVICE_HOST and $sh and $SERVICE_HOST ne $sh ){
	    
	} else {
	    out("---> Building switch $key\n");
	    buildSwitch($key);
	}
    }

}

sub buildMLNhosts {
    my $key;
    if ( $HOSTLIST ){
	foreach $key ( split /:/, $HOSTLIST ) {
	    my $service_host = getScalar("/host/$key/service_host");
	    if ( not $service_host or ($service_host eq $SERVICE_HOST)){ 
		buildMLNHost($key);
	    }
#            buildMLNHost($key);
        }
    } else {
	my @array = getHosts();
	
	foreach $key ( @array) {	
	    my $service_host = getScalar("/host/$key/service_host");
	    if ( not $service_host or ($service_host eq $SERVICE_HOST)){ 
		buildMLNHost($key);
	    }
	}
    }
}

sub buildHosts {
    my $key;
    if ($CONFIGURE_HOSTS_ONLY) {
        foreach $key ( split /:/, $HOSTLIST ) {
		buildHostFilesystem($key);
        }
    }
    else {
	my @array;
	if ( @RECONFIGURE_HOST_LIST ) {
	    @array = @RECONFIGURE_HOST_LIST;
	} else {
	    @array = getHosts();
	}
	foreach $key ( @array) {

	    my $service_host = getScalar("/host/$key/service_host");
#	    print "SH: $service_host, global: $SERVICE_HOST\n";
	    if ( not $service_host or ($service_host eq $SERVICE_HOST)){ 
		buildHostFilesystem($key);
	    }
        }
    }
}

sub createHostStartScript {
    verbose("creating start script\n");
    my $hostname       = $_[0];
    my $term           = $_[1];
    my $boot_order     = $_[2];
    $boot_order = $DEFAULTS{'BOOT_ORDER'} unless $boot_order;
    my $screen_command = $_[3];
    my $xterm_command  = $_[4];
    my $noterm_command = $_[5];
    my $owner          = getScalar("/host/$hostname/owner" );
    my $sudo           = getScalar( "/host/$hostname/sudo" );
    my $locking        = getScalar( "/host/$hostname/locking" );

    my $tun_owner      = $owner;
    my $xen = getScalar("/host/$hostname/xen");
    
    # first: remove any old boot order script:
    my $old_order = getScalar( "/host/$hostname/boot_order",$OLD_DATA_ROOT );

    if ( $old_order and $old_order != $boot_order ) {

        verbose("Removing old start and stop script\n");
        system(
"$shell{'RM'} $PROJECT_PATH/$PROJECT/start_${old_order}_$hostname.sh"
        );
        system(
            "$shell{'RM'} $PROJECT_PATH/$PROJECT/stop_${old_order}_$hostname.sh"
        );
    }

    $tun_owner = $sudo if ($sudo);
    out("writing $PROJECT_PATH/$PROJECT/start_${boot_order}_$hostname.sh\n" );
    open( HOSTSTART,
        ">$PROJECT_PATH/$PROJECT/start_${boot_order}_$hostname.sh" )
      or die "failed to open start_$hostname\n";
    if ( $xen ) {
	print HOSTSTART "#!/bin/sh\n";
	print HOSTSTART enableLock($hostname) if $locking;
	print HOSTSTART "type=\$1\n";
	print HOSTSTART
	  "mco=\$(/usr/sbin/xm list | grep \"$hostname.$PROJECT\" )\n";
	print HOSTSTART "if [ -n \"\$mco\" ]; then\n";
	print HOSTSTART "echo \"Host $hostname seems to be up already\"\n";
	print HOSTSTART "exit 1\n";
	print HOSTSTART "fi\n\n";
	print HOSTSTART "default=$term\n";
	
	print HOSTSTART "if [ -z \$type ]; then\n";
	print HOSTSTART "type=\$default\n";
	print HOSTSTART "fi\n";
	
	if ( getScalar("/host/$hostname/hvm") ){
	    print HOSTSTART "command=\"create ${hostname}_xen.hvm\"\n";
	    print HOSTSTART "echo Starting HVM ${hostname}\n";
	    if ( getScalar("/host/$hostname/locking")){
		print HOSTSTART enableLock($hostname,"/usr/sbin/xm \$command 1>/dev/null");
	    } else {
		print HOSTSTART "/usr/sbin/xm \$command 1>/dev/null";
	    }
	} else {
	    print HOSTSTART "command=\"create ${hostname}_xen.cfg\"\n";

	    print HOSTSTART "if [ -f $hostname.ram ]; then\n";
	    print HOSTSTART "command=\"restore $hostname.ram\"\n";
	    print HOSTSTART "echo \"Restoring $hostname from $hostname.ram\"\n";
	    print HOSTSTART "fi\n";

	    print HOSTSTART "if [ \"\$type\" = \"screen\" ]; then\n";
	    print HOSTSTART "if /usr/sbin/xm \$command 1>/dev/null; then \n";
	    print HOSTSTART "sleep 1; $screen_command\n";
	    print HOSTSTART "fi\n";

	    print HOSTSTART "elif [ \"\$type\" = \"xterm\" ]; then\n";
	    print HOSTSTART "if /usr/sbin/xm \$command 1>/dev/null; then \n";
	    print HOSTSTART "sleep 1; $xterm_command\n";
	    print HOSTSTART "fi\n";
	    
	    print HOSTSTART "elif [ \"\$type\" = \"none\" ]; then\n";
	    print HOSTSTART "if /usr/sbin/xm \$command 1>/dev/null; then \n";
	    print HOSTSTART "sleep 1; $noterm_command\n";
	    print HOSTSTART "fi\n";
	    print HOSTSTART "fi\n";
	    print HOSTSTART "if [ -x $hostname.ram ]; then rm $hostname.ram; fi\n";	
	}

	} else {
    # If host is not Xen-based then "none" is invalid
	    if ($term !~ m/(screen|xterm)/) {
		$term = "xterm"; # Make the default an xterm, per documentation
	    }
	    print HOSTSTART "#!/bin/sh\n";
	    print HOSTSTART "type=\$1\n";
	    print HOSTSTART
	      "mco=\$(find $PIDDIR_NAME -type s | grep \"/$hostname/\" )\n";
	    print HOSTSTART "if [ -n \"\$mco\" ]; then\n";
	    print HOSTSTART "echo \"Host $hostname seems to be up already\"\n";
	    print HOSTSTART "exit 1\n";
	    print HOSTSTART "fi\n\n";
	    
	    
	    my %net = getHash("/host/$hostname/network");

	    my $each;
	    my $tun    = 0;
	    my $bridge = 0;
	    foreach $each ( keys %net ) {
		$tun = 1 if ( $net{$each}{"tun_iface"} );
	    }

	    if ($tun) {
		
		print HOSTSTART "if [ \$UID == 0 ]; then\n";
		
		foreach $each ( keys %net ) {
#	    print "checking $each\n";
		    if ( getScalar("/host/$hostname/network/$each/tun_iface") ) {
			print HOSTSTART "TUN_DEVICE=" . $net{$each}{"tun_iface"} . "\n";
			print HOSTSTART "TUN_ADDRESS=" . $net{$each}{"tun_address"} . "\n";
			print HOSTSTART "NETMASK=" . $net{$each}{"netmask"} . "\n";
			if ($tun_owner) {
			    print HOSTSTART "OWNER=$tun_owner\n";
			}
			print HOSTSTART
			  "if ! /sbin/ifconfig \$TUN_DEVICE &> /dev/null ; then\n";
			if ($tun_owner) {
			    print HOSTSTART "tunctl -t \$TUN_DEVICE -u \$OWNER\n";
			}
			else {
			    print HOSTSTART "tunctl -t \$TUN_DEVICE\n";
			}
                print HOSTSTART
			  "/sbin/ifconfig \$TUN_DEVICE \$TUN_ADDRESS netmask \$NETMASK up\n";
			print HOSTSTART "fi\n";
		    }
		}
		print HOSTSTART "fi\n";
	    }
	    print HOSTSTART "default=$term\n";
	    
	    print HOSTSTART "if [ -z \$type ]; then\n";
	    print HOSTSTART "type=\$default\n";
	    print HOSTSTART "fi\n";
	    
	    print HOSTSTART "if [ \"\$type\" = \"screen\" ]; then\n";
	    print HOSTSTART "$screen_command\n";
	    print HOSTSTART "elif [ \"\$type\" = \"xterm\" ]; then\n";
	    print HOSTSTART "$xterm_command\n";
	    print HOSTSTART "fi\n";
	    
	}
    close(HOSTSTART);
    system("$shell{'CHMOD'} +x $PROJECT_PATH/$PROJECT/start_${boot_order}_$hostname.sh");
}

sub removeLock {
    my $hostname = $_[0];
    my $command = $_[1];
    chomp $command;
    my $lockdir = getScalar("/host/$hostname/lock_dir");
    $lockdir = $DEFAULTS{LOCK_DIR} unless $lockdir;
    if ( $lockdir ){
	verbose("Adding locking code to start script\n");
	my $string = "if $command; then\n";
	$string .= "if [ -e $lockdir/$hostname.$PROJECT ]; then\n";
	$string .= "rm $lockdir/$hostname.$PROJECT\n";
	$string .= "else\n";
	$string .= "WARNING: This VM was supposed to be locked, but no lock was found.\n";
	$string .= "fi\n";
	$string .= "fi\n"; 
	return $string;
    } else {
	return "echo 'WARNING: Locking enabled, but no lock_dir found!'\n";
    }
    
}   


sub enableLock {
    #  
    my $hostname = $_[0];
    my $command = $_[1];
    chomp $command;
    my $lockdir = getScalar("/host/$hostname/lock_dir");
    my $lock_timeout = getScalar("/host/$hostname/lock_timeout");
    $lockdir = $DEFAULTS{LOCK_DIR} unless $lockdir;
    $lock_timeout = $DEFAULTS{LOCK_TIMEOUT} unless $lock_timeout;
    if ( $lockdir ){
	verbose("Adding locking code to start script\n");
	my $string = "if [ -e $lockdir/$hostname.$PROJECT ]; then\n";
        $string .= "old=\$(head -1 $lockdir/$hostname.$PROJECT)\n";
	$string .= "new=\$(date +\%s)\n";
	$string .= "diff=\$(( \$new - \$old ))\n";
	$string .= "if [ \$diff -le $lock_timeout ]; then\n";	
	$string .= "echo \"LOCK: lock already established by \$(head -2 $lockdir/$hostname.$PROJECT)\"\n";
	$string .= "exit 1\n";
	$string .= "fi\n";
	$string .= "fi\n"; 
	$string .= "if $command; then\n";
	$string .= "while virsh list | grep $hostname.$PROJECT > /dev/null; do date +\%s > $lockdir/$hostname.$PROJECT; echo \$HOSTNAME >> $lockdir/$hostname.$PROJECT; sleep $lock_timeout; done &\n";
	$string .= "fi\n"; 	
	return $string;
    } else {
	return "echo 'WARNING: Locking enabled, but no lock_dir found!'\n";
    }
    
}

sub createHostStopScript {
    verbose("creating stop script\n");
    my $hostname   = $_[0];
    my $boot_order = $_[1];
    $boot_order = $DEFAULTS{'BOOT_ORDER'} unless $boot_order;    
    my $owner = getScalar("/host/$hostname/owner" );
    my %net   = getHash( "/host/$hostname/network" );
    my $xen = getScalar("/host/$hostname/xen");
    my $each;
    my $tun    = 0;
    my $bridge = 0;
    foreach $each ( keys %net ) {
        $tun = 1 if ( $net{$each}{"tun_iface"});
    }
    out("writing $PROJECT_PATH/$PROJECT/stop_${boot_order}_$hostname.sh\n" );    
    open( STOP, ">$PROJECT_PATH/$PROJECT/stop_${boot_order}_$hostname.sh" )
      or die "Failed to open $STOP_SCRIPT\n";
    print STOP "#!/bin/sh\n";
    
    if ($xen ){
	print STOP "STOP=shutdown\n";

	print STOP "if \[ \$1 \]; then\n";
	print STOP "if \[ \$1 = \"save\" \]; then\n";
	print STOP "echo \"Saving $hostname in $PROJECT_PATH/$PROJECT/$hostname.ram\"\n";
	
	print STOP "xm save $hostname.$PROJECT $PROJECT_PATH/$PROJECT/$hostname.ram\n";
	
	print STOP "exit\n";
	print STOP "fi\n";
	print STOP "fi\n";

	
	
	print STOP "if \[ \$1 \]; then\n";
	print STOP "STOP=destroy\n";
	print STOP "echo \"Brute force on $hostname\"\n";
	print STOP "fi\n";
	
	
	
	#
	print STOP "echo \"$hostname... OK\"\n";
	if ( getScalar("/host/$hostname/locking")){
	    print STOP removeLock($hostname,"xm \$STOP $hostname.$PROJECT 2>/dev/null");
	} else {
	    print STOP "xm \$STOP $hostname.$PROJECT 2>/dev/null\n";
	}
	

	
    } else {
    print STOP "STOP=cad\n";
    
    print STOP "if \[ \$1 \]; then\n";
    print STOP "STOP=halt\n";
    print STOP "echo \"Brute force on $hostname\"\n";
    print STOP "fi\n";
    
    print STOP "mco=\$(find $PIDDIR_NAME -type s | grep \"/$hostname/\" )\n";
    
    #
    print STOP "if \[ \$mco \]; then\n";
    print STOP "echo -n \"$hostname... \"\n";
    
    print STOP "$shell{'UML_MCONSOLE'} \$mco \$STOP 2>/dev/null\n";
    
    print STOP "else\n";
    print STOP "echo \" Console for $hostname not found. Alreaddy off?\"\n";
    print STOP "exit 1\n";
    print STOP "fi\n";
    
    if ($tun) {
	
        print STOP "if [ \$UID == 0 ]; then\n";
	
        foreach $each ( values %net ) {
            if ( $net{$each}{"tun_iface"} ) {
                print STOP
                  "echo \"I need to wait for $hostname to shutdown before "
                  . $net{$each}{"tun_iface"}
		. " can be removed\"\n";
            }
        }
        print STOP "while [ -w \$mco ]; do sleep 2 ; done\n";
	
        foreach $each ( values %net ) {
            if ( $net{$each}{"tun_iface"} ) {
                print STOP "echo \"removing " . $net{$each}{"tun_iface"} . "\"\n";
                print STOP "TUN_DEVICE=" . $net{$each}{"tun_iface"} . "\n";
                print STOP "/sbin/ifconfig \$TUN_DEVICE down\n";
                print STOP "tunctl -d \$TUN_DEVICE\n";
            }
        }
        print STOP "fi\n\n";
    }
    }
    close(STOP);
    system(
	"$shell{'CHMOD'} +x $PROJECT_PATH/$PROJECT/stop_${boot_order}_$hostname.sh"
    );
}


sub buildGlobalConfig {

    checkForProjectName();
#    checkIfLocal();

}

sub checkForProjectName {
    my $project = getScalar("/global/project");
    if ( not $project ) {
	print "No project name found, you should at least have global { project project_name } in the config\n";
	exit 1;
#        askForProjectName();
    }
    else {
        setProjectName( $project );
    }

}

sub checkIfLocal {
    if ($GLOBAL) {

        #	  We do this to deprecate a previous functionality.
        $LOCAL = "yes";

        $shell{"UML_SWITCH"} = which('uml_switch');
        chomp $shell{"UML_SWITCH"};
        $shell{"TUNCTL"} = which(tunctl);
        chomp $shell{"TUNCTL"};
        $shell{"UML_MCONSOLE"} = which('uml_mconsole');
        chomp $shell{"UML_MCONSOLE"};

    }
}

###################################
# Read the files and the permissions
# to be copied into the image.

sub filesParser {

    debug("filesParser Called");
    my @line;
    my @files;
    my $filecounter = 0;

    while ( @line = getCLine() ) {

        #	  $l =~ s/^\s*//;

        #	  @line = split /\s+/, $l;

        last if $line[0] =~ /\}/;

        if ( not $line[0] =~ /\{/ ) {
            my $file = new File;

            $file->from("$line[0]");
            $file->to("$line[1]");
            $file->permissions("$line[2]");

            $files[ $filecounter++ ] = $file;
            debug(  "filesParser: to("
                  . $file->to
                  . ") from("
                  . $file->from
                  . ") perm("
                  . $file->permissions
                  . ")\n" );
        }

    }

    return @files;

}

sub mountParser {

    #      print "FileHandler Called\n";
    my @line;
    my @mount;
    my $counter = 0;

    while ( @line = getCLine() ) {

        #	  $l =~ s/^\s*//;

        #	  @line = split /\s+/, $l;

        last if $line[0] =~ /\}/;

        if ( not $line[0] =~ /\{/ ) {
            my $mount = new Mount;

            $mount->from( getValue( $line[0] ) );
            $mount->to( getValue( $line[1] ) );
            $mount->type( getValue( $line[2] ) );

            if ( $line[3] ) {
                $mount->options( getValue( $line[3] ) );
            }

            $mount[ $counter++ ] = $mount;
        }

    }

    return @mount;

}

# sub createHost2Role {
#     debug("createHost2Role called");
#     my $host;
#     my $hfc = 0;
#     my @array;
#     my $each;
#     my $tm;

#     debug("createHostsFile called");

#     foreach $host ( getBlockKeys("/host") ) {
#         @array = getArray( "/hostname/$host/roles" );
#         if (@array) {
#             foreach $each (@array) {

#                 $HOST2ROLE_FILE[ $hfc++ ] = $hfc + 1 . "\thost\t$host\t$each";
#                 debug("createHostsFile: $HOSTS_FILE[$hfc - 1]");
#             }

#         }

#     }

# }

sub createHostsFile {
    my $host;
    my $hfc = 0;
    my %array;
    my $each;
    my $tm;

    debug("createHostsFile called");

    foreach $host ( getHosts() ) {
            %array = getHash("/host/$host/network");
            if (%array) {
                foreach $each ( keys %array ) {
                    if ( $array{$each}{"address"} =~ /\d+\.\d+\.\d+\.\d+/ ) {
                        $HOSTS_FILE[ $hfc++ ] = $array{$each}{"address"} . "\t$host";
                        debug("createHostsFile: $HOSTS_FILE[$hfc - 1]");
                    }
                }
            }
    }
    
    @HOSTS_FILE = ( @HOSTS_FILE, @HOSTS_FILE_COMMON );
}

sub setHostsFile {

    #      out("Setting hosts file\n");
    my $hostname = $_[0];

    my $i = 0;

    if ( not open( HOSTS, ">$MOUNTDIR/etc/hosts" ) ){
	verbose("Failed to open file $MOUNTDIR/etc/hosts\n");
	return;
    }
    my $temp =  "127.0.0.1 localhost $hostname\n";
    print HOSTS $temp;
    for ( $i = 1 ; $i <= $#HOSTS_FILE ; $i++ ) {
        print HOSTS "$HOSTS_FILE[$i]\n";
    }
    close HOSTS;

}

sub usersParser {
    my @users;
    my $i = 0;
    my $l;
    my @line;

    debug("usersParser: called");
    while ( @line = getCLine() ) {
        last if $line[0] =~ /\}/;

        if ( not $line[0] =~ /\{/ ) {
            my $user = new User;

            $user->name( getValue( $line[0] ) );
            $user->password( getValue( $line[1] ) );
            if ( $line[2] ) {
                $user->homedir( getValue( $line[2] ) );
            }
            if ( $line[3] ) {

                $user->uid( getValue( $line[3] ) );
            }
            $users[ $i++ ] = $user;
        }

    }

    return @users;

}


sub setUsers {
    my $hostname = $_[0];
    my $temp     = $_[1];
    my @users    = @$temp;
    my $FAILOVER;
    mkdir("$MOUNTDIR/var/mln") unless stat("$MOUNTDIR/var/mln");
    my $homedir;
    my $each;

    
    out("Adding users: ");
    foreach $each (@users) {
	my @ua = split /\s+/,$each;
        out( $ua[0] . "," );
	# check if user exists
	my $line = `grep "^$ua[0]:" $MOUNTDIR/etc/passwd`;
	chomp $line;
	if ( $line ){
	    verbose("old user found: $line\n");
	    open(PASSWD,"$MOUNTDIR/etc/passwd");
	    if (PASSWD){
		my @array;
		foreach( <PASSWD> ){
		    if ( $_ =~ /^($ua[0]:)\S+(:\d+:\d+:.*)$/g ){
#			print "changed: $_";
#			print "to: $1 . $ua[1] . $2\n";
			push(@array,$1 . $ua[1] . $2 . "\n");
		    } else {
			push(@array,$_);
		    }
		    
		}	    
		close(PASSWD);
		open(PASSWD,">$MOUNTDIR/etc/passwd");
		foreach (@array){
		    print PASSWD $_;
		}
		close(PASSWD);	    
	    
	    } 
	}else {
        my $command = "/usr/sbin/useradd -s /bin/bash -m -k /etc/skel ";
	
        if ( $ua[1] ) {
            $command .= "-p \'" . $ua[1] . "\' ";
        }
	
        if ( $ua[2] ) {
            $homedir = $ua[2];
        }
        else {
            $homedir = "/home/" . $ua[0];
        }
	
	
	if ( not $RECONFIGURE ){
	    system("$shell{'CHROOT'} $MOUNTDIR mkdir -p $homedir");
	    $command .= "-d $homedir ";
	    
	    if ( $ua[3] ) {
		
		$command .= " -u " . $ua[3] . " -o ";
	    }
	    
	    $command .= $ua[0];
	    
	    verbose("setUser: $command\n");
	    # my $return = system("$shell{'CHROOT'} $MOUNTDIR $command 2>&1");
	    my @outp = `$shell{'CHROOT'} $MOUNTDIR $command 2>&1`;
	    print "error: $?\n";
	    foreach (@outp){
	       print $_;
	    }
#	print "return $return\n";
	    system( "$shell{'CHROOT'} $MOUNTDIR chown -R "
		. $ua[0]
		. " $homedir" );
#	system("cat $MOUNTDIR/etc/passwd");
#	system("ls $MOUNTDIR/home");
	    if ( stat("$MOUNTDIR/home") and not stat("$MOUNTDIR/home/$ua[0]") ){
		out("MLN needs to add the user using a start-script\n");
		$FAILOVER = 1;
		open(STARTUP,">>$MOUNTDIR/etc/init.d/startup_once"); 
		print STARTUP "mkdir -p $homedir\n";
		print STARTUP "$command\n";
		print STARTUP "chown -R $ua[0] $homedir\n";
		close(STARTUP);
	    }
	
#    print "setUsers done\n";
	    out("\n");
	    if ( $FAILOVER){
		system("ln -s /etc/init.d/startup_once $MOUNTDIR/etc/rc2.d/S19startup_once");
		system("chmod +x  $MOUNTDIR/etc/init.d/startup_once");
		open(STARTUP,">>$MOUNTDIR/etc/init.d/startup_once"); 
		print STARTUP "rm /etc/init.d/startup_once\n";
		print STARTUP "rm /etc/rc2.d/S19startup_once\n";
		close(STARTUP);
	    }
	} else {
	    print "Alternate path for reconfigure\n";
	    open(PASSWD,"$MOUNTDIR/etc/passwd");
	    if (PASSWD){
		my @array;
		foreach( <PASSWD> ){
		    if ( $_ =~ /^($ua[0]:)\S+(:.*)$/ ){
#			print "changed: $_";
#			print "to: $1 . $ua[1] . $2\n";
			push(@array,$1 . $ua[1] . $2);
		    } else {
			push(@array,$_);
		    }
		    
		}	    
		close(PASSWD);
		open(PASSWD,">$MOUNTDIR/etc/passwd");
		foreach (@array){
		    print PASSWD $_;
		}
		close(PASSWD);
	    }
	}
	}
    }	
}

sub checkForUserModeCopy {
    return unless ( $USER_MODE or $USER_MODE_REC );

    my $fs = getLatestTemplate($USER_MODE_COPY_FS);
    if ( not stat("$TEMPLATEDIR/$fs") ) {
        die(
"I need the filesystem template called $USER_MODE_COPY_FS, you should download it\n"
          )

    }

    #      my $linux = `which `;
    #     chomp $linux;

#      die "You need to have user-mode-linux installed to build these filesystems in user mode\n" unless $linux;

    $shell{'LINUX'} = $DEFAULTS{KERNEL};
}

sub registerTemplate {

    my $opt_string = 't:m:n:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    my $MESSAGE       = $opt{m};
    my $NAME          = $opt{n};
    my $TEMPLATE_PATH = $opt{t};
    my $TEMPLATE      = $TEMPLATE_PATH;

    # removing path

    $TEMPLATE =~ s/.*\///g;

    if ( not $NAME ) {
        $NAME = getTemplateName($TEMPLATE);
    }

    if ( stat("$TEMPLATE_PATH") ) {
        print "Copying $TEMPLATE\n";

        system("$shell{'CP'} $TEMPLATE_PATH $TEMPLATEDIR");
        if ( not stat("$TEMPLATEDIR/$TEMPLATE") ) {
            out( "Copy failed, exiting.\n", "red" );
        }

        if ( $TEMPLATE =~ /tar\.gz$/ ) {
            print("Extracting...\n");
            system("$shell{'TAR'} xzf $TEMPLATEDIR/$TEMPLATE -C $TEMPLATEDIR");
            system("$shell{'RM'} -- $TEMPLATEDIR/$TEMPLATE");

            addToTemplateList( $TEMPLATE, $MESSAGE );

        }
        elsif ( $TEMPLATE =~ /tar\.(bz|bz2)$/ ) {
            print("Extracting...\n");
            system("$shell{'TAR'} xjf $TEMPLATEDIR/$TEMPLATE -C $TEMPLATEDIR");
            system("$shell{'RM'} -- $TEMPLATEDIR/$TEMPLATE");

            addToTemplateList( $TEMPLATE, $MESSAGE );

        }
        elsif ( $TEMPLATE =~ /\.(ext2|ext3|img)$/ ) {
            out("No need to extract.\n");
            addToTemplateList( $TEMPLATE, $MESSAGE );
        }
        else {
            print
"Unknown compression format. You need to uncompress it yourself. It is located here:\n$TEMPLATEDIR/$TEMPLATE\nPress enter to continue.\n";
            <STDIN>;
        }
    }
    else {
        print "Sorry, file $TEMPLATE not found\n";
    }

}

sub addToTemplateList {

    my $TEMPLATE = $_[0];
    my $MESSAGE  = $_[1];

    my $name = getTemplateNameWithVersion($TEMPLATE);

    if ( $name eq $TEMPLATE ) {

        $name =~ s/\.tar\.(gz|bz|bz2)//;
    }

    checkIfTemplateExists( $name, "remove" );
    my $rname = getTemplateNameWithVersion($TEMPLATE);

    my $bsize = getTemplateSize($rname);

    my $size = int( $bsize / 1000000 );

    my $tt = getTemplateType($TEMPLATE);

    my $type = "gzip"  if ( $tt eq "gz" );
    my $type = "bzip2" if ( $tt eq "bz" or $tt eq "bz2" );

    my $reg_line = "$name $rname ${size}MB $type \"$MESSAGE\"";

    if ( !stat("$TEMPLATEDIR/$TEMPLATE_LIST_FILE") ) {
        open( TL, ">$TEMPLATEDIR/$TEMPLATE_LIST_FILE" )
          or die "failed to open $TEMPLATEDIR/$TEMPLATE_LIST_FILE\n";
    }
    else {
        open( TL, ">>$TEMPLATEDIR/$TEMPLATE_LIST_FILE" )
          or die "failed to open $TEMPLATEDIR/$TEMPLATE_LIST_FILE\n";
    }
    print TL "$reg_line\n";
    close(TL);

}

sub checkIfTemplateExists {

    my $template = $_[0];
    my $remove   = $_[1];
    my $line;
    my $name;
    my @lines;
    if ( not stat("$TEMPLATEDIR/$TEMPLATE_LIST_FILE") ) {
        return 0;
    }

    open( TL, "$TEMPLATEDIR/$TEMPLATE_LIST_FILE" )
      or die "failed to open $TEMPLATEDIR/$TEMPLATE_LIST_FILE\n";
    while ( $line = <TL> ) {

        $name = ( split /\s+/, $line )[1];

        if ( $template eq $name ) {

            if ( not $remove ) {
                close(TL);
                return 1;
            }
            else {
                out( "Removing old entry for $name\n", "red" );
            }
        }
        elsif ($remove) {

            push( @lines, $line );
        }
    }
    close(TL);

    if ($remove) {
        open( TL, ">$TEMPLATEDIR/$TEMPLATE_LIST_FILE" )
          or die "failed to open $TEMPLATEDIR/$TEMPLATE_LIST_FILE\n";
        my $each;
        foreach $each (@lines) {
            print TL "$each";
        }
        close(TL);
    }

    return 0;
}

sub downloadTemplates {

    my $opt_string = 'ut:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
    my $ONLY_NEW;

    $ONLY_NEW = 1 if $opt{u};

    # Here we determine if this subroutine has been called with
    # the default parameter. This should not interfere with the
    # CLI option processing.
    my $GET_DEFAULT;
    if ( $_[0] eq 'default' ) {
        $GET_DEFAULT = 1;
    }

    # Let's see if we have been passed an option to use a mirror,
    # either via CLI or as the second subroutine parameter (which
    # will only be used when the first parameter is default).
    my $USE_MIRROR;
    my $template_mirror;
    if ( $GET_DEFAULT && $_[1] ) {
        $USE_MIRROR      = 1;
        $template_mirror = $_[1];
    }
    elsif ( $opt{t} ) {
        $USE_MIRROR      = 1;
        $template_mirror = $opt{t};
    }

    while ( $template_mirror =~ /\/$/ ) { $template_mirror =~ s/\/$//; }

    my $WGET = which('wget');
    chomp $WGET;

    my $PWD = `pwd`;
    chomp $PWD;

    die "You need to have wget installed. Failed to find wget in your path\n"
      unless stat($WGET);

#      die "You can only run this script standing in the root of your mln-X.X directory\n" unless stat ("$PWD/$TEMPLATE_DIR");

    if ($USE_MIRROR) {
        open( TEMPLATES, "$template_mirror/${TEMPLATE_LIST_FILE}" )
          or die "Failed to get list from $template_mirror\n";
        $DEBUG
          && out("DEBUG: Using local templates mirror: $template_mirror\n");
    }
    else {
        open( TEMPLATES,
            "$WGET -q -O - ${TEMPLATE_LIST_SITE}/${TEMPLATE_LIST_FILE} |" )
          or die "Failed to get list\n";
    }

    my $template;
    my @line;
    my $ret;

    while ( $template = <TEMPLATES> ) {
        chomp $template;
        @line = split /\s+/, $template;
        my $v = getTemplateVersion( $line[1] );
        system("clear");
        my $new = templateIsNewer( $line[1] );
        $DEBUG && print "DEBUG: new: $new\n";

        # Go to the next iteration, if:
        # 1. We're only looking for new updates, AND
        # 2. The current template is not new.
        if (
            ( $ONLY_NEW and not( $new eq "yes" ) )
            or ( $GET_DEFAULT
                and ( $line[0] ne $DEFAULTS{TEMPLATE} ) )
          )
        {
            next;
        }
        $DEBUG && print "DEBUG: ONLY_NEW: $ONLY_NEW\n";

        # This is a kludge. :-(
        # The following block is duplicated code that is
        # designed to get the default template (if $GET_DEFAULT)
        # and then return. There must be a better way to do this,
        # though it might require some code shuffling. Perhaps
        # it would be a good idea to rewrite much of the logic
        # and display code for downloadTemplates, including better
        # logic for getting the default template.
        if ($GET_DEFAULT) {
            my $def_template_dir = $line[1];
            $def_template_dir =~ s/.tar.gz//;

            if ( stat("$TEMPLATEDIR/$def_template_dir") ) {
                out(
"You already have the correct version of the default template, no need to download it again.\n"
                );
            }
            else {

                out("Downloading default template...\n");

                # Here we do a conditional block to see if we're using a local
                # mirror for templates.
                if ($USE_MIRROR) {
                    out(
"$shell{CP} $template_mirror/$line[1] $TEMPLATEDIR/$line[1]\n"
                    );
                    $ret =
                      system(
"$shell{CP} $template_mirror/$line[1] $TEMPLATEDIR/$line[1]"
                      );
                }
                else {

                    out(
"$shell{WGET} -O - http://$TEMPLATE_FILE_MIRROR\.$TEMPLATE_FILE_SITE/$line[1] > $TEMPLATEDIR/$line[1]\n"
                    );
                    $ret =
                      system(
"$shell{WGET} -O - http://$TEMPLATE_FILE_MIRROR\.$TEMPLATE_FILE_SITE/$line[1] > $TEMPLATEDIR/$line[1]"
                      );
                }

                if ( $line[3] =~ /gzip/ and $ret == 0 ) {
                    print("Extracting...\n");
                    my $message = getRestAsString( 4, \@line );
                    system(
"$shell{'TAR'} xzf $TEMPLATEDIR/$line[1] -C $TEMPLATEDIR"
                    );
                    system("$shell{'RM'} -- $TEMPLATEDIR/$line[1]");

                    addToTemplateList( $line[1], $message );
                }
                else {
                    print
"Unknown compression format. You need to uncompress it yourself. It is located here:\n$TEMPLATEDIR/$line[1]\nPress enter to continue.\n";
                    <STDIN>;
                }
            }
            close(TEMPLATES);
            return;
        }    # Close if $GET_DEFAULT

        print "Found this template: "
          . getTemplateName( $line[1] )
          . " Version: "
          . $v->major . "."
          . $v->minor;
        if ( $new eq "yes" ) {
            print " NEW!\n";
        }
        else {
            print "\n";
        }
        print "Size: $line[2]\n";
        print "Description:\n";
        my $message = getRestAsString( 4, \@line );
        print "$message\n";
        print "Would you like to download it? (y/n) (Default: n) ";
        my $answer = <STDIN>;
        if ( $answer =~ /^([yY]|yes)/ ) {

            # Here we do a conditional block to see if we're using a local
            # mirror for templates.
            if ($USE_MIRROR) {
                out(
"$shell{CP} $template_mirror/$line[1] $TEMPLATEDIR/$line[1]\n"
                );
                $ret =
                  system(
                    "$shell{CP} $template_mirror/$line[1] $TEMPLATEDIR/$line[1]"
                  );
            }
            else {

                out(
"$shell{WGET} -O - http://$TEMPLATE_FILE_MIRROR\.$TEMPLATE_FILE_SITE/$line[1] > $TEMPLATEDIR/$line[1]\n"
                );
                $ret =
                  system(
"$shell{WGET} -O - http://$TEMPLATE_FILE_MIRROR\.$TEMPLATE_FILE_SITE/$line[1] > $TEMPLATEDIR/$line[1]"
                  );
            }

            if ( $line[3] =~ /gzip/ and $ret == 0 ) {
                print("Extracting...\n");
                system(
                    "$shell{'TAR'} xzf $TEMPLATEDIR/$line[1] -C $TEMPLATEDIR");
                system("$shell{'RM'} -- $TEMPLATEDIR/$line[1]");

                addToTemplateList( $line[1], $message );
            }
            else {
                print
"Unknown compression format. You need to uncompress it yourself. It is located here:\n$TEMPLATEDIR/$line[1]\nPress enter to continue.\n";
                <STDIN>;
            }
        }
    }
    close(TEMPLATES);
}

sub makeDir {
    if ( not stat( $_[0] ) ) {
        out("The directory $_[0] is not present: \n");
        out("Trying to create it ... ");
        system("mkdir -p $_[0]");
        if ( stat( $_[0] ) ) {
            out("OK\n");
        }
        else {
            out("Failed\n");
            out("Unable to create the directory $_[0]. Aborting\n");
            exit 1;
        }
    }

}

sub writeMLNdaemonScript {
    
    open(FILE,">/etc/init.d/mlnd");
    
    print FILE "#!/bin/bash\n\n\n";
    print FILE "# MLN daemon start/stop script\n";
    print FILE 'case "$1" in' . "\n";
    print FILE '           start)' . "\n";
    print FILE '            echo "Starting MLN daemon..."' . "\n";
    print FILE '            /usr/local/bin/mln daemon -D /var/run/mln.pid' . "\n";
    print FILE '            ;;' . "\n";
    print FILE '           stop)' . "\n";
    print FILE '            echo "Stopping MLN daemon... "' . "\n";
    print FILE '            kill $(cat /var/run/mln.pid)' . "\n";
    print FILE '            ;;' . "\n";
    print FILE '           restart)' . "\n";
    print FILE '            $0 stop' . "\n";
    print FILE '            sleep 1' . "\n";
    print FILE '            $0 start' . "\n";
    print FILE '            ;;' . "\n";
    print FILE '           *)' . "\n";
    print FILE '            print "Usage: $0 {start|stop|restart}"' . "\n";
    print FILE '            ;;' . "\n";
    print FILE 'esac' . "\n";
    close(FILE);
    system("chmod +x /etc/init.d/mlnd");
}

sub setupMLN {

    # Command line parsing:
    my $opt_string = 'nsl:t:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    my $uml_mirror;
    if ( $opt{l} ) {
        $uml_mirror = $opt{l};
        $DEBUG && print "DEBUG: Using UML Mirror: $uml_mirror\n";

        # Here we are checking to see whether or not the mirror
        # location exists. If it does, great. If not, we need
        # to complain about it and exit.
        #
        # Also, if we want to support URIs, then this will need
        # probably need to be changed.

        unless ( -d "$uml_mirror" ) {
            print
"Error: UML mirror directory $uml_mirror does not exist or is not a directory.\n";
            exit;
        }

        # Remove any trailing slashes.
        while ( $uml_mirror =~ /\/$/ ) { $uml_mirror =~ s/\/$//; }

    }

    my $template_mirror;
    if ( $opt{t} ) {
        $template_mirror = $opt{t};
        $DEBUG && print "DEBUG: Using Template Mirror: $template_mirror\n";

        # Here we are checking to see whether or not the mirror
        # location exists. If it does, great. If not, we need
        # to complain about it and exit.
        #
        # Also, if we want to support URIs, then this will need
        # probably need to be changed.

        unless ( -d "$template_mirror" ) {
            print
"Error: UML mirror directory $template_mirror does not exist or is not a directory.\n";
            exit;
        }

        # Remove any trailing slashes.
        while ( $template_mirror =~ /\/$/ ) { $template_mirror =~ s/\/$//; }

    }

    my $SINGLE;

    my $SYSTEM_WIDE;
    my $PROJECT_INSTALL_DIR;
    my $FILES_INSTALL_DIR;
    my $TEMPLATE_INSTALL_DIR;
    my $UML_INSTALL_DIR;
    my $UML;
    my $SYSTEM_WIDE_PREFIX;
    my $DISTRIBUTED_FRONT;
    my $DISTRIBUTED_BACK;
    my $W_CONFIG_FILE;
    my $SERVICE_HOST;
    my $FRONTEND_IP;
    my $response;
    my $PREV_CONFIG;
    my $answer;
    my $DEFAULT_PLUGIN_DIR = "/etc/mln/plugins";
    my $DEFAULT_PERSONAL_PLUGIN_DIR = ".mln_plugins";
    
    unless ( $opt{n} ) {
      # This method installs MLN and UML from scratch.
      # tasklist for single user setup:
      system("clear");
      print "################ MLN INSTALLER ###########\n";
      print
"In order to install MLN on your system,\nsome questions need to be answered:\n";
      print "\n";
      print
"Do you want to set up MLN for your user or for the entire system?\n";
      print "1 - Single user (Default)\n";
      print "2 - Entire system (Need to be root)\n";
      print "3 - MLN frontend for distributed management (Need to be root)\n";
      print "4 - MLN daemon backend for distributed management (Need to be root)\n";
      print "[1]: ";
      
	$answer = <STDIN>;
      chomp $answer;
    }

    $DISTRIBUTED_FRONT = 1 if $answer == 3;
    $DISTRIBUTED_BACK = 1 if $answer == 4;
    
    if ( $answer == 2 || $answer == 3 || $answer == 4 || $opt{s} ) {
        $SYSTEM_WIDE = 1;

        makeDir($SYS_CONF_DIR);

        # Read in previous configuration.
#        if ( stat($DEFAULT_FILE) ) {
#            $PREV_CONFIG = 1;
#            parseConfig($DEFAULT_FILE);
#        }

        unless ($PREV_CONFIG) {
	    
	    # For system installations, determine the default prefix, which will be
	    # used for derivative questions.
            $response = $GLOBAL_USER_PREFIX;
            unless ( $opt{n} ) {
		print "\n";
		print
		  "What would you like the default install prefix to be? [ $GLOBAL_USER_PREFIX ] : ";
		$answer = <STDIN>;
		chomp $answer;
		while ( $answer =~ /\/$/ ) { $answer =~ s/\/$//; }
            }
	    
            if ($answer && !$opt{n}) {
                $SYSTEM_WIDE_PREFIX = $answer;
            }
            else {
                $SYSTEM_WIDE_PREFIX = $response;
            }
        }
    }
    else {
        if ( stat("$ENV{'HOME'}/$CONFIG_FILE_NAME") ) {
            $PREV_CONFIG = 1;
            parseConfig("$ENV{'HOME'}/$CONFIG_FILE_NAME");
        }
    }
    
    # where to store UML?
    
    if ($SYSTEM_WIDE) {
        $response =
          $PREV_CONFIG ? $UML_PATH : "$SYSTEM_WIDE_PREFIX/$GLOBAL_USER_UML_DIR";
    }
    else {
        $response = $PREV_CONFIG ? $UML_PATH : $SINGLE_USER_UML_DIR;
    }
    my $INSTALL_UML = 1;
    out("Do you want to install User-Mode Linux? [N/y]: ");
    $answer = <STDIN>;
    chomp $answer;
    $answer = "N" unless $answer;
    while ( not $answer =~ /Y|y|n|N/ ) { 
	out("[N/y]");
	$answer = <STDIN>;
	chomp $answer;
	$answer = "N" unless $answer;	
    }
    if ( $answer =~ /N|n/){
	$INSTALL_UML = 0;
    } 
    
    if ( $INSTALL_UML ){
	unless ( $opt{n} ) {
	    print "\n";
	    print "Where do you want to store the User-Mode Linux kernel and modules?\n";
	    print "[ " . $response . " ]  : ";
	    
	    $answer = <STDIN>;
	    chomp $answer;
	    while ( $answer =~ /\/$/ ) { $answer =~ s/\/$//; }
	}
	
	
	if ($answer && !$opt{n}) {
	    $UML_INSTALL_DIR = $answer;
	}
	else {
	    $UML_INSTALL_DIR = $response;
	}
	makeDir($UML_INSTALL_DIR);
	
	# get UML from website if necessary
	
	$UML = $UML_KERNEL_PACKAGE;
	$UML =~ s/\.tar\.gz//;
	
	my $uml_done;
	my $uml_ret;
	if ( stat("$UML_INSTALL_DIR/$UML") ) {
	    $uml_done = 1;
	    out(
		"You already have the correct version of UML, no need to download it again.\n"
	    );
	}
	elsif ($uml_mirror) {
	    print "Downloading precompiled UML from $uml_mirror:\n";
	    print
	      "$shell{CP} $uml_mirror/$UML_KERNEL_PACKAGE $UML_INSTALL_DIR/$UML_KERNEL_PACKAGE\n";
	    $uml_ret =
	      system(
"$shell{CP} $uml_mirror/$UML_KERNEL_PACKAGE $UML_INSTALL_DIR/$UML_KERNEL_PACKAGE"
	      );
	}
	else {
	    print "Downloading precompiled UML from the MLN website:\n";
	    print
	      "$shell{WGET} -O - ${UML_DOWNLOAD_PATH}$UML_KERNEL_PACKAGE > $UML_INSTALL_DIR/$UML_KERNEL_PACKAGE\n";
	    $uml_ret =
	      system(
		  "$shell{WGET} -O - ${UML_DOWNLOAD_PATH}$UML_KERNEL_PACKAGE > $UML_INSTALL_DIR/$UML_KERNEL_PACKAGE"
	      );
	}
	
	# unpack and store UML the right place

	if ($uml_ret) {
	    "Encountered an error message. Aborting\n";
	}
	
	unless ($uml_done) {
	    print "Extracting ${UML_INSTALL_DIR}/$UML_KERNEL_PACKAGE\n";
	    system(
		"tar xzf ${UML_INSTALL_DIR}/$UML_KERNEL_PACKAGE -C ${UML_INSTALL_DIR}"
	    );

	    system("rm ${UML_INSTALL_DIR}/$UML_KERNEL_PACKAGE");
	}
    }
    # where to store projects?
    if ($SYSTEM_WIDE) {
        $response =
	  $PREV_CONFIG
          ? $PROJECT_PATH
          : "$SYSTEM_WIDE_PREFIX/$GLOBAL_USER_PROJECT_DIR";
    }
    else {
        $response = $PREV_CONFIG ? $PROJECT_PATH : $SINGLE_USER_PROJECT_DIR;
    }
    unless ($opt{n}) {
	print "\n";
	print "Where would you like to store the projects?\n";
	
	print "[ " . $response . " ]  : ";
	
	$answer = <STDIN>;
	while ( $answer =~ /\/$/ ) { $answer =~ s/\/$//; }
	chomp $answer;
    }
    
    if ($answer && !$opt{n}) {
        $PROJECT_INSTALL_DIR = $answer;
    }
    else {
        $PROJECT_INSTALL_DIR = $response;
    }
    
    # We want to create the project directory, but not for system
    # installations.
    unless ($SYSTEM_WIDE) {
        makeDir($PROJECT_INSTALL_DIR);
    }
    
    # where to store files?
    
    if ($SYSTEM_WIDE) {
        $response =
	  $PREV_CONFIG
          ? $FILES_PATH
          : "$SYSTEM_WIDE_PREFIX/$GLOBAL_USER_FILES_DIR";
    }
    else {
        $response = $PREV_CONFIG ? $FILES_PATH : $SINGLE_USER_FILES_DIR;
    }
    
    
    unless ($opt{n}) {
	print "\n";
	print
	  "Where would you like to store files that will be copied into the vm at build time?\n";
	
	if ($SYSTEM_WIDE) {
	    print "[ $response/\$USER ]  : ";
	}
	else {
	    print "[ " . $response . " ]  : ";
	}

	$answer = <STDIN>;
	chomp $answer;
	while ( $answer =~ /\/$/ ) { $answer =~ s/\/$//; }
    }
    
    if ($answer && !$opt{n}) {
        $FILES_INSTALL_DIR = $answer;
    }
    else {
        $FILES_INSTALL_DIR = $response;
    }
    makeDir($FILES_INSTALL_DIR);
    
    # where to store the templates?
    
    if ($SYSTEM_WIDE) {
        $response =
	  $PREV_CONFIG
          ? $TEMPLATEDIR
          : "$SYSTEM_WIDE_PREFIX/$GLOBAL_USER_TEMPLATE_DIR";
    }
    else {
        $response = $PREV_CONFIG ? $TEMPLATEDIR : $SINGLE_USER_TEMPLATE_DIR;
    }
    
    unless ($opt{n}) {
	print "\n";
	print "Where would you like to store the templates?\n";
	
	print "[ " . $response . " ]  : ";
	
	$answer = <STDIN>;
	chomp $answer;
	while ( $answer =~ /\/$/ ) { $answer =~ s/\/$//; }
    }
    
    if ($answer && !$opt{n}) {
        $TEMPLATE_INSTALL_DIR = $answer;
    }
    else {
        $TEMPLATE_INSTALL_DIR = $response;
    }
    makeDir($TEMPLATE_INSTALL_DIR);
    
    # create the plugins directory
#    if ($SYSTEM_WIDE) {
#      makeDir($DEFAULTS{PLUGIN_LOCATIONS}[1]);
#    }
    
    
    
    if ($SYSTEM_WIDE) {
        $W_CONFIG_FILE = $DEFAULT_FILE;
    }
    else {
        $W_CONFIG_FILE = "$ENV{'HOME'}/$CONFIG_FILE_NAME";
    }
    
    
    # write the configuration

    my $XEN_KERNEL_VERSION;
    my $XEN_KERNEL;
    my $XEN_MODULES;
    my $XEN_RAMDISK;
    out("\nDetecting Xen presence and kernel version...");
    if ( `xm info` ){
	$XEN_KERNEL_VERSION = assumeXenKernelVersion();
	out("Xen found in kernel $XEN_KERNEL_VERSION\n");
	$XEN_KERNEL = "/boot/vmlinuz-$XEN_KERNEL_VERSION";
	$XEN_MODULES = "/lib/modules/$XEN_KERNEL_VERSION";
	$XEN_RAMDISK = getXenInitrd($XEN_KERNEL_VERSION);
	out("The following Xen kernel, modules and (possibly) initrd was set as default:\n");
	out("xen_kernel $XEN_KERNEL\n");
	out("xen_modules $XEN_MODULES\n");
	out("xen_ramdisk $XEN_RAMDISK\n");
	out("If you are unhappy about these settings, please edit $W_CONFIG_FILE after the installation is complete\n");
	out("Press ENTER to continue\n");
	<STDIN>;
	
    } else {
	out("Xen was not found, is xend running?\n");
    }

    if ( $DISTRIBUTED_FRONT or $DISTRIBUTED_BACK ){
	# service host name
	$SERVICE_HOST = `hostname`;
	chomp $SERVICE_HOST;
	out("\n");
	out("For distributed management to work, every server is identified as a 'service_host'\n");
	out("The servive_host name should be either an IP or a resolveable name\n");
	out("The service_host name for this host will be '$SERVICE_HOST'\n");
	out("Please edit $W_CONFIG_FILE to change it\n");
	out("Press ENTER to continue\n");
	<STDIN>;
	
    }
    
    open( CONF, ">$W_CONFIG_FILE" )
      or die "Failed to open $W_CONFIG_FILE sorry....";

    print CONF "# MLN configuration file generated by the mln setup command\n\n";
#    out("adding: templates $TEMPLATE_INSTALL_DIR\n");
    print CONF "\n";    
    print CONF "# The location of the filesystem templates:\n";
    print CONF "# You can use environment variables in this path, but make sure\n";
    print CONF "# that the variables are there when you run he daemon\n";
    print CONF "templates $TEMPLATE_INSTALL_DIR\n";
    print CONF "\n";
#    out("adding: files $FILES_INSTALL_DIR \n");
    print CONF "# Files which are being copied into the VMs at build-time\n";
    print CONF "# must be placed in this directory\n";
    print CONF "files $FILES_INSTALL_DIR/\$USER \n";
    print CONF "\n";
#    out("adding: projects $PROJECT_INSTALL_DIR \n");
    print CONF "# This folder is going to contain projects and likely filesystem images.\n";
    print CONF "# Make sure there is sufficient space as some projects can become large.\n";
    print CONF "# It is advised that every user has his own project directory, but in\n";
    print CONF "# case of XEN, root will probarbly be the only one to use MLN\n";
    print CONF "projects $PROJECT_INSTALL_DIR \n";
    print CONF "\n";
#    out("adding: uml $UML_INSTALL_DIR \n");
    print CONF "# The location of the User-Mode Linux kernel to use\n";
     print "# " if ( $INSTALL_UML );
    print CONF "uml $UML_INSTALL_DIR \n";
    print CONF "\n";
#   out("adding: default_kernel $UML_INSTALL_DIR/$UML/linux \n");
    print CONF "# The default User-Mode Linux kernel binary\n";
     print "# " if ( $INSTALL_UML );
    print CONF "default_kernel $UML_INSTALL_DIR/$UML/linux \n";
    print CONF "\n";
#    out("adding: default_modules $UML_INSTALL_DIR/$UML \n");
    print CONF "# The modules beloning to the default User-Mode Linux kernel\n";
     print "# " if ( $INSTALL_UML );
    print CONF "default_modules $UML_INSTALL_DIR/$UML \n";
    print CONF "\n";
    
    print CONF "## STORAGE SETTINGS ##\n\n";
    print CONF "# Use this setting to define which default LVM volume group to use:\n";
    print CONF "# Example: lvm_vg mln-images\n";
    print CONF "# lvm_vg <volume-group>\n";
    print CONF "\n";
    
    print CONF "# The san_path option is used to tell MLN that a LVM volume group or\n";
    print CONF "# filesystem path is actually part of a shared storage which the other\n";
    print CONF "# servers use as well. It is a prerequesite for live migration.\n";
    print CONF "# Example: The volume group 'mln-images' is on a SAN: san_path mln-images\n";
    print CONF "# Example: The path /mln/nfssan points to a NFS mounted SAN: san_path /mln/nfssan\n";
    print CONF "# You can have multiple SANs. Use one line per SAN.\n";
    print CONF "# san_path <san1>\n";
    print CONF "# san_path <san2>\n";
    print CONF "\n";
    print CONF "## XEN SETTINGS ##\n\n";

    print CONF "# The xen_kernel <path> lets you point to the default Xen domU kernel to use\n";
    print CONF "# This is usually the same kernel you use on the dom0.\n";
    print CONF "# The kernels are usually placed in the /boot/ directory and begin\n";
    print CONF "# are called vmlinuz-<kernel_kersion>\n";
    print CONF "# Example: xen_kernel /boot/vmlinuz-2.6\n"; 

    if ( $XEN_KERNEL ){
	print CONF "xen_kernel $XEN_KERNEL\n";
	print CONF "xen_modules $XEN_MODULES\n";
    }
    print CONF "\n";
    print CONF "# The initrd (or ramdisk) is sometimes needed to boot the virtual machine.\n";
    print CONF "# Sometimes, it might also fail to boot it. So what should you do?\n";
    print CONF "# In practice, you have three choices:\n";
    print CONF "#  - Try with the initrd (default)\n";
    print CONF "#  - Try without the initrd (comment out the line below)\n";
    print CONF "#  - If all of the above fails, create a custom initrd that works and then but it in here\n";

    print CONF "# you can also point to a different ramdisk (and kernel) in the MLN\n";
    print CONF "# project file.\n\n";
    if ( $XEN_RAMDISK ){
	print CONF "xen_ramdisk $XEN_RAMDISK\n";
    } else {
	print CONF "# xen_ramdisk /boot/initrd.img-<kernel_version>\n";	
    }
    print CONF "\n";
    
    print CONF "## GENERAL VM SETTINGS ##\n\n";
    print CONF "\n";
    print CONF "# The default amount of memory for each VM\n";
    print CONF "default_memory 64M\n";
    print CONF "\n";
    print CONF "# The default filesystem template to use\n";
    print CONF "# Example: default_template etch.ext3\n";
    print CONF "# default_template <template-name> \n";

    print CONF "\n";
    print CONF "# Start all virtual machines in a screen session or xterm window\n";
    print CONF "# Example: default_term aterm -bg black -fg green -fn 9x15\n";

    if ( $SYSTEM_WIDE or $DISTRIBUTED_FRONT or $DISTRIBUTED_BACK ) {
	print CONF "default_term screen\n";
	print CONF "# default_term xterm\n";
    } else {
	print CONF "# default_term screen\n";
	print CONF "default_term xterm\n";	
    }
    print CONF "\n";
    print CONF "# The default filesystem size of a virtual machine";
    print CONF "default_size 250M\n";    
    
    print CONF "\n";
    print CONF "## DISTRIBUTED MANAGEMENT OPTIONS ##\n";
    print CONF "\n";
    print CONF "# The 'service_host' is the name to identify the server as a location\n";
    print CONF "# for a virtual machine. The service_host value can either be a IP address or a resolv-able\n";
    print CONF "# name for the host\n";
    if ( $SYSTEM_WIDE or $DISTRIBUTED_FRONT or $DISTRIBUTED_BACK ){
        print CONF "service_host $SERVICE_HOST\n";
    } else {
	print CONF "# service_host $SERVICE_HOST\n";	
    }

    print CONF "\n";
    print CONF "# The address to listen on. Default is to listen on all addresses\n";
    print CONF "# daemon_listen_address x.x.x.x\n";
    
    
    print CONF "\n";
    print CONF "# If you wish to store the MLN daemons projects somewhere else than root,\n";
    print CONF "# or the current user starting the daemon, then you can define the path\n";
    print CONF "# using the daemon_projects option:\n";
    print CONF "# Example: daemon_projects /opt/large-disk\n";
      
    
    print CONF "\n";
    print CONF "# The IP address of hosts that are allowed to manage this MLN daemon\n";
    print CONF "# BE VERY AWARE THAT THIS IS VERY BETA-QUALITY SOFTWARE!!\n";
    print CONF "# USE WITH CAUTION!\n";
    
    if ( $DISTRIBUTED_BACK ){
	print CONF "# daemon_allow x.x.x.x\n";

    } else {
	print CONF "# daemon_allow x.x.x.x\n";
    }

    print CONF "\n";

    print CONF "# If this is a machine that will manage other servers,\n";
    print CONF "# you will need to add one line for each server backend\n";
    print CONF "# The groups can be used to print status information for a subset\n";
    print CONF "# of the servers.\n";
    print CONF "# format: daemon_status_query <hostname> [group[,group]]\n";
    print CONF "# Example: daemon_status_query backend1.example.org Xen,HVM,development\n";

    print CONF "\n";
    print CONF "# Use this option if you want the server to check with the manager host\n";
    print CONF "# if the project has been updated. This can be useful in case of server downtime\n";
    print CONF "# and if some of the hosts have moved to another server because they are on a SAN.\n";
    print CONF "# If the server starts projects on its own, and not from\n";
    print CONF "# the Manager, then the manager should run the mln daemon as well in order to answer\n";
    print CONF "# version requests\n";
    print CONF "# Default is 0 (off)\n";
    print CONF "# allways_check_project_version 1\n";
    

#    foreach my $key ( keys %DEFAULTS ) {
#        if ( not $key =~ /(KERNEL|KERNEL_VERSION)/ ) {
#            print CONF "$key $DEFAULTS{$key}\n";
#        }
#    }
    close(CONF);
    out("Configuration written to $W_CONFIG_FILE\n\n");

    if ( $DISTRIBUTED_BACK or $DISTRIBUTED_FRONT ){
	out("Do you want to have a MLN daemon start/stop script in /etc/init.d/mlnd?\n[Y]/n: ");
	$answer = <STDIN>;
	chomp $answer;
	$answer = "Y" unless $answer;
	while ( not $answer =~ /Y|y|n|N/ ) { 
	    out("[Y]/n");
	    $answer = <STDIN>;
	    chomp $answer;
	    $answer = "Y" unless $answer;	
	}
	if ( $answer =~ /Y|n/){
	    writeMLNdaemonScript();	    
	    out("Note, the MLN daemon is not set to start automatically at boot.\nPress ENTER to continue.");
	    <STDIN>;
	}
    }

    if ( $DISTRIBUTED_BACK or $DISTRIBUTED_FRONT or $SYSTEM_WIDE ){
	out("Do you want to have the mln script in /usr/local/bin?");
	$answer = <STDIN>;
	chomp $answer;
	$answer = "Y" unless $answer;
	while ( not $answer =~ /Y|y|n|N/ ) { 
	    out("[Y]/n");
	    $answer = <STDIN>;
	    chomp $answer;
	    $answer = "Y" unless $answer;	
	}
	if ( $answer =~ /Y|y/){
	    system("cp $0 /usr/local/bin");
	} else {
	    out("You will have to make sure mln is somewhere in your PATH yourself.\nPress ENTER to continue.");
	    <STDIN>;
	}
    }

#    my $DEFAULT_PLUGIN_DIR = "/etc/mln/plugins";
#    my DEFAULT_PERSONAL_PLUGIN_DIR = ".mln_plugins";

    my $plugins_path;
    if ($SYSTEM_WIDE){
	$plugins_path = $DEFAULT_PLUGIN_DIR;
    } else {
	$plugins_path = $ENV{'HOME'} . "/". $DEFAULT_PERSONAL_PLUGIN_DIR;
    }
    
    print "Creating plugin directory: $plugins_path\n";
    makeDir($plugins_path);
    if ( stat("plugins") ){
	system("cp -v plugins/* $plugins_path");
    } else {
	print "could not fint the plugin directory";
    }
    
    # Hmmm... if we don't re-parse the config file we just created, then we
    # can't perform snazzy in-line setup because (being in setup mode) it isn't
    # parsed in initializeConfig. So we'll just do it here again. Maybe in-line
    # setup isn't relevant (due to other manual setup tasks and building), in
    # which case we could just dump this section and remove the call to
    # setupMLN from initializeConfig.
    #
    # Right now this is duplicated code, we should find a better way.

    if ( stat($DEFAULT_FILE) ) {
        parseConfig($DEFAULT_FILE);
    }
    if ( stat("$ENV{'HOME'}/$CONFIG_FILE_NAME") ) {
        parseConfig("$ENV{'HOME'}/$CONFIG_FILE_NAME");
    }

    # If there are no templates, we want to download one.
    # Right now, this doesn't actually download the *default* template,
    # it simply calls the downloadTemplates subroutine.
    # This should be changed to somehow tell downloadTemplates that it
    # just wants the default. (?)
    if ( !stat("$TEMPLATEDIR/$TEMPLATE_LIST_FILE") ) {
        unless ($opt{n}) {
          print "You currently have no templates installed.\n";
          print
"At least the Default debian template needs to be installed for MLN to work.\n Would you like the Default template
to be downloaded and installed automatically?\n";
          print "[Y]/n: ";
          $answer = <STDIN>;
          chomp $answer;
        }

        if ( ( not $answer ) or ( $answer =~ /Y|y|yes/ ) or $opt{n} ) {
            if ($template_mirror) {
                downloadTemplates( default, $template_mirror );
            }
            else {
                downloadTemplates(default);
            }
        }
        else {
            print
"WARNING: Not downloading template: Make sure you download and register it manually later\n";
        }
    }
    else {
        print "It appears you already have one or more templates installed.\n";
        print "To add more later, you can run \"mln download_templates\"\n";
        if ($opt{n}) {
          print "Press Enter to continue.\n";
          <STDIN>;
        }
    }

    out("MLN setup complete.\n")

}

sub expandEnvirVariable {

    my @folders = split /\//, $_[0];

    my $each;
    my $string;    # = "/";
    foreach $each (@folders) {

        #	print "checking $each\n";
        if ( $each and $each =~ /\$([^\/]+)/ ) {

#            	    print "found variable $1\n";
            verbose("found variable $each\n");
	    if ( $ENV{$1} ){
		$each = $ENV{$1};
	    } elsif ( $_ eq "USER" ){
		my $user = detectUser();
		out("No USER in environment, using $user\n");
		$each = $user;
	    } else {
		out("Warning: variable $1 not in environment!\n");
	    }
        }

        if ($each) {
            $string .= "/" . $each;
        }
    }
    return $string;
}

sub detectUser {
    my $uid = `echo \$UID`;
    chomp $uid;
#    print "User ID = '$uid'\n";
    my $username = `grep :x:$uid: /etc/passwd`;
    $username =~ s/^([^:]*):.*/$1/g;
#    print "username is $1\n";
    return $1;
}

# This method parses the .mln configuration file of the user
sub parseConfig {
    my @line;
    my $l;
    my $openok = false;
    $openok = open( CONF, $_[0] ) or die "Failed to open config file $_[0] sorry....";
    if ($openok) {
        while ( $l = <CONF> ) {
            @line = split /\s+/, $l;

            if ( @line[0] =~ /files/ ) {
                $FILES_PATH = expandEnvirVariable( $line[1] );
            }
            elsif ( @line[0] =~ /templates/ ) {
                $TEMPLATEDIR = expandEnvirVariable( $line[1] );
            }
            elsif ( @line[0] =~ /projects/ ) {
                $PROJECT_PATH = expandEnvirVariable( $line[1] );
            }
            elsif ( @line[0] =~ /^daemon_max_memory$/ ) {
		if ( $line[1] =~ /(\d+)(M(|B)|G(|B))/ ){
		    $DAEMON_MAX_MEMORY = $1;
		    if ( $2 =~ /G/ ){
			$DAEMON_MAX_MEMORY *= 1024;
		    }
		}
            }
            elsif ( @line[0] =~ /uml/ ) {
                $UML_PATH = expandEnvirVariable( $line[1] );
            }
	    elsif ( $line[0] =~ /san_path/ ) {
                $SAN_PATH{$line[1]} = 1;
            }
	    elsif ( $line[0] =~ /default_vm/ ) {
                $DEFAULTS{VM} = $line[1];
            }
	    elsif ( $line[0] =~ /lock_dir/ ) {
                $DEFAULTS{LOCK_DIR} = $line[1];
            }
            elsif ( @line[0] =~ /daemon_status_query/ ) {
		push(@DAEMON_STATUS_QUERY_HOSTS,$line[1]);
		if ( $line[2] ) {
		    $DAEMON_GROUP_INDEX{$line[1]} = $line[2];
		    my @gr = split /,/,$line[2];
		    my $group;
		    foreach $group (@gr){
			push(@{$DAEMON_GROUPS{$group}},$line[1]);
		    }
		}
            }
            elsif ( @line[0] =~ /default_kernel/ ) {
                $DEFAULTS{KERNEL} = expandEnvirVariable( $line[1] );
                chomp( $DEFAULTS{KERNEL} );
                if ( stat( $DEFAULTS{KERNEL} ) ) {
                    $DEFAULTS{KERNEL_VERSION} = `$DEFAULTS{KERNEL} --version`;
                    chomp $DEFAULTS{KERNEL_VERSION};
                }
                else {

     #		      print STDERR "Warning: UML kernel $DEFAULTS{KERNEL} not found!\n";
                }
            }
            elsif ( @line[0] =~ /default_modules/ ) {
                $DEFAULTS{MODULE_PATH} = expandEnvirVariable( $line[1] );
                chomp( $DEFAULTS{MODULE_PATH} );
                if ( not $DEFAULTS{MODULE_PATH} =~ /\/$/ ) {
                    $DEFAULTS{MODULE_PATH} .= "/";
                }
            }
            elsif ( @line[0] =~ /xen_kernel/ ) {
                $DEFAULTS{XEN_KERNEL} = expandEnvirVariable( $line[1] );
            }
            elsif ( @line[0] =~ /xen_ramdisk/ ) {
                $DEFAULTS{XEN_RAMDISK} = expandEnvirVariable( $line[1] );
            }
            elsif ( @line[0] =~ /service_host/ ) {
		$SERVICE_HOST = $line[1];
#		print "setting service host to: $SERVICE_HOST\n";
            }
            elsif ( @line[0] =~ /xen_modules/ ) {
                $DEFAULTS{XEN_MODULES} = expandEnvirVariable( $line[1] );
            }
            elsif ( @line[0] =~ /lvm_vg/ ) {
		if ( $line[1] =~ /\/dev\/(\S+)/ ){
		    $line[1] = $1;
		}
		$DEFAULTS{MLN_VG} = $line[1];
            }  
	    elsif ( @line[0] =~ /daemon_listen_address/ ) {
		$DEFAULTS{LISTEN_ADDRESS} = $line[1];
            }
            elsif ( @line[0] =~ /xen_bridge/ ) {
		$DEFAULTS{XEN_BRIDGE} = $line[1];
            }
            elsif ( @line[0] =~ /default_template/ ) {
                $DEFAULTS{TEMPLATE} = $line[1];

            }
            elsif ( @line[0] =~ /screen_command/ ) {
                $DEFAULTS{SCREEN_COMMAND} = getRestAsString( 1, \@line );

            }
            elsif ( @line[0] =~ /^default_term$/ ) {
                $DEFAULTS{TERM} = getRestAsString( 1, \@line );

            }
            elsif ( @line[0] =~ /default_size/ ) {
                $DEFAULTS{FILESYSTEM_SIZE} = $line[1];

            }
            elsif ( @line[0] =~ /default_memory/ ) {
                $DEFAULTS{MEMORY} = $line[1];

            }
            elsif ( @line[0] =~ /default_term_command/ ) {
                $DEFAULTS{TERM_COMMAND} = getRestAsString( 1, \@line );

            }
            elsif ( @line[0] =~ /default_color/ ) {
                $DEFAULTS{color} = $line[1];

            }
            elsif ( @line[0] =~ /default_mac_base/ ) {
                $DEFAULTS{MAC_BASE} = $line[1];

            }
            elsif ( @line[0] =~ /default_family/ ) {
                $DEFAULTS{FAMILY} = $line[1];
            }
            elsif ( @line[0] =~ /db_name/ ) {
                $DEFAULTS{db_name} = $line[1];
            }
	    elsif ( @line[0] =~ /db_user/ ) {
                $DEFAULTS{db_user} = $line[1];
            }
            elsif ( @line[0] =~ /db_password/ ) {
                $DEFAULTS{db_password} = $line[1];
            }

            elsif ( @line[0] =~ /batch_size/ ) {
                $BATCH_SIZE = $line[1];
            }
            elsif ( @line[0] =~ /^slirp$/ ) {
                $DEFAULTS{SLIRP} = $line[1];
            } elsif ( @line[0] =~ /^plugin(|s)_dir$/ ){
#		print "found extra plugin: $line[1]\n";
		push(@{$DEFAULTS{"PLUGIN_LOCATIONS"}},expandEnvirVariable( $line[1] ));	    
	    }
            elsif ( @line[0] =~ /template_file_site/ ) {
                $TEMPLATE_FILE_SITE = getRestAsString( 1, \@line );
                chomp $TEMPLATE_FILE_SITE;
                chop $TEMPLATE_FILE_SITE;
            }
	    elsif ( @line[0] =~ /daemon_allow/ ) {
		debug("parseConfig: adding $line[1] to authorized list\n");
		push(@ALLOWED_DAEMONS,$line[1]);
	    }
	    elsif ( @line[0] =~ /daemon_projects/ ) {
		debug("parseConfig: adding $line[1] as daemon projects\n");
                $DEFAULTS{DAEMON_PROJECTS} = $line[1];
	    }
	    elsif ( @line[0] =~ /lvm_execute_server/ ) {
		debug("parseConfig: using $line[2] as lvm execution server for path $line[1]\n");
                $LVM_EXECUTE_SERVER{$line[1]} = $line[2];
	    }
	    elsif ( @line[0] =~ /always_check_project_version/ ) {
		debug("parseConfig: adding $line[1] as daemon projects\n");
                $DEFAULTS{CHECK_PROJECT_VERSION} = $line[1];
	    }	    
            elsif ( @line[0] =~ /template_file_mirror/ ) {
                $TEMPLATE_FILE_MIRROR = getRestAsString( 1, \@line );
                chomp $TEMPLATE_FILE_MIRROR;
                chop $TEMPLATE_FILE_MIRROR;
            }
	    elsif ( $l =~ /^notification\.(\S+)\.command\s+(.*)\n/ ) {
#		print "setting notification: $1 to " . $2 . "\n";
		$NOTIFICATION{$1} = $2;
		
	    }
        }
    }

}

sub writeConfig {
    out("---> Config for $ENV{'USER'} \n");
    out("mln version $VERSION\n");
    out("Template directory is: $TEMPLATEDIR\n");
    out("Files directory is:    $FILES_PATH\n");
    out("Projects directory is: $PROJECT_PATH\n");
    out("UML directory is: $UML_PATH\n");
    out(
"User-Mode Linux kernel: $DEFAULTS{KERNEL} ($DEFAULTS{KERNEL_VERSION})\n"
    );
    out(
"Kernel modules are located: $DEFAULTS{MODULE_PATH}$DEFAULTS{KERNEL_VERSION}\n"
    );
    if ( $DEFAULTS{XEN_KERNEL} ) {
	out("Xen kernel: $DEFAULTS{XEN_KERNEL}\n");
    }
    out("---> Other default variables:\n");
    my $each;
    my $key;

    foreach $each ( keys %DEFAULTS ) {
        if ( not $each =~ /(KERNEL|KERNEL_VERSION)/ ) {
            out("$each $DEFAULTS{$each}\n");
        }
    }
    if ( %PLUGIN_LIST ){
	out("---> Plugins:\n");
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    my $subcall = $plugin . "_version"; 
	    &$subcall if defined(&$subcall);
	}
    }
}

sub startProjectHandler {
    my $opt_string = 's:p:h:t:a';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    usage() and die unless $opt{p} or $opt{a};

    my $project = $opt{p};
    my $host    = $opt{h};

    #    my $pwd = `pwd`;
    my $sleep = $opt{s};
    my $type  = $opt{t};
    my @projects = getProjects();
    if ( not $project and $opt{a} ){
	foreach $project (getProjects()){
	    $project =~ s/\/.*\///g ;
	    print "Starting project $project\n"; 
	    if ( updateProjectVersion($project) != 0 ){
		startProject($project,$host,$type,$sleep);
	    } else {
		out("Failed to verify project version. Project will not be started\n");
	    }
	}
    } else {
	if ( updateProjectVersion($project) != 0 ){
	    startProject($project,$host,$type,$sleep);
	} else {
	    out("Failed to verify project version. Project will not be started\n");
	}
    }
}

sub startProject {


    my $project = "$PROJECT_PATH/$_[0]";

    my $host    = $_[1];

    #    my $pwd = `pwd`;
    my $sleep = $_[3];
    my $type  = $_[2];
    my $local = $_[4];
    my $pwd   = $ENV{'PWD'};

    if ( $host and stat($project) ) {


	$DATA_ROOT = buildDataTree("$project/$_[0].mln");
	my $service_host = getScalar("/host/$host/service_host");

	if ($SERVICE_HOST and $service_host and $service_host ne $SERVICE_HOST ) {
	    my $ticket = remoteStartClient("start",$service_host,"",$_[0],$host);
	    push(@PENDING_TICKETS,$ticket);
	    collectTickets(2);
	} else { 
	    
	    my $start_script =
	      `find $project -type f -iname "start_*_${host}.sh" -printf "%p"`;
	    chomp $start_script;
	    
	    if ( stat("$start_script") ) {
		chdir("$project");
		
		system("$start_script $type");
		chdir("$pwd");
	    }
	    else {
		die
		  "Failed to find start script for $host in $project. Is is spelled correctly?\n";
	    }
	}
    }
    elsif ( stat($project) ) {

	$DATA_ROOT = buildDataTree("$project/$_[0].mln");
#	$DATA_ROOT = buildDataTree("$project/$opt{p}.mln");
	my $return = system("./beforeProjectStart.sh") if stat("beforeProjectStart.sh");
	if ( $return != 0 ) { 
	    warn("script beforeProjectStart.sh returned $return, not continuing unless 0\n");
	    chdir("$pwd");
	    return;
	}
	my @hosts = `ls $project/start_*.sh 2>/dev/null | sort -n -k 2 -t '_'`;
        my $i;
	chdir("$project");
        # Lets boot all the switches first

        for ( $i = 0 ; $i <= $#hosts ; $i++ ) {
            chomp $hosts[$i];

            if ( $hosts[$i] ) {
                if ( not $hosts[$i] =~ /.*_\d+_.*.sh$/ ) {
#		    print "Calling '$hosts[$i] $type' at $ENV{'PWD'}\n";
		    my $switch = $hosts[$i];
		    $switch =~ s/^.*_(\S+)\.sh/$1/;
		    my $sh = getScalar("/switch/$switch/service_host");
		    if ( ( $sh and $sh eq $SERVICE_HOST) or not $sh ){
			system("$hosts[$i] $type");
		    }
                }
            }

        }
	$return = system("./beforeHostsStart.sh") if stat("beforeHostsStart.sh");
	if ( $return != 0 ) { 
	    warn("script beforeHostsStart.sh returned $return, not continuing unless 0\n");
	    chdir("$pwd");
	    return;
	}
        # now we take care of the hosts
        for ( $i = 0 ; $i <= $#hosts ; $i++ ) {
            chomp $hosts[$i];
            if ( $hosts[$i] ) {
#		print "$hosts[$i]\n";
                #		print ("starting $hosts[$i] $type '$1' '$#hosts'\n");

                if ( $hosts[$i] =~ /.*_\d+_.*.sh$/ ) {
#		print "Calling '$hosts[$i] $type' at" . `pwd` ."\n";
		    my $host = $hosts[$i];
		    $host =~ s/^.*_(\S+)\.sh/$1/;
		    my $sh = getScalar("/host/$host/service_host");
		    if ( ( $sh and $sh eq $SERVICE_HOST) or not $sh ){

			system("$hosts[$i] $type");
			sleep $sleep if $sleep;
		    }
                }
            }
            #	    print "$hosts[$i]\n";
        }
	if ( not $local ){
	    doRemoteStarts($_[0],"start");
	}
	$return = system("./afterHostsStart.sh") if stat("afterHostsStart.sh");
	if ( $return != 0 ) { 
	    warn("script afterHostsStart.sh returned $return, not continuing unless 0\n");
	    chdir("$pwd");
	    return;
	}
	$return = system("./afterProjectStart.sh") if stat("afterProjectStart.sh");
	if ( $return != 0 ) { 
	    warn("script afterProjectStart.sh returned $return, not continuing unless 0\n");
	    chdir("$pwd");
	    return;
	}
	chdir("$pwd");
	if ( not $local ){
	    collectTickets(3);
	}
    }
    
    else {
        die "Failed to find project called $project\n";
    }

}

sub cleanUpProject {

    # Command line parsing:
    my $opt_string = 'fp:c';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    ( usage() and print "ERROR: you need to supply a project name" ) and die
      unless $opt{p};

    my $project          = $opt{p};
    my $check_filesystem = $opt{c};

#    $CONFIGFILE = "$PROJECT_PATH/$project/${project}.mln";
    $DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/${project}.mln");
#    parse_mln_config_file($CONFIGFILE);

#    buildGlobalConfig();

   # Just to be sure, I'll check if the host is really down, before we thrash it
    if ( checkIfAnyAreUp() == 1 ) {
        out(
"DANGER: A host in this project is still up! You probarbly want to shut the project dow first.\n",
            "red"
        );
        exit 1;
    }

    my $mln_command;

    my $each;

    # clean up the network sockets:

    out("Removing uml_switch sockets\n");
    foreach $each ( getBlockKeys("/switch") ) {
        if ( stat("$PROJECT_PATH/$project/network/$each") ) {
            system("$shell{'RM'} -v $PROJECT_PATH/$project/network/*");
        }
    }

    # clean up the host sockets:

    out("Removing host sockets\n");
    foreach $each ( getHosts() ) {
        if ( stat("$PROJECT_PATH/$project/uml_dir/$each/$each") ) {
            system(
                "$shell{'RM'} -rv $PROJECT_PATH/$project/uml_dir/$each/$each");
        }
        if ( stat("$PROJECT_PATH/$project/uml_dir/$each//$each") ) {
            system(
                "$shell{'RM'} -rv $PROJECT_PATH/$project/uml_dir/$each//$each");
        }

    }

    if ($check_filesystem) {

        checkCowFilesystems();

        if ( not stat("$USER_MODE_TEMP_DIR") ) {
            mkdir("$USER_MODE_TEMP_DIR")
              or die "Failed to create $USER_MODE_TEMP_DIR. I'm dying.\n";
        }
        $USER_MODE_TEMP_DIR = $USER_MODE_TEMP_DIR . "/" . int( rand(1000) );

        prepareForUserModeBuild();

        $USER_MODE_REC = 1;
        checkForUserModeCopy();

        my $hostlist;
        my $each;
        my $cows_served;

        # add all the hosts and the first batch to the first hostlist:

        # first, all the regular hosts, but only the first time
        if ( $BATCH_NUMBER = 1 ) {
            foreach $each ( getHosts() ) {

                if ( not getScalar("/hostname/$each/cow_filesystem" )
                    and getScalar("/hostname/$each/type" ) eq "host" )
                {

                    system("$shell{'FSCK'} -f -y $IMAGEDIR/$each");

                }
            }
        }

        # and now the first batch, if any
        my @batch_hosts = getBatchHosts(1);
        my $ubd_devices;

# Check if we have any cow-based systems. in that case we will have to start a VM
        if ( $#batch_hosts > 0 ) {

            foreach $each (@batch_hosts) {

		# print "adding $each to hostlist\n";
                $ubd_devices .= "ubd"
                  . getUbdDevice( $BATCH_NUMBER, $each )
                  . "=$IMAGEDIR/$each,$IMAGEDIR/"
                  . getScalar("/hostname/$each/cow_filesystem") . " ";
                $hostlist .= $each . ":";
                $cows_served++;
            }

            my $conf = $CONFIGFILE;
            $conf =~ s/^.*\///g;
            verbose("conf: $conf\n");

            my $fs = getLatestTemplate($USER_MODE_COPY_FS);

            my $cowfile = "$USER_MODE_TEMP_DIR/debian.cow";
            system( $shell{'MKCOW'} . " $cowfile $TEMPLATEDIR/$fs" );

            # this command is run inside the virtual machine

            $mln_command =
              "clean_filesystems -f /tmp/mln/$conf -h $hostlist -b 1 ";

            print "mln_command: $mln_command\n";

            my $command =
"$shell{'LINUX'} mem=32M ubd0=$cowfile,$TEMPLATEDIR/$fs $ubd_devices project=$PROJECT_PATH files=$FILES_PATH mln=$USER_MODE_TEMP_DIR mln_command=\\\"$mln_command\\\"";
            out("---> RUNNING BATCH 1 ($BATCH_COUNTER) \n");
            print "Command: $command\n";
            system("$command");

            if ( $BATCH_COUNTER > 1 ) {
                my $i;
                for ( $i = 2 ; $i <= $BATCH_COUNTER ; $i++ ) {
                    @batch_hosts = getBatchHosts($i);
                    if ( $#batch_hosts > 0 ) {
                        out("---> RUNNING BATCH $i ($BATCH_COUNTER) \n");

                        $ubd_devices = "";
                        $hostlist    = "";

                        foreach $each (@batch_hosts) {

                            #	    print "adding $each to hostlist\n";
                            $ubd_devices .= "ubd"
                              . getUbdDevice( $i, $each )
                              . "=$IMAGEDIR/$each,$IMAGEDIR/"
                              . getScalar("/hostname/$each/cow_filesystem") . " ";
                            $hostlist .= $each . ":";
                            $cows_served++;
                        }

                        $mln_command =
"clean_filesystems -f /tmp/mln/$conf -h $hostlist -b $i ";

                        print "mln_command: $mln_command\n";

                        my $command =
"$shell{'LINUX'}  mem=32M ubd0=$cowfile,$TEMPLATEDIR/$fs $ubd_devices project=$PROJECT_PATH files=$FILES_PATH mln=$USER_MODE_TEMP_DIR mln_command=\\\"$mln_command\\\"";

                        system("$command");

                    }

                }
            }

        }
        cleanUpUserModeBuild();
    }

}

sub cleanCowFilesystems {

    out("Attempting to clean filesystems\n");
    my $opt_string = 'f:h:b:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    ( usage() and print "ERROR: cleanCowFilesystem config error\n" ) and die
      unless $opt{f};

    parse_mln_config_file( $opt{f} );

    buildGlobalConfig();
    $CONFIGURE_HOSTS_ONLY = 1;

    my $each;
    foreach $each ( split /:/, $opt{h} ) {

        system(
            "$shell{'FSCK'} -f -y /dev/ubd/" . getUbdDevice( $opt{b}, $each ) );

    }

}

sub stopProjectHandler {
     # Command line parsing:
    my $opt_string = 'Hs:p:h:aw:S';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    usage() and die unless $opt{p} or $opt{a};

    my $wait = $opt{w};
    my $project = $opt{p};
    my $host    = $opt{h};
    my $save = $opt{S};
    my $force = $opt{H};
    if ( $force and $save ){
	print "Error, you cannot destroy AND save the virtual machines at the same time\n"; 
	exit 1;
    }
    my $option = "force" if $force;
    $option = "save" if $save; 
#    print "option is $option\n";
    my $sleep   = $opt{s};
    if ( not $project and $opt{a} ){
	foreach $project (getProjects()){
	    $project =~ s/\/.*\///g ;
	    print "Stopping project $project\n"; 
	    stopProject($project,$host,$sleep,$option,$wait);
	}
    } else {
	stopProject($project,$host,$sleep,$option,$wait);
    }
    

}

sub stopProject {
    
    my $projectName = $_[0];
    my $project = "$PROJECT_PATH/$projectName";
    my $host = $_[1];
    my $sleep = $_[2];
    my $option = $_[3];
    my $wait = $_[4];   
    my $forceSuffix;
    my $pwd     = `pwd`;    
    my $uml_dir = "uml_dir";
    my $command;
    
    if ( $option eq "force" ) {
        $command = "halt";
        print "Brute force mode!\n";
    } elsif ( $option eq "save" ) {
	$command = "save";
    }
    
    if ( $wait =~ /\d+/ ) {
	out("Giving project $wait seconds to shutdown\n");
    }
    chomp $pwd;

    if ( $host and stat($project) ) {
	$DATA_ROOT = buildDataTree("$project/$projectName.mln");
	my $service_host = getScalar("/host/$host/service_host");

	if ($SERVICE_HOST and $service_host and ($service_host ne $SERVICE_HOST) ) {
	    my $ticket = remoteStartClient("stop",$service_host,"",$projectName,$host,$option,$wait);
	    push(@PENDING_TICKETS,$ticket);
	    collectTickets(2);
	} else { 
	    
	    chdir("$project");        
	    my $stop_script =
	      `find . -type f -iname "stop*${host}.sh" -printf "%p"`;
	    chomp $stop_script;
	    
	    system("./$stop_script $command");
	    chdir("$pwd");
	}
    }
    elsif ( stat($project) ) {
        my @hosts;
        chdir("$project");
	$DATA_ROOT = buildDataTree("$project/$projectName.mln");
        @hosts = `ls stop_*.sh 2>/dev/null | sort -nr -k 2 -t '_'`;
	my $return;
	my $script;
	out("Stopping $projectName\n");
        $script = "beforeProjectStop.sh";
	$return = system("./$script") if stat("$script");
	if ( $return != 0 ) { 
	    warn("script $script returned $return, not continuing unless 0\n");
	    chdir("$pwd");
	    return;
	}

        $script = "beforeHostsStop.sh";
	$return = system("./$script") if stat("$script");
	if ( $return != 0 ) { 
	    warn("script $script returned $return, not continuing unless 0\n");
	    chdir("$pwd");
	    return;
	}

	# all the hosts first
        my $i;
        for ( $i = 0 ; $i <= $#hosts ; $i++ ) {
            chomp $hosts[$i];

            if ( $hosts[$i] ) {
#		print "Calling '$hosts[$i] $command' at $ENV{'PWD'}\n";
		
                if ( $hosts[$i] =~ /.*_\d+_(.*).sh/  ) {
		    my $host = $1;
		    my $service_host = getScalar("/host/$host/service_host");
		    if ( ($SERVICE_HOST and $service_host and $service_host eq $SERVICE_HOST) or not $service_host ){
			system("./$hosts[$i] $command");
			sleep $sleep if $sleep;
		    }
                }
            }

        }

	if ( $wait ){
#	    print "engaging in wait\n";

	    my $sleep_interval = 3;
	    my $time_left;
	    my $infinity;
	    my $time_waited;
	    if ( $wait =~ /(\d+)/ ){
		$time_left = $1;
	    } else {
		$infinity = $wait;
	    }
	    # we need to check status on all the hosts
	    my @still_up;
	    for ( $i = 0 ; $i <= $#hosts ; $i++ ) {
		chomp $hosts[$i];
		$hosts[$i] =~ /stop_(\d+)_(.*)\.sh/;
		my $host = $2;
#		print "checking $host\n";
		push(@still_up,$hosts[$i])  if checkIfUp($host,$projectName);
	    }
	    while ( @still_up ){
	    # get list of hosts that are still up
	    
		if ( not $time_waited > $time_left or $infinity ) {
#		    print "waiting: ";
		    sleep $sleep_interval;
		    $time_waited += $sleep_interval;
		    @still_up = ();
		    for ( $i = 0 ; $i <= $#hosts ; $i++ ) {
			chomp $hosts[$i];
			$hosts[$i] =~ /stop_(\d+)_(.*)\.sh/;
			my $host = $2;
#			print "$host,";
			push(@still_up,$hosts[$i]) if checkIfUp($host,$project);
		    }
#		    print "\n";
		} else {
		    out("Time is up, killing remaining machines!\n");
		    foreach (@still_up){
			system("./$_ halt");
		    }
		    last;
		}
	    # if wait is digit AND we still have time:
	    # sleep
	    # elsif wait is digit AND we have no time:
	    # call force on the remaining hosts that are down
	    }
	}
#	print "doing remote commands with: $wait\n";
	doRemoteStarts($projectName,"stop",$option,$wait);
	$script = "afterHostsStop.sh";
	$return = system("./$script") if stat("$script");
	if ( $return != 0 ) { 
	    warn("script $script returned $return, not continuing unless 0\n");
	    chdir("$pwd");
	    return;
	}

	# all the switches last
	for ( $i = 0 ; $i <= $#hosts ; $i++ ) {
	    chomp $hosts[$i];
	    
	    if ( $hosts[$i] ) {
                if ( not $hosts[$i] =~ /.*_\d+_.*.sh$/ ) {
#		    print "Calling switch '$hosts[$i] $command' at $ENV{'PWD'}\n";		    
                    system("./$hosts[$i] $command");
                }
            }

        }
        $script = "afterProjectStop.sh";
	$return = system("./$script") if stat("$script");
	if ( $return != 0 ) { 
	    warn("script $script returned $return, not continuing unless 0\n");
	    chdir("$pwd");
	    return;
	}

	
	chdir("$pwd");
	if ( @PENDING_TICKETS ){
	    collectTickets(2);
	}
    }
    else {
        die "Faild to find project called $project\n";
    }

}

sub setupBridge {

    die "Only root can use this command\n" unless ( $ENV{'USER'} == 0 );

    my $opt_string = 'e:t:b:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    my $interface = "br0";
    my $tap       = "tap0";
    my $eth       = "eth0";

    $interface = $opt{b} if $opt{b};
    $tap       = $opt{t} if $opt{t};
    $eth       = $opt{e} if $opt{e};

    my $MY_ADDR    = getIP($eth);
    my $MY_NETMASK = getNETMASK($eth);
    my $MY_GATEWAY = `route -n | grep "^0.0.0.0" | awk '{print \$2}'`;
    chomp $MY_ADDR;
    chomp $MY_GATEWAY;

    print "gateway: $MY_GATEWAY\n";
    print "$eth addr: $MY_ADDR\n";

    $shell{'BRCTL'} = which('brctl');
    chomp $shell{'BRCTL'};

    die
"you need to have brctl installed (bridge-utils under debian) for this to work.\n"
      unless $shell{'BRCTL'};

    # Security measure, lets see if the bridge interface already is up:

    my $status = `$shell{'BRCTL'} show | grep $interface`;
    if ( $status =~ /$interface/ ) {
        out(
"Bridge interface: $interface is already up. I don't want to continue.\n",
            "red"
        );
        exit 1;
    }

    print "Trying: $shell{'TUNCTL'} -t $tap\n";
    system("$shell{'TUNCTL'} -t $tap 2> /dev/null");

    my $exit_value = $?;
    if ( $exit_value == 1 ) {
        print "Interface $tap already exists\n";
    }
    elsif ( $exit_value > 1 ) {
        print "Unknown exit value exit value: $exit_value\n";

        #	die "Failed to create tap device $tap\n" if ( $ret != 0 );
    }
    my $ret = system("$shell{'IFCONFIG'} $tap > /dev/null");
    die "Failed to create tap device $tap\n" if ( $ret != 0 );

    print "OK\n-------------------\n";

    print "Trying: $shell{'BRCTL'} addbr $interface\n";

    system("$shell{'BRCTL'} addbr $interface");

    my $status    = `$shell{'BRCTL'} show | grep $interface`;
    my $broadcast = getBROADCAST($eth);
    if ($broadcast) {

        $broadcast = "broadcast $broadcast ";

    }

    # $broadcast =~ s/\.\d+$/\.255/;

    if ( $status =~ /$interface/ ) {
        print "OK\n-------------------\n";

        system("$shell{'IFCONFIG'} $eth 0.0.0.0 promisc up");
        system("$shell{'IFCONFIG'} $tap 0.0.0.0 promisc up");

        #	print "broadcast: $broadcast\n";
        system(
"$shell{'IFCONFIG'} $interface $MY_ADDR $broadcast netmask $MY_NETMASK up"
        );
        system("$shell{'BRCTL'} stp $interface off");
        system("$shell{'BRCTL'} setfd $interface 1");
        system("$shell{'BRCTL'} sethello $interface 1");
        system("$shell{'BRCTL'} addif $interface $eth");
        system("$shell{'BRCTL'} addif $interface $tap");

        if ($MY_GATEWAY) {
            system("$shell{'ROUTE'} add default gw $MY_GATEWAY");
        }
        print
"bridge interface $interface set up and connected to $tap and $eth:\n";
        system("$shell{'BRCTL'} show $interface");

        print
"\nWARNING: If this host was configured using DHCP, then the dhcp client might reset what this script just did!\n";
    }
    else {

        # clean up if it should fail
        print "Failed to create the bridge interface called $interface\n";
        system("$shell{'TUNCTL'} -d $tap");
    }
}

sub getIP {

    my $l;
    open( IFCONFIG, "$shell{'IFCONFIG'} $_[0] |" )
      or die "failed to open pipe\n";
    while ( $l = <IFCONFIG> ) {

        if ( $l =~ /inet addr:(\d+\.\d+\.\d+\.\d+) / ) {
            close(IFCONFIG);
            return $1;
        }
    }
    close(IFCONFIG);
}

sub getNETMASK {

    my $l;

    #    print "trying $_[0]\n";
    open( IFCONFIG, "$shell{'IFCONFIG'} $_[0] |" )
      or die "failed to open pipe\n";
    while ( $l = <IFCONFIG> ) {

        #	print "$l";
        if (
            $l =~ /inet addr:(\d+\.\d+\.\d+\.\d+).* Mask:(\d+\.\d+\.\d+\.\d+)/ )
        {
            close(IFCONFIG);

            #	      print "matched this line: $l";
            #	      print "returning $2\n";
            return $2;
        }
    }
    close(IFCONFIG);

    #    print "no netmask found. Defaulting to 255.255.255.0\n";
}

sub getBROADCAST {

    my $l;
    open( IFCONFIG, "$shell{'IFCONFIG'} $_[0] |" )
      or die "failed to open pipe\n";
    while ( $l = <IFCONFIG> ) {

        if ( $l =~
            /inet addr:(\d+\.\d+\.\d+\.\d+).* Bcast:(\d+\.\d+\.\d+\.\d+) / )
        {
            close(IFCONFIG);
            return $2;
        }
    }
    close(IFCONFIG);
}

sub printSwitch {
    my $name = $_[0];
    print "-> Switch $name \n";
    my %SWITCH = getHash("/switch/$name");
    if ( $SWITCH{"tap"} ) {
        my $tap = $SWITCH{"tap"};
        print "Tap device $tap\n";
    }
    
    if ( $SWITCH{"sock"} ) {
        print "Socket: ", $SWITCH{"sock"}, "\n";

    }
    if ( $SWITCH{"bridge"} ) {
        print "Bridge: ", $SWITCH{"bridge"}, "\n";

    }
    if ( $SWITCH{"xen"} ) {
        print "Xen enabled\n";
    }
    if ( $SWITCH{"service_host"} ) {
        print "Service Host: ", $SWITCH{"service_host"}, "\n";

    }
}

sub disableBridge {

    # brctl delif br0 eth0
    # ifconfig br0 down
    # brctl delbr br0

    die "Only root can use this command\n" unless ( $ENV{'USER'} == 0 );

    my $opt_string = 'e:t:b:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    my $interface = "br0";
    my $tap       = "tap0";
    my $eth       = "eth0";

    $interface = $opt{b} if $opt{b};
    $tap       = $opt{t} if $opt{t};
    $eth       = $opt{e} if $opt{e};

    my $MY_ADDR    = getIP($interface);
    my $MY_GATEWAY = `route -n | grep "^0.0.0.0" | awk '{print \$2}'`;
    my $MY_NETMASK = getNETMASK($interface);
    chomp $MY_ADDR;
    chomp $MY_GATEWAY;
    my $broadcast = getBROADCAST($interface);
    if ($broadcast) {

        $broadcast = "broadcast $broadcast ";

    }

    # my $broadcast = $MY_ADDR;
    # $broadcast =~ s/\.\d+$/\.255/;

    print "gateway: $MY_GATEWAY\n";
    print "$interface addr: $MY_ADDR/$MY_NETMASK $broadcast\n";
    print
"MLN will try to reassign network address to the correct interface. The network may hang for a little while.\n";

    print "Reassigning $MY_ADDR/$MY_NETMASK address/netmask to $eth\n";
    system(
"$shell{'IFCONFIG'} $eth $MY_ADDR $broadcast netmask $MY_NETMASK up; $shell{'BRCTL'} delif $interface $eth; $shell{'ROUTE'} add default gw $MY_GATEWAY dev $eth"
    );

    #       exit 1;
    print "---------------------------------------------\n";
    print "Taking down the bridge: $interface\n";

    system("$shell{'BRCTL'} delif $interface $tap");
    system("$shell{'IFCONFIG'} $interface down");
    system("$shell{'BRCTL'} delbr $interface");

    print "---------------------------------------------\n";

    print "Setting default route to $MY_GATEWAY on interface $eth\n";

    #      system("$shell{'ROUTE'} add default gw $MY_GATEWAY");

    print "---------------------------------------------\n";

    #      print "Removing TAP device $tap\n";
    #      system("$shell{'IFCONFIG'} $tap down");
    #      system("$shell{'TUNCTL'} -d $tap");

}

sub printVersion {
    print "Version: $VERSION\n";
}

sub getProjects {
    my @projects =
      `$shell{'FIND'} $PROJECT_PATH -maxdepth 1 -mindepth 1 -type d`;
    my $i;

    for ( $i = 0 ; $i <= $#projects ; $i++ ) {
        chomp $projects[$i];
    }

    return @projects;

}

sub listProjects {
    my @projects = getProjects();
    my $i;
    for ( $i = 0 ; $i <= $#projects ; $i++ ) {
        print "$projects[$i]\n";
    }
}

sub removeHost {
#    print "Removehost called\n";
    my $host = $_[0];
    debug("Setting CURRENT HOSTNAME to $host\n");
    $CURRENT_HOSTNAME = $host;
    my $vm_is_removed;		    
#		    print "removing host: $host\n";
    if ( %PLUGIN_LIST ){
	
	my $plugin;
	my $sh = getScalar("/host/$host/service_host");
	if ( $sh eq $SERVICE_HOST or ( not $sh)){
	    foreach $plugin (keys %PLUGIN_LIST){
		
		my $subcall = $plugin . "_removeHost"; 
#			    print "calling $subcall\n";
#			    print("calling $subcall\n");
		if ( defined(&$subcall) and not $vm_is_removed ){
		    $vm_is_removed = &$subcall($host,$PROJECT);
		}
		
	    }
	}
    }
		    
    if ( not $vm_is_removed ){
	my $lvm = getScalar("/host/$host/lvm");
	my $filepath = getScalar("/host/$host/filepath");
	if ($lvm) {
	    my $vg = getScalar("/host/$host/lvm_vg");
	    $vg = $DEFAULTS{'MLN_VG'} if not $vg;
	    my $path = `which lvremove`;
#			print "path: $path\n";
#			print "$ENV{'PATH'}\n";
#			print("$shell{'LVREMOVE'} -f $vg/$host.$candidate");
	    system("$shell{'LVREMOVE'} -f --quiet /dev/$vg/$host.$PROJECT &>/dev/null");
	} elsif ( $filepath ) {
	    out("Removing filesystem: $filepath/$host.$PROJECT\n");
	    system("rm $filepath/$host.$PROJECT");
	} else {
	    out("Removing filesystem: $PROJECT_PATH/$PROJECT/images/$host\n");
#			    system("$shell{'RM'}
	}
    }


}

sub removeProject {
#    print "remove project\n";
    my @projects = getProjects();
    my $each;
    my $candidate = $_[0];
    my $force = $_[1];
#    print "force: $force\n";
#    print "removeProject called with $_[0]\n";
    if ( not $force ){
	my $opt_string = 'p:fdv';
	getopts( "$opt_string", \my %opt ) or usage() and exit;
	
	$DEBUG = $opt{d};
	$VERBOSE = $opt{v};
	$candidate = $opt{p};
	if ( not $candidate ){
	    print "usage: mln remove -p project [ -f ]\n";
	    exit 1;
	}
	$force = $opt{f};
	
	if ( not $force ){
	    print "\nAre you sure you want to remove $candidate? (y/N)\n";
	    my $answer = <STDIN>;
	    if ( not $answer =~ /^([yY]|yes)/ ) {
		exit;
	    }
	}
    } else {
	$candidate = $_[0];
	$force = 1;
    }
    my $temp;
    foreach $each (@projects) {
        if ( $each =~ /\/$candidate$/ ) {
	    $temp = $DATA_ROOT;
	    if ( stat("$each/$candidate" . ".mln")){
		$DATA_ROOT =  buildDataTree("$each/$candidate" . ".mln");
		$PROJECT = $candidate;

		my @servers = isDistributed();
		if ( @servers and not $force ) {
		    print "WARNING: This project is distributed.\nI will not remove this project unless the option -f is supplied\n";
		    exit;
		}
		# i need the list of servers too...
		if ( not $SPAWNED_REMOTELY ){
		    foreach (@servers){
#			print "contacting $_\n";
			
			my $ticket = distributedRemove($_,$candidate);
			if ( $ticket ){
			    my $t = new buildTicket;
			    $t->ticket($ticket);
			    $t->host($_);
			    $t->port(34001);
			    push(@PENDING_TICKETS,$t);
			}
		    }
		}
		out("Removing $each\n");
		my %hosts = getHash("/host");
#		print "got hosts\n";
		my $host;
		foreach $host (keys %hosts){
		    my $vm_is_removed;		    
		    $CURRENT_HOSTNAME = $host;
#		    print "removing host: $host\n";
		    if ( %PLUGIN_LIST ){

			my $plugin;
			my $sh = getScalar("/host/$host/service_host");
			if ( $sh eq $SERVICE_HOST or ( not $sh)){
			    foreach $plugin (keys %PLUGIN_LIST){
			    
				my $subcall = $plugin . "_removeHost"; 
#			    print "calling $subcall\n";
#			    print("calling $subcall\n");
				if ( defined(&$subcall) and not $vm_is_removed ){
				    $vm_is_removed = &$subcall($host,$candidate);
				}
				
			    }
			}
		    }
		    
		    if ( not $vm_is_removed ){
			my $lvm = getScalar("/host/$host/lvm");
			if ($lvm) {
			    my $vg = getScalar("/host/$host/lvm_vg");
			    $vg = $DEFAULTS{'MLN_VG'} if not $vg;
			    my $path = `which lvremove`;
#			print "path: $path\n";
#			print "$ENV{'PATH'}\n";
#			print("$shell{'LVREMOVE'} -f $vg/$host.$candidate");
			system("$shell{'LVREMOVE'} -f --quiet /dev/$vg/$host.$candidate &>/dev/null");
			}
		    }
		}
		setPersistent($candidate,'off',1);
		my %switches = getHash("/switch");
		my $switch;
		foreach $switch (keys %switches){
		    if ( %PLUGIN_LIST ){
			
			my $plugin;

			foreach $plugin (keys %PLUGIN_LIST){			    
			    my $subcall = $plugin . "_removeSwitch";
			    if ( defined(&$subcall) ){
				last if &$subcall($switch,$candidate);
			    }
			    
			}
		    }
		}
		if ( %PLUGIN_LIST ){
		    
		    my $plugin;
		    
		    foreach $plugin (keys %PLUGIN_LIST){			    
			my $subcall = $plugin . "_removeProject";
			if ( defined(&$subcall) ){
			    last if &$subcall($candidate,$DATA_ROOT);
			}
			
		    }
		}
		
	    } else {
		print "WARNING: project dir did not contain any config file\n";
	    }
            system("$shell{'RM'} -r $each");
	    $DATA_ROOT = $temp;
	    if ( not $SPAWNED_REMOTELY and @PENDING_TICKETS ){
		collectTickets(3);
	    }
            return;
        }
    }

    print "Failed to find project $candidate\n";

}

sub checkIfExists {
    return if ($CONFIGURE_HOSTS_ONLY);

    #      return if $ADD;
    my @projects = getProjects();
    my $each;
    my $candidate = $PROJECT;

    foreach $each (@projects) {
        if ( $each =~ /\/$candidate$/ ) {
            print "Old version of project found.\n";

            if ( not $REMOVE ) {
                print "\nWARNING\n";
                print "You allready have a project with that name\n";
                print "Are you sure you want to remove the old one?\n";
                print "(y/n)\n";
                my $answer = <STDIN>;
                if ( $answer =~ /^([yY]|yes)/ ) {
                    removeProject($PROJECT,1);
                    return;
                }
                else {
                    die "Exited\n";

                }
            }
            else {
#                print "removing old version of project\n";
                removeProject($PROJECT,1);
            }

        }
    }
}

sub getImageSize {
    
    # returns the size of an image in Kilobytes.
    
}

sub getImages {

    # I will check for the image directory in case it does not exist
    return unless stat($IMAGEDIR);
    return if ($CONFIGURE_HOSTS_ONLY);

    my @images = `$shell{'FIND'} $IMAGEDIR -type f -printf \"\%P\n\"`;
    my $i;

    #    print "@images";
    #    print "size: $#images\n";
    for ( $i = 0 ; $i <= $#images ; $i++ ) {
        chomp $images[$i];

        #	print "Checking $images[$i]\n";
        if ( $HOSTS{ $images[$i] } ) {

            #	      print "Updating $images[$i]\n";
            $HOSTS{ $images[$i] }{'exists'} = 1;
        }
    }

}

sub setProjectVersion {
    
    my $project = $_[0];
    $project = $PROJECT unless $project;
    my $new_version = $_[1];
    my $version;
    
    if (stat("$PROJECT_PATH/$project/version")){
	open (FILE,"$PROJECT_PATH/$project/version");
	$version = <FILE>;
	chomp($version);
	verbose("version is $version\n");
	close(FILE);
    }
    if ( $new_version ){
	$version = $new_version;
    } else {
	$version++;
    }
    open (FILE,">$PROJECT_PATH/$project/version");
    verbose("setting version to $version\n");
    print FILE "$version\n";
    close(FILE);
    
}
sub getProjectVersion {
    
    my $project = $_[0];
    my $version;
    if (stat("$PROJECT_PATH/$project")){
	open (FILE,"$PROJECT_PATH/$project/version");
	$version = <FILE>;
	chomp($version);
	verbose("version is $version\n");
	close(FILE);
	return "$version";
    }
}

sub getProjectManager {
    
    my $project = $_[0];
    my $manager;
    if (stat("$PROJECT_PATH/$project")){
	open (FILE,"$PROJECT_PATH/$project/manager");
	$manager = <FILE>;
	chomp($manager);
	verbose("Project manager is $manager\n");
	close(FILE);
	return "$manager";
    }
}

sub updateProjectVersion {

    my $project = $_[0];
    my $sock = $_[1];
    verbose("Update project version called fo $project\n");
    # 0. Check if we heed project versions and if manager exists
    
    if ( not $sock ){
	if ( not stat("$PROJECT_PATH/$project/manager")){
	    # this project is local, exiting quietly. 
	    return 1;
	}
    }
    verbose("manager OK\n");
    if ( not $DEFAULTS{"CHECK_PROJECT_VERSION"} ){
	# we don't check for project versions
	return 1;
    }

    # 1. Get the project version
    my $version = getProjectVersion($project);
#    print "my version is $version\n";
    # 2. Find the manager and connect
    
    my $manager = getProjectManager($project);
    verbose("my manager is $manager\n");
    if ( not $sock ){
	$sock = new IO::Socket::INET(
	    PeerAddr => $manager,
	    PeerPort => 34001,
	    Proto    => 'tcp');
    }
    if ( $sock ){
	verbose("Socket is established\n");
    # 3. Ask the manager for latest version
	print $sock "project_version_request:$project:$SERVICE_HOST\n";
	my $reply = <$sock>;
#	print "answer back: $reply";
	chomp $reply;
	if ( $reply =~ /^project_version:$project:(\d+)$/ ){
	    # 4. If local version is old, ask for newer version
	    if ( $1 > $version ){
		out("Project has been updated to version $1. Local version is $version\n");
		print $sock "GET-PROJECT-FILE\n";
		system("cp $PROJECT_PATH/$project/$project.mln $PROJECT_PATH/$project/$project.mln" . time );
		open(FILE,">$PROJECT_PATH/$project/$project.mln");
		$reply = <$sock>;		
		while( $reply ne "OUTPUT-END\n" ){
		    print FILE $reply;
		    $reply = <$sock>;

		}	
		# print "Done\n";
		setProjectVersion($project,$1);
		if ( not $_[1] ){
#		    print "closing socket\n";
		    close($sock);
		}
		return $1;
	    } else {
#		print "version OK\n";
		print $sock "GOODBYE\n";
		if ( not $_[1] ){
#		    print "closing socket\n";
		    close($sock);
		}
#		print "returning $version\n";
		return $version;
	    }
	} else {
	    close($sock);
	    out("$manager did not provide correct project version answer\n");
	    return 0;
	}	    	    

    } else {
	out("Could not connect to $manager: $!\n");
	return 0;
    }
}

sub saveConfig {

#    my $data = $_[0];
#    $data = $DATA_ROOT unless $data;
# this method needs to be more flexible
	my $configfile = "$PROJECT_PATH/$PROJECT/$PROJECT.mln";
	$configfile = $_[0] if $_[0];

    out("Saving Config file: $configfile\n");
    
#    system("cp $CONFIGFILE $PROJECT_PATH/$PROJECT/$PROJECT.mln");
    open( F, ">$configfile" )
      or print STDERR
      "WARNING: Failed to open $configfile\n";

    printBlock($DATA_ROOT,"",F);
#    my $each;
#    foreach $each (@CONFIG_FILE_TRANSCRIPT) {
#        print F $each;
#    }
    print F "\n";
    close(F);

}


sub getUpgradeElement {

    my $hostname = $_[0];
    my $variable = $_[1];

    return $UPGRADE_LIST{$hostname}{$variable};

}

# sub compareHosts {
#     my $hostname;
#     $hostname = $_[0];
#     my $each;
#     my %host;

#     foreach $each ( keys %USED_VARIABLES ) {

#         # we need a decision based on every possible variable.
#         # Some might need rebuild, others don't.
#         # This means quite a bit of code, but it is possible to group scalar
#         # variables by consequence, like all that affect start/stop scripts in
#         # one group.

#        # We have three different tasks (in order): rebuild, reconfigure, scripts
#        # An operator setTask has to be convergent to the stronger tasks.

#         # The resize is a special case, and has to be recorded separately.

#         my $new = getVariable( $hostname, $each );
#         my $old = getVariable( $hostname, $each, "old" );

#         #	    return "pass" if ((not $new and $old) or ( $new and not $old));
#         #	    print "DEBUG: testing $each ($new,$old)\n";
#         next if ( not $new and not $old );

#         if ( $each =~ /template|cow_filesystem|service_host|devfs/ ) {

#             setUpgradeTask( $hostname, "rebuild", $each )
#               if ( ( not $new and $old )
#                 or ( $new and not $old )
#                 or ( $new ne $old ) );

#             #       	setUpgradeElement($hostname,$each);
#         } elsif ( $each =~ /^groups$/ ) {
# 	    my %new_hash = %$new;
# 	    my %old_hash = %$old;

# 	    my $new_group; 
# 	    my $old_group;
	     
# 	    foreach $new_group (keys %new_hash){
# 		if( not $old_hash{$new_group}){
# 		    setUpgradeTask( $hostname, "reconfigure", $each );
# 		} else {
# 		    my $tm = $new_hash{$new_group};
# 		    my @new_users = @$tm;
		    
# 		    $tm = $new_hash{$old_group};
# 		    my @old_users = @$tm;
		    
# 		}
# 	    }
	    
	    
# 	}
#         elsif ( $each =~ /^swap$/ ) {

#             setUpgradeTask( $hostname, "reconfigure", $each )
#               if ( ( not $new and $old )
#                 or ( $new and not $old )
#                 or ( $new ne $old ) );

#             #		setUpgradeElement($hostname,$each);
#         }
#         elsif ( $each =~ /network/ ) {
#             my $k;
#             my %net     = %$new;
#             my %old_net = %$old;
#             my $task    = "reconfigure";

#             foreach $k ( keys %old_net ) {
#                 setUpgradeTask( $hostname, $task, $each )
#                   and setUpgradeElement( $hostname, $each )
#                   if ( not $net{$k} );
#             }

#             foreach $k ( keys %net ) {
#                 my $n;
#                 my $o;

#                 setUpgradeTask( $hostname, $task, $each )
#                   and setUpgradeElement( $hostname, $each )
#                   if ( not $old_net{$k} );
#                 if ( $old_net{$k} and $net{$k} ) {
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->address ne $old_net{$k}->address );
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->gateway ne $old_net{$k}->gateway );
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->netmask ne $old_net{$k}->netmask );
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->iface ne $old_net{$k}->iface );
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->tun_address ne $old_net{$k}->tun_address );
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->tun_iface ne $old_net{$k}->tun_iface );
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->switch ne $old_net{$k}->switch );
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->broadcast ne $old_net{$k}->broadcast );
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->mac ne $old_net{$k}->mac );
#                     setUpgradeTask( $hostname, $task, $each )
#                       and setUpgradeElement( $hostname, $each )
#                       if ( $net{$k}->auto ne $old_net{$k}->auto );
#                 }
#             }

#         }
#         elsif ( $each =~ /^modules$/ or $each =~ /^startup$/ ) {
#             my @array     = @$new;
#             my @old_array = @$old;

#             if ( $#array != $#old_array ) {

#                 #		    print "Different lentgh error.\n";
#                 setUpgradeElement( $hostname, $each );
#                 setUpgradeTask( $hostname, "reconfigure", $each );
#             }

#             my $k;

#             for ( $k = 0 ; $k <= $#array ; $k++ ) {
#                 setUpgradeTask( $hostname, "reconfigure", $each )
#                   and setUpgradeElement( $hostname, $each )
#                   if ( "$array[$k]" ne "$old_array[$k]" );
#             }

#         }
#         elsif ( $each =~ /files/ ) {
#             my $k;
#             my @files     = @$new;
#             my @old_files = @$old;

#             if ( $#old_files != $#files ) {

#                 #		      print "Different length error.\n";
#                 setUpgradeElement( $hostname, $each );
#                 setUpgradeTask( $hostname, "reconfigure", $each );
#             }

#             foreach $k (@files) {
#                 my $match = 0;
#                 my $n;

#                 foreach $n (@old_files) {
#                     if (    $k->from eq $n->from
#                         and $k->to          eq $n->to
#                         and $k->permissions eq $n->permissions )
#                     {
#                         $match = 1;
#                     }
#                 }
#                 setUpgradeTask( $hostname, "reconfigure", $each )
#                   and setUpgradeElement( $hostname, $each )
#                   if ( not $match );
#             }

#         }
#         elsif ( $each =~ /mount/ ) {
#             my $k;
#             my @mount     = @$new;
#             my @old_mount = @$old;

#             if ( $#old_mount != $#mount ) {

#                 #		      print "Different length error.\n";
#                 setUpgradeTask( $hostname, "reconfigure", $each );
#                 setUpgradeElement( $hostname, $each );
#             }

#             for ( $k = 0 ; $k <= $#mount ; $k++ ) {
#                 my $match = 0;
#                 my $n     = $mount[$k];
#                 my $o     = $old_mount[$k];

#                 if (
#                        not $o
#                     or not $n
#                     or not( $o->from eq $n->from
#                         and $o->to      eq $n->to
#                         and $o->type    eq $n->type
#                         and $o->options eq $n->options )
#                   )
#                 {
#                     setUpgradeTask( $hostname, "reconfigure", $each );
#                 }
#             }
#         }
#         elsif ( $each =~ /users/ ) {
#             my $k;
#             my @users     = @$new;
#             my @old_users = @$old;

#             if ( $#old_users != $#users ) {

#                 #		      print "Different length error.\n";
#                 setUpgradeTask( $hostname, "reconfigure", $each );
#                 setUpgradeElement( $hostname, $each );
#             }

#             foreach $k (@users) {
#                 my $match = 0;
#                 my $n;

#                 foreach $n (@old_users) {
#                     if (    $k->name eq $n->name
#                         and $k->homedir  eq $n->homedir
#                         and $k->password eq $n->password
#                         and $k->uid      eq $n->uid )
#                     {
#                         $match = 1;
#                     }
#                 }
#                 setUpgradeTask( $hostname, "reconfigure", $each )
#                   and setUpgradeElement( $hostname, $each )
#                   if ( not $match );
#             }
#         }
#         elsif ( $each =~ /^root_password$|^nameserver$|modules_dir/ ) {

#             setUpgradeTask( $hostname, "reconfigure", $each )
#               and setUpgradeElement( $hostname, $each )
#               if ( $new ne $old );

#         }
#         elsif ( $each =~
#             /^memory$|^term$|owner|group|sudo|color|boot_order|nice|devfs/ )
#         {

#             #		print "DEBUG: $each matched ($new,$old)\n";

#             setUpgradeTask( $hostname, "scripts", $each )
#               and setUpgradeElement( $hostname, $each )
#               if ( $new ne $old );

#         }
#         elsif ( $each =~ /^size$|^free_space$/ ) {

#             setUpgradeTask( $hostname, "resize", $each )
#               and setUpgradeElement( $hostname, $each )
#               if ( $new ne $old );

#         }
#         elsif ( $each =~ /^kernel$/ ) {

#         }
#     }

#     return $HOSTS{$hostname}{'upgrade'};
# }

# sub setUpgradeTask {

#     my $hostname = $_[0];
#     my $task     = $_[1];
#     my $variable = $_[2];

#     my $old_task = $HOSTS{$hostname}{'task'};
#     my $result   = $old_task;

#     $HOSTS{$hostname}{'upgrade'} = 1;

#     setUpgradeElement( $hostname, $variable );

#     if ( $task eq "resize" ) {
#         $HOSTS{$hostname}{'resize'} = 1;

#         #	print "DEBUG: Setting resize for $hostname\n";
#         return;
#     }

#     if ( not $old_task or $old_task eq "scripts" ) {
#         $result = $task;
#     }
#     elsif ( $task eq "reconfigure" and not( $task eq "rebuild" ) ) {
#         $result = $task;
#     }
#     elsif ( $task eq "rebuild" ) {
#         $result = $task;
#     }

# #     print "DEBUG: Setting upgrade task for $hostname from '$old_task' to '$result'\n";
#     $HOSTS{$hostname}{'task'} = $result;

# }



sub checkIfUp {
    return if ($CONFIGURE_HOSTS_ONLY);

    my $key     = $_[0];
    my $project = $_[1];
    my $root = $_[2];
#    if ( not $root){
#	print "checkIfUp: no root submitted\n";
#    }
    $root = $DATA_ROOT unless $root;
    
    if ( %PLUGIN_LIST ){
	
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    
	    my $subcall = $plugin . "_checkIfUp"; 
#	    print "calling $subcall\n";
#	    verbose("calling $subcall\n");
	    if ( defined(&$subcall) ){
		my $status =  &$subcall($key,$project,$root);
		if ( $status =~ /^-1/ ){
		    return 0;
		} elsif ( $status =~ /^1/) {
		    return $status;
		}
	    }
	    
	}
    }    

    
    my $path = "$PIDDIR/$key/$key/mconsole";
    my $xen = getScalar("/host/$key/xen",$root);
#    print "checkIfUp: $key is xen: $xen\n";
    
    if ($project) {

        $path = "$PROJECT_PATH/$project/${PIDDIR_NAME}/$key/$key/mconsole";
    }

    #    print "*** path: $path\n";
    if ( $xen ){
#	print "checkIfUp says this is a xen host\n";
	my $project = getScalar("/global/project",$root);
	if ( @XM_LIST_CACHE ){
#	    print "XM_LIST_CACHE exists\n";
	    my @status = grep(/$key\.$project/,@XM_LIST_CACHE);
	    if ( @status ) {
#		print "match on $key.$project\n";
		return 1;
	    }
	    else {
		return 0;
	    }
	} else {
	    my $status = `$shell{'XM'} list $key.$project 2>/dev/null | grep "$key.$project"`;
	    
	    chomp $status;
#	    print "status return: $status\n";
#	    my $ret = system("xm list $key.$project 1>/dev/null");
#	    print "ret: $ret, and $? - $!\n";
#	    if (system("xm list $key.$project 1>/dev/null 2>/dev/null") == 0 ){
#		print "$key.$project is up\n";
#	    }
	    if ( $status =~ /$key\.$project/ ) {
		return 1;
	    }
	    else {
		return 0;
	    }
	}
    } else {
#	print "checkIfUp says this is a UML host\n";
	my $status = `$shell{'UML_MCONSOLE'}  $path version 2> /dev/null`;
	chomp $status;
	if ( $status =~ /OK/ ) {
	    return 1;
	    
	}
	else {
	    return 0;
	}
    }
}

sub upgradeHosts {

    my $key;

    if ($CONFIGURE_HOSTS_ONLY) {
        foreach $key ( split /:/, $HOSTLIST ) {
            if ( getScalar("/host/$key",$DIFF) ) {
                buildHostFilesystem($key);
            }
        }
    }
    else {
        #	print "DEBUG: upgradeHosts: selecting hosts for upgrade\n";
        foreach $key ( getBlockKeys("/host/$key",$DIFF) ) {
                buildHostFilesystem($key);
        }
    }
}

sub upgradeMLNHosts {
    my $key;
    foreach $key ( getBlockKeys("/host",$DIFF)){
#	out("is $key being upgraded?");
	if ( not $LIVE_LIST{$key}  and ( getScalar("/host/$key/service_host") eq $SERVICE_HOST or ( not getScalar("/host/$key/service_host")))) {
	    # AHA!
	    # we skip reconfiguration for the live hosts
	    # but that means we do not get start and stop scripts

	    if ( checkIfUp($key,$PROJECT,$OLD_DATA_ROOT) ){
		out("$key is running, shutting down\n");
		stopHost($key,$PROJECT,$OLD_DATA_ROOT);
		$RESTART_ME{$key} = 1;
		buildMLNHost($key);

	    } else {
		buildMLNHost($key);
	    }
	} elsif ( $LIVE_LIST{$key} and ( getScalar("/host/$key/service_host") eq $SERVICE_HOST or ( not getScalar("/host/$key/service_host"))) ) {
	    out("$key: creating start and stop scripts\n");
	    configure_host_XEN($key);
	    executePlugin("createStartStopScripts",$key);
	    # we offer plugins to do stuff to he running VM. very scary...
	    if ( %PLUGIN_LIST ){
		
		my $plugin;
		foreach $plugin (keys %PLUGIN_LIST){
		    
		    my $subcall = $plugin . "_liveUpgrade"; 
#		    print "calling $subcall\n";
		    verbose("calling $subcall\n");
		    if ( defined(&$subcall) ){
			&$subcall($key);
		    }
		    
		}
	    }    
	    
	    
	}
    }    
}

sub registerUpgradeCandidates {

    my $key;
    my @candidates;

    open( CANDIDATES, ">$USER_MODE_TEMP_DIR/diff.mln" )
      or die "failed to read $USER_MODE_TEMP_DIR/diff.mln\n";

    foreach $key ( getHosts($DIFF) ) {
	if ( not $LIVE_LIST{$key}){
#	    print "registering $key for upgrade\n";
	    print CANDIDATES "$key\n";
	}
    }
    close(CANDIDATES);
}

sub readUpgradeCandidates {
    my $cand;
#    $DIFF = buildDataTree($UPGRADE_CANDIDATES_FILE);
    print "read upgrade candidates: \n";
    printBlock($DIFF);
}

sub prepareForReconfig {
    my @array;
    if ( @RECONFIGURE_HOST_LIST ){
	@array = @RECONFIGURE_HOST_LIST
    } else {
	@array = getHosts();
    }
    my $host;
    foreach $host (@array){
	if ( checkIfUp($host)){
	    $RESTART_ME{$host} = 1;
	    stopHost($host);
	}
    }
}


sub stopHosts {

    return if ($CONFIGURE_HOSTS_ONLY);
    my $key;

    foreach $key ( getHosts($DIFF) ) {
	if ( checkIfUp($key,$PROJECT,$OLD_DATA_ROOT) ) {
	    $RESTART_ME{$key} = 1;
	    stopHost($key);
	}
    }
    
    foreach $key ( getHosts($OLD_DATA_ROOT) ) {
	if ( checkIfUp($key,$PROJECT,$OLD_DATA_ROOT) and not getScalar("/host/$key")) {
	    stopHost($key,$PROJECT,$OLD_DATA_ROOT);
	}
    }
}

sub startReconfiguredHosts {
    return if ($CONFIGURE_HOSTS_ONLY);
        my @array;
    if ( @RECONFIGURE_HOST_LIST ){
	@array = @RECONFIGURE_HOST_LIST
    } else {
	@array = getHosts();
    }
    my $host;
    foreach $host (@array){
	if ( $RESTART_ME{$host}){
	    startHost($host);
	}
    }
    
}

sub startHosts {

#    return if ($CONFIGURE_HOSTS_ONLY);
    my $key;

    foreach $key ( getHosts($DIFF) ) {
####	print "Restart me: $RESTART_ME{$key}\n";
	if ( $RESTART_ME{$key} or ( not getScalar("/host/$key",$OLD_DATA_ROOT) and keys %RESTART_ME ) or (not getScalar("/host/$key",$OLD_DATA_ROOT) and $RESTART_UPGRADED) ){
	    my $service_host = getScalar("/host/$key/service_host");
	    if ( ($service_host and $SERVICE_HOST and $service_host eq $SERVICE_HOST) or not $service_host){
#		print "starting $key\n";
		startHost($key);
	    }
	}
    }
}

sub stopHost {
    my $hostname = $_[0];
    my $project = $_[1];
    my $root = $_[2]; 
    my $wait = $_[3];
    my $halt = $_[4];
    out("wait : $wait\n");
    out("halt: $halt\n");
    $root = $DATA_ROOT unless $root;
    
    $project = $PROJECT unless $project;
    if ( not getScalar("/host/$hostname/xen",$root) ){
	out("Sending stop signal to $hostname: ");
	my $status =
	  `$shell{'UML_MCONSOLE'} $PIDDIR/$hostname/$hostname/mconsole cad 2>/dev/null`;
	print "$status";
	my $wait = "OK";
	print "Waiting";
	
	while ( $wait =~ /OK/ ) {
	    sleep 4;
	    my $status =
	      `$shell{'UML_MCONSOLE'} $PIDDIR/$hostname/$hostname/mconsole version 2>/dev/null`;
	    print ".";
	    $wait = "NO" if ( not $status =~ /OK/ );
	    
	}
	print " done\n";
    } else {	

	my $boot_order = getScalar("/host/$hostname/boot_order",$root);
	$boot_order = $DEFAULTS{'BOOT_ORDER'} unless $boot_order;    
	
	out("Sending stop signal to $hostname: ");

	
	
	system("$PROJECT_PATH/$PROJECT/stop_${boot_order}_$hostname.sh $halt");
	my $count;
	while ( checkIfUp($hostname,$project,$root) ) {
	    out(".");
	    sleep 3;
	    $count += 3;
	    if ( $count > $wait ){
		out("Wait exceeded $wait seconds, terminating $hostname\n");
		system("$PROJECT_PATH/$PROJECT/stop_${boot_order}_$hostname.sh halt");
	    }	    
	}
        out(" done\n");
    }
}

sub startHost {

    my $hostname = $_[0];
    my $pwd      = $ENV{'PWD'};

    print "Starting $hostname\n";

    chdir("$PROJECT_PATH/$PROJECT");

    my $start_script =
      `find . -type f -iname "start_*${hostname}.sh" -printf "%p"`;
    chomp $start_script;

    if ( stat("$start_script") ) {

        system("$start_script");
    }
    else {
        warn
"Failed to find start script for $hostname in $PROJECT. Is is spelled correctly?\n";
    }
    chdir("$pwd");
}

sub removeOldSwitches {
    my $key;
#    print "removeOldSwitches called\n";
    my @switches = getBlockKeys("/switch",$OLD_DATA_ROOT);
    foreach $key (@switches){
	
	my $old_s = getScalar("/switch/$key/service_host",$OLD_DATA_ROOT);
	my $new_s = getScalar("/switch/$key/service_host",$DATA_ROOT);
	if ( not $old_s and $SERVICE_HOST ){ 
	    $old_s = $SERVICE_HOST;
	}
#	print "checking $key for removal new: $new_s old: $old_s ($SERVICE_HOST)\n";
#	print "getScalar('/switch/$key/') = " . getScalar("/switch/$key",$DATA_ROOT) . "\n";
        if ( ($new_s and $new_s ne $old_s and $old_s eq $SERVICE_HOST ) ) {

            print "Removing start and stop scripts for switch $key\n";

            verbose(
		"$shell{'RM'} $PROJECT_PATH/$PROJECT/start_${key}.sh\n"
            );
            system(
		"$shell{'RM'} $PROJECT_PATH/$PROJECT/start_${key}.sh"
            );
            system(
		"$shell{'RM'} $PROJECT_PATH/$PROJECT/stop_${key}.sh"
            );
	    my $obridge = getScalar("/switch/$key/bridge",$OLD_DATA_ROOT);
	    my $bridge = $obridge;
	    $bridge = "$key.$PROJECT" unless $obridge;
#	print "bridge name: $bridge " . length($bridge) ."\n";
	    if ( length($bridge) > 16 and not $obridge ){
		my $rest = 15 - length($key);
		my $crop = $PROJECT;
		$crop =~ s/^(.*)(\S{$rest})$/$2/;
		$bridge = "$key.$crop";
#	    print "new bridge name: $bridge\n";
	    }
	    system("ifconfig $bridge down 2>/dev/null");
	    system("brctl delbr $bridge 2>/dev/null");

	    

        }
    }	
	
    
}

sub removeOldHosts {
#    print "RemoveHosts called\n";
    
    my $key;


    foreach $key ( getHosts($OLD_DATA_ROOT) ) {
	next if getScalar("/host/$key");
	my $old_s = getScalar("/host/$key/service_host",$OLD_DATA_ROOT);
	my $new_s = getScalar("/host/$key/service_host",$DATA_ROOT);
#	print "$old_s Vs $new_s\n";
	if ( not $old_s and $SERVICE_HOST ){ 
	    $old_s = $SERVICE_HOST;
	}
	
	# dette er stedet hvor leg sjekker om en host ikke lenger er her
	my $host = getScalar("/host/$key",$DATA_ROOT);

        if ( not getScalar("/host/$key",$DATA_ROOT) or ($new_s and $new_s ne $old_s and $old_s eq $SERVICE_HOST ) ) {
	    out("Shutting down $key\n");
	    my $boot_order = getScalar("/host/$key/boot_order",$OLD_DATA_ROOT );
	    
            $boot_order = 99 unless $boot_order;

	    system("$PROJECT_PATH/$PROJECT/stop_${boot_order}_${key}.sh");
	    while ( checkIfUp($key,$PROJECT,$OLD_DATA_ROOT) ) {
		sleep 3;
		out(".");
	    }
	    out("\n");
            out("Removing start and stop scripts for $key\n");

            verbose(
		"$shell{'RM'} $PROJECT_PATH/$PROJECT/start_${boot_order}_${key}.sh\n"
            );
	    if ( stat("$PROJECT_PATH/$PROJECT/start_${boot_order}_${key}.sh")){
		system(
		    "$shell{'RM'} $PROJECT_PATH/$PROJECT/start_${boot_order}_${key}.sh"
		);
	    }
	    if ( stat("$PROJECT_PATH/$PROJECT/stop_${boot_order}_${key}.sh")){
		system(
		    "$shell{'RM'} $PROJECT_PATH/$PROJECT/stop_${boot_order}_${key}.sh"
		);
	    }
	    my $vm_is_removed;
	    foreach my $plugin (keys %PLUGIN_LIST){
		
		my $subcall = $plugin . "_removeHost"; 
		if ( defined(&$subcall) and not $vm_is_removed ){
		    $vm_is_removed = &$subcall($key,$PROJECT);
		}
		
	    }
	    

        }
    }
}

sub networkConfigBusybox {
#    print "network config busybox\n";
    my $hostname = $_[0];
    my $i        = 0;
    my $netw     = $_[1];
    my %network  = %$netw;
    my $each;
    return unless %network;

    open( NETCONF, ">>$MOUNTDIR/etc/init.d/rcS" )
      or ( print "Failed to open file $MOUNTDIR/etc/init.d/rcS\n" and return);

    foreach $each ( keys %network ) {

        if ( $network{$each}{'address'} =~ /\d+\.\d+\.\d+\.\d+/ ) {
            my $tm      = $network{$each}{'broadcast'};
            my $command =
              "ifconfig " . $each . " " . $network{$each}{'address'} . " ";

            $command .= " netmask " . $network{$each}{'netmask'};
            if ($tm) {
                $command .= " broadcast" . $network{$each}{'broadcast'};
            }
            $command .= " up\n";
            print NETCONF "$command";

            if ( $network{$each}{'gateway'} ) {
                print NETCONF "route add default gw " . $network{$each}{'gateway'} . "\n";
            }
        }
        elsif ( $network{$each}{'address'} =~ /^dhcp$/ ) {
            print NETCONF "mkdir -p /var/state/dhcp\n";
            print NETCONF "ifconfig " . $each . " 0.0.0.0 up\n";
            print NETCONF "dhclient " . $each . " &\n";

            #		print NETCONF "udhcpc -i " . $each->iface . " &\n";
        }

    }

    close(NETCONF);

}

# sub vtunParser {

#     my @vtun;
#     my @line;
#     my $stack;
#     my $i = 0;

#     while ( @line = getCLine() ) {

#         $vtun[ $i++ ] = getRestAsString( 0, \@line );
#         $stack++ if ( $vtun[ ( $i - 1 ) ] =~ /\{/ );

#         if ( $line[0] =~ /\}/ ) {
#             if ( $stack == 0 ) {
#                 $vtun[ ( $i - 1 ) ] = "";
#                 last;

#             }
#             else {
#                 $stack--;
#             }
#         }
#     }

#     return @vtun;
# }

# sub setVtun {
#     my $hostname = $_[0];
#     my $i        = 0;
#     my $temp     = $_[1];
#     my @vtun     = @$temp;

#     ############ Writing the configuration file:

#     open( VTUND, ">$MOUNTDIR/etc/vtund.conf" )
#       or die "Failed to open file $MOUNTDIR/etc/vtun.conf\n";

#     #      }
#     for ( $i = 0 ; $i <= $#vtun ; $i++ ) {
#         print VTUND "$vtun[$i]\n";
#     }
#     close VTUND;

#     ########## Doing the Debian workaround to make vtun work
# # Its a bit dirty this way, but just creating the folder right away didn't seem to work

#     my @commands = ();

#     $commands[0] = "mkdir -p /dev/misc/net";
#     $commands[1] = "ln -sf /dev/net/tun /dev/misc/net/tun";

#     setStartupCommands( $hostname, \@commands );

#     print "vtun.conf configured\n";

# }

sub setMount {

    my $hostname = $_[0];
    my $tm       = $_[1];
    my $format   = $_[2];
    
    return if getScalar("/host/$hostname/hvm");
    
    my @mount = getArray("/host/$hostname/mount"); 
    my @fstab;
    my $fsc;
    my $swap  = getScalar("/host/$hostname/swap");
    my $xen  = getScalar("/host/$hostname/xen");
    my $devfs = getScalar("/host/$hostname/devfs");
    my $disk_counter = 2;
    
    my $each;

    verbose("Mount offset: $MOUNT_OFFSET\n");
    if ($devfs) {
        $fstab[ $fsc++ ] = "/dev/ubd/0 / $format defaults 0 1";
    } elsif( $xen ) {
	$fstab[ $fsc++ ] = "/dev/hda1 / $format defaults 0 1";
    } else {
        $fstab[ $fsc++ ] = "/dev/ubd0 / $format defaults 0 1";
    }
    $fstab[ $fsc++ ] = "proc /proc proc defaults 0 0";
    if ($swap) {
	if ( $xen ) {
        $fstab[ $fsc++ ] = "/dev/hda2 none swap sw 0 0";
	} else {
	    $fstab[ $fsc++ ] = "/dev/ubd16 none swap sw 0 0";
	}
    }

    if (@mount) {
	out("adding additional mounts\n");
        foreach $each (@mount) {
	    my $hd_counter = 3;
	    my @line =  split /\s+/,$each;
	    my $options = "defaults";
	    $options = $line[3] if ( $line[3] );
		
	    if ( $xen ){
		if ( not $line[2] eq "hostfs" ){
		    $fstab[ $fsc++ ] = "/dev/hda$hd_counter $line[1] $line[2] $options 0 0";
		    $hd_counter++;
		} else {
		    print "WARNING: hostfs is not supported under Xen, skipping $line[1]\n";
		}
	    } else {
		$fstab[ $fsc++ ] = "/dev/ubd" . ( $disk_counter * $MOUNT_OFFSET ) ." $line[1] $line[2] $options 0 0";
		$disk_counter++;
	    }
	    makeDirectory($hostname,$line[1]);
	    
	    }
	
	} else {
	    verbose("no additional mounts\n");
	}
	
	writeToFile( $hostname, "/etc/fstab", \@fstab );
}

sub addToFile {

    my $hostname = $_[0];
    my $filename = $_[1];
    my $tm       = $_[2];
    my @content  = @$tm;
#    system("df -h");
#    system("ls $MOUNTDIR/etc");
    if (not open( F, ">>$MOUNTDIR$filename" )){
	verbose("Failed to open file $MOUNTDIR$filename: $!\n");
	return;
    }
    #   }
    for ( my $i = 0 ; $i <= $#content ; $i++ ) {
	verbose("adding content: \'$content[$i]\'\n");
        print F "$content[$i]\n";
    }
    close F;

}

sub makeDirectory {

    my $hostname = $_[0];
    my $path     = $_[1];

    system("$shell{'MKDIR'} -p $MOUNTDIR$path");

}

# sub dyndnsParser {
#     my @line;
#     my @files;
#     my $filecounter = 0;
#     my $dyndns      = new Dyndns;
#     while ( @line = getCLine() ) {
#         last if $line[0] =~ /\}/;

#         if ( not $line[0] =~ /\{/ ) {
#             if ( $line[0] =~ /user/ ) {
#                 $dyndns->user( getValue( $line[1] ) );
#             }
#             elsif ( $line[1] =~ /password/ ) {
#                 $dyndns->password( getValue( $line[1] ) );
#             }
#             elsif ( $line[1] =~ /hostname/ ) {
#                 $dyndns->hostname( getValue( $line[1] ) );
#             }
#         }

#     }

#     return $dyndns;

# }

# sub setDyndns {

#     my $hostname = $_[0];
#     my $dyndns   = $_[1];

#     my @command;

#     $command[0] = "#!/bin/sh";
#     $command[1] = "NAME=" . $dyndns->user;
#     $command[2] = "PASS=" . $dyndns->password;
#     $command[3] = "HOST=" . $dyndns->hostname;
#     $command[4] = "if [ ! -f ipcheck.dat ]; then";
#     $command[5] =
#       "./ipcheck.py -l --makedat -r checkip.dyndns.org \$NAME \$PASS \$HOST";
#     $command[6] = "else";
#     $command[7] = "./ipcheck.py -l -r checkip.dyndns.org \$NAME \$PASS \$HOST";
#     $command[8] = "fi";

#     writeToFile( $hostname, "/root/update-ip.sh", \@command, "755" );

#     my @cron;
#     @cron[0] = "# dyndns.org dynamical update";
#     @cron[1] = "*/3 * * * * root /root/update-ip.sh";

#     addToFile( $hostname, "/etc/crontab", \@cron );

# }

sub writeToFile {

    my $hostname    = $_[0];
    my $filename    = $_[1];
    my $tm          = $_[2];
    my $permissions = $_[3];

    my @content = @$tm;

    # Make sure the directory exists
    my @pathary = split ('/',$filename);
    pop @pathary;
    my $dirname = join('/', @pathary);
    makeDir($MOUNTDIR.$dirname);

    open( F, ">$MOUNTDIR$filename" )
      or verbose("Failed to open file $MOUNTDIR/$filename\n");

    for ( my $i = 0 ; $i <= $#content ; $i++ ) {
        print F "$content[$i]\n";
    }
    close F;

    if ($permissions) {

        system("$shell{'CHMOD'} $permissions $MOUNTDIR$filename");

    }
    verbose("Written to file $MOUNTDIR$filename\n");
}

sub printScalarVariable {

    my $hostname = $_[0];
    my $variable = $_[1];

    my $tmp = getScalar("/host/$hostname/$variable" );
    print "$hostname: $variable = '$tmp'\n" if ($tmp);

}

# Helper method for downloadTemplates

sub getTemplateVersion {

    my $string = $_[0];

    my $v = new TemplateVersion;

    $string =~ /^.*V(\d+)\.(\d+)\.(ext2|dir|ext3|img)(|(\.tar\.(gz|bz2)))$/;

    $v->major($1);
    $v->minor($2);

    return $v;

}

# This method finds a list of all the templates we have locally

sub findLocalTemplates {

    # first I find out what templates I have locally

    if ( stat("$TEMPLATEDIR/$TEMPLATE_LIST_FILE") ) {
        open( LL, "$TEMPLATEDIR/$TEMPLATE_LIST_FILE" )
          or die "failed to open $TEMPLATEDIR/$TEMPLATE_LIST_FILE";
        my $temp;
        while ( $temp = <LL> ) {
            chomp $temp;
            my @line = ();
            @line = split /\s+/, $temp;

            $LOCAL_TEMPLATES{"$line[1]"} = getTemplateVersion( $line[1] );
        }
        close(LL);
    }

}

sub listTemplates {

    my $each;

    print "All available templates:\n";
    print "Name:                   Real name:              Size (Bytes)\n";

    foreach $each ( keys %LOCAL_TEMPLATES ) {
        my $template_name = getTemplateName($each);
        $each =~ s/.tar.gz//;
        my $size = getTemplateSize($each);
        print "$template_name\t$each\t$size\n";

    }

}

sub getTemplateName {

    my $tn = $_[0];

    $tn =~ s/^(.*)-V(\d+)\.(\d+)(.*)(|(\.tar\.(bz2|gz)))$/$1$4/;

    return $tn;

}

sub getTemplateNameWithVersion {

    my $tn = $_[0];

    $tn =~ s/^(.*)(\.tar\.(bz2|gz|bz))$/$1/;

    return $tn;

}

sub getTemplateType {

    my $tn = $_[0];

    $tn =~ /^(.*)-V(\d+)\.(\d+)\.(.*)(\.tar\.(bz2|gz|bz))$/;

    return $4;

}

sub getTemplateSize {

    my $template = $_[0];

    my $size = ( stat("$TEMPLATEDIR/$template") )[7];
    return $size;

}

sub templateIsNewer {

    my $template = $_[0];
    my $version  = getTemplateVersion($template);
    my $each;
    my $new;
    $new = "yes";
    foreach $each ( keys %LOCAL_TEMPLATES ) {

        my $local  = getTemplateName($each);
        my $remote = getTemplateName($template);
        $remote =~ s/.tar.gz//;

        $DEBUG && print "DEBUG: In templateIsNewer ...\n";
        $DEBUG && print "DEBUG: Local: $local\n";
        $DEBUG && print "DEBUG: Remote: $remote\n";
        if ( $local eq $remote ) {

            $DEBUG
              && print "DEBUG: Local_major: "
              . $LOCAL_TEMPLATES{$each}->major
              . " remote_major: "
              . $version->major . "\n";
            if ( $LOCAL_TEMPLATES{$each}->major < $version->major ) {

                next;
            }
            elsif ( $LOCAL_TEMPLATES{$each}->major == $version->major ) {

                $DEBUG
                  && print "DEBUG: local_minor: "
                  . $LOCAL_TEMPLATES{$each}->minor
                  . " remote_minor: "
                  . $version->minor . "\n";
                if ( $LOCAL_TEMPLATES{$each}->minor < $version->minor ) {
                    next;
                }
                elsif ( $LOCAL_TEMPLATES{$each}->minor >= $version->minor ) {
                    $DEBUG && print "DEBUG: The remote is old\n";
                    $new = "no";
                }
            }
        }
    }
    return $new;
}

sub checkTemplates {

    my $each;
    foreach $each ( getHosts() ) {

	my $sh = getScalar("/host/$each/service_host");
	if ( $SERVICE_HOST and $sh and $sh eq $SERVICE_HOST ){
	    
	    my $lvm_snapshot = getScalar("/host/$each/lvm_snapshot");
	    
            my $template = getScalar("/host/$each/template" );
	    if ( not $lvm_snapshot ){
		if ( not $template ) {
		    $template = $DEFAULTS{TEMPLATE};
		}
		my $latest = getLatestTemplate($template);
		
	    } else {
		my $vg = getScalar("/host/$each/lvm_vg");
		$vg = $DEFAULTS{'MLN_VG'} if not $vg;
#		if( not stat("/dev/$vg/$template")){
#		    print STDERR
#		      "ERROR: Could not find template /dev/$vg/$template for LVM snapshots\n";
#		    exit 2;		   		    
#		}
	    }
	}

    }
}

sub getLatestTemplate {

    my $template  = $_[0];
    my $max_major = 0;
    my $max_minor = 0;
    my $latest_template;

    # check if there is a version of this template
    my $each;
    foreach $each ( keys %LOCAL_TEMPLATES ) {

        if ( getTemplateName($each) eq $template ) {
#	    print "checking $each " . $LOCAL_TEMPLATES{$each}->major . "." . $LOCAL_TEMPLATES{$each}->minor . "\n";
            if ( $LOCAL_TEMPLATES{$each}->major == $max_major ) {
#		print "$each has highest major so far\n";
                if ( $LOCAL_TEMPLATES{$each}->minor > $max_minor ) {
#		    print "$each has highest minor so far\n";
                    $latest_template = $each;
                    $max_minor       = $LOCAL_TEMPLATES{$each}->minor;
                    $max_major       = $LOCAL_TEMPLATES{$each}->major;
                }
            } elsif ( $LOCAL_TEMPLATES{$each}->major > $max_major ) {
		$latest_template = $each;
		$max_minor       = $LOCAL_TEMPLATES{$each}->minor;
		$max_major       = $LOCAL_TEMPLATES{$each}->major;
	    }
        }
	
    }
    
    if ($latest_template) {
        $latest_template =~ s/\.tar\.(gz|bz2)$//;
#	print "returning latest template $latest_template\n";
        return $latest_template;
    }
    else {
        return $template;
    }

}

sub out {

    my $string = $_[0];
    if ( $GLOBAL_OUTPUT ){
#	print "GLOBAL: $string";
	print $GLOBAL_OUTPUT $string;
    } else {
	my $color  = $_[1];
	
	if ( not $QUIET ) {
	    if ( $color eq "blue" and $COLORS ) {
	    print "\033[34;1m${string}\033[0m";
	    }
	    elsif ( $color eq "red" and $COLORS ) {
		print "\033[31;1m${string}\033[0m";
	    }
	    elsif ( $color eq "lightgreen" and $COLORS ) {
		print "\033[32;1m${string}\033[0m";
	    }
	    elsif ( $color eq "cyan" and $COLORS ) {
		print "\033[36;1m${string}\033[0m";
	    }
	    else {
		print "$string";
	    }
	}
    }
}

sub initializeConfig {
#    print "initializeConfig called\n";
    $homedir = $ENV{'HOME'};
    $user    = $ENV{'USER'};

    # The following two conditionals were previously located
    # within the 'unless' block below. Removing them from
    # that block fixed a serial problem we were having (when
    # running setupMLN, we called other subroutines that
    # expected us to have parsed the config, but it hadn't
    # been parsed yet because we were running in setup mode.

    if ( stat($DEFAULT_FILE) ) {
        parseConfig($DEFAULT_FILE);
    }
    if ( stat("$ENV{'HOME'}/$CONFIG_FILE_NAME") ) {
        parseConfig("$ENV{'HOME'}/$CONFIG_FILE_NAME");
    }
    
    # set the project path to daemon special path, if defined
    if ( $ARGV[0] =~ /^daemon$/ and $DEFAULTS{DAEMON_PROJECTS} ) {
	$PROJECT_PATH = $DEFAULTS{DAEMON_PROJECTS};
    }
    # checking if variables have been overridden:       
    unless ( $ARGV[0] =~ /^setup$/ ) {
        my $i;
        my @temp_array;
        for ( $i = 0 ; $i <= $#ARGV ; $i++ ) {

            if ( $ARGV[$i] eq "-T" ) {
                $TEMPLATEDIR = $ARGV[ ++$i ];
                next;
            }
            elsif ( $ARGV[$i] eq "-P" ) {
                $PROJECT_PATH = $ARGV[ ++$i ];
                next;
            }
            elsif ( $ARGV[$i] eq "-R" ) {
                $SPAWNED_REMOTELY = 1;
                next;
            }
            elsif ( $ARGV[$i] eq "-F" ) {
                $FILES_PATH = $ARGV[ ++$i ];
                next;
            }
            elsif ( $ARGV[$i] =~ /-L|\"-L/ ) {
                $SERVICE_HOST = $ARGV[ ++$i ];
                next;
            }
            else {

                push( @temp_array, $ARGV[$i] );
            }
        }

        @ARGV = @temp_array;

        unless ( $TEMPLATEDIR and $PROJECT_PATH ) {

            out( "Failed to find the templatedir and project path.\n", "red" );
            out(
"MLN does not appear to have been setup. Before using MLN, your site or user configuration must be created.\n Would you like to do that now? (y/N) \n"
            );
            my $answer = <STDIN>;
            if ( $answer =~ /^([yY]|yes)/ ) {
                setupMLN();
            }
            else {
                out( "Not setting up MLN. Quitting.\n", "red" );
                exit 1;
            }
        }

        if (    $ARGV[0] =~ /^build$|^setup$/
            and not stat($PROJECT_PATH)
            and not $SIMULATE )
        {
            out("The directory to store the project is not present: \n");
            out( $PROJECT_PATH . "\n" );
            out("Trying to create it ... ");
            system("mkdir -p $PROJECT_PATH");
            if ( stat($PROJECT_PATH) ) {
                out("OK\n");
            }
            else {
                out("Failed\n");
                out(
                    "Unable to create the project directory. Cannot continue.\n"
                );
                exit 1;
            }

#      print "template: $TEMPLATEDIR\nproject: $PROJECT_PATH\nfiles: $FILES_PATH\n";
#      print "ARGV: @ARGV\n";

        }

        if (    $ARGV[0] =~ /^build$|^setup$/
            and $FILES_PATH
            and not stat($FILES_PATH)
            and not $SIMULATE )
        {
            out(
"The files directory for transfer of files into VMs is not present: \n"
            );
            out( $FILES_PATH . "\n" );
            out("Trying to create it ... ");
            system("mkdir -p $FILES_PATH");
            if ( stat($FILES_PATH) ) {
                out("OK\n");
            }
            else {
                out("Failed\n");
                out("Unable to create the files directory. Cannot continue.\n");
                exit 1;
            }

#      print "template: $TEMPLATEDIR\nproject: $PROJECT_PATH\nfiles: $FILES_PATH\n";
#      print "ARGV: @ARGV\n";

        }
    }

}

# sub setPolicyhost {

#     my $hostname = $_[0];

#     if ( $VIRTUALSITE{'policyhost'} ) {

#         my @content;
#         $content[0] = $VIRTUALSITE{'policyhost'};

#         writeToFile( $hostname, "/var/mln/policyhost", \@content );

#     }

# }

# sub setDnsForwarders {

#     my $hostname = $_[0];

#     if ( $VIRTUALSITE{'dnsforwarders'} ) {

#         my $tm      = $VIRTUALSITE{'dnsforwarders'};
#         my @content = @$tm;

#         writeToFile( $hostname, "/var/mln/dnsforwarders", \@content );

#     }

# }

# sub setDomain {

#     my $hostname = $_[0];

#     if ( $VIRTUALSITE{'domain'} ) {

#         my @content;
#         $content[0] = $VIRTUALSITE{'domain'};

#         writeToFile( $hostname, "/var/mln/domain", \@content );

#     }

# }

sub saveConfigFile {

    my $hostname = $_[0];
    my $file     = $_[1];
    my $line;
    my @transcript;

    open( FILE, "$file" ) or die "Failed to open $file\n";

    while ( $line = <FILE> ) {
        chomp $line;
        push( @transcript, $line );
    }

    writeToFile( $hostname, "/var/$PROJECT.mln", \@transcript );

}

# sub lookup {

#     my $host;
#     my $keyword;
#     my $delimiter = "\n";
#     my $prefix = "";
#     my $configfile;
#     my @selection;
#     my $virtualsite;
#     my $header;
#     my $tail;

#     my $i;
#     my @temp_array;
#     for ($i = 0; $i <= $#ARGV ; $i++){

# 	if ($ARGV[$i] eq "-d" ){
# 	    $delimiter = $ARGV[++$i];
# 	    next;
# 	} elsif ( $ARGV[$i] eq "-p" ){
# 	    $prefix = $ARGV[++$i];
# 	    next;
# 	} elsif ( $ARGV[$i] eq "host" ){
# 	    $host = $ARGV[++$i];
# 	      next;
# 	} elsif ($ARGV[$i] eq "keyword" ){
# 	    $keyword = $ARGV[++$i];
# 	      next;
# 	} elsif ($ARGV[$i] eq "virtualsite" ){
# 	    $virtualsite = $ARGV[++$i];
# 	      next;
# 	} elsif ($ARGV[$i] eq "-f" ){
# 	    $configfile = $ARGV[++$i];
# 	    next;
# 	} elsif ($ARGV[$i] eq "-t" ){
# 	    $tail = $ARGV[++$i];
# 	    next;
# 	} elsif ($ARGV[$i] eq "-h" ){
# 	    $header = $ARGV[++$i];
# 	    next;
#      	}

#     }

#     parse_mln_config_file($configfile);

#     buildGlobalConfig();

#     if ( $host ) {

# 	if ( $host eq "all" ) {
# 	   my $each ;
# 	   foreach $each ( getBlockKeys("/host") ){
# 	       push (@selection , $each ) if ( $HOSTS{$each}{'type'} eq "host" );
# 	   }
# 	} else {
# 	    push (@selection, $host);
# 	}
# 	my $each;
# 	foreach $each ( @selection ){

# 	    my @keywords;

# 	    if ( $keyword eq "all" ){
# 		@keywords = keys %USED_VARIABLES;
# 	    }
# 	    else {
# 		push ( @keywords , $keyword );
# 	    }

# 	    my $key;
# 	    foreach $key (@keywords) {
# 		printHostVariable($host, $key, $delimiter , $prefix , $header , $tail);
# 	    }

# 	}

#     }
#     elsif ( $virtualsite ) {

# 	printVirtualsiteVariable($virtualsite,$delimiter,$prefix);

#     }
# }

# sub printHostVariable {

#     my $hostname  = $_[0];
#     my $variable  = $_[1];
#     my $delimiter = $_[2];
#     my $prefix    = $_[3];
#     my $header    = $_[4];
#     my $tail      = $_[5];

#     if ( isInArray( $variable, \@HOST_SCALAR_KEYWORDS ) ) {
#         my $value = getVariable( $hostname, $variable );
#         print "$header$prefix$value$tail";
#     }
#     elsif ( isInArray( $variable, \@HOST_BLOCK_KEYWORDS ) ) {
#         my $tm = getVariable( $hostname, $variable );
#         my @array = @$tm;
#         my $element;
#         print "$header";
#         foreach $element (@array) {
#             print "$prefix$element$delimiter";
#         }
#         print "$tail";
#     }
#     elsif ($variable) {

#     }

# }

# sub printVirtualsiteVariable {

#     my $variable  = $_[0];
#     my $delimiter = $_[1];
#     my $prefix    = $_[2];

# }

sub isInArray {

    my $keyword = $_[0];
    my $tm      = $_[1];
    my @array   = @$tm;
    my $each;

    foreach $each (@array) {
        if ( $each eq $keyword ) {
            return 1;
        }
    }

    return 0;

}

sub verifyPath {
    
    my $path = $_[0];

    $path =~ s/^(\/.*)\/(|\S+)$/$1/g;
    verbose("verify path called for $path\n");
    if ( not stat($path)){
	verbose("creating path $path\n");
	system("mkdir -p $path");
    }
}

sub prepareForUserModeBuild {

# thing that are done here:
# 1. create a temporary directory for mln and clean it up
# 2. store a copy of mln in the directory
# 3. store a copy of the configuration file in the directory
# 4. Copy all the kernel modules so that they are accessible for the vm later on
# 5. Note down who will need what kernel modules
# 6. Note the cow-based hosts
# 7. Copy all the include-files
# 8. Copy all the plugins
    # 1:

    if ( not stat("$USER_MODE_TEMP_DIR") ) {
        verbose("Making new user_mode_build_dir\n");
        mkdir("$USER_MODE_TEMP_DIR")
          or die "Failed to make dir $USER_MODE_TEMP_DIR\n";
        mkdir("$USER_MODE_TEMP_DIR/modules");
    }
    elsif ($USER_MODE_TEMP_DIR) {
        print "cleaning up user_mode_build_dir\n";
        if ( stat("$USER_MODE_TEMP_DIR/mln") ) {
            system("$shell{'RM'} $USER_MODE_TEMP_DIR/mln");
        }
        if ( stat("$USER_MODE_TEMP_DIR/modules") ) {
            system("$shell{'RM'} -r $USER_MODE_TEMP_DIR/modules");
        }
    }

# 2:
# - it is either run directly, or from somwhere in the PATH how do i know which one?
    my $mln_command = $0;
    my $mln;

    if ( $mln_command =~ /\// ) {

        # we have a slash, and don't need the path
        $mln = $mln_command;
    }
    else {
        $mln = which($mln_command);
        chomp $mln;
    }

    if ( not $mln ) {
        die
          "ERROR: I can't identify what mln command was used: '$mln_command'\n";
    }

    verbose("$shell{'CP'} $mln $USER_MODE_TEMP_DIR\n");
    system("$shell{'CP'} $mln $USER_MODE_TEMP_DIR");

    # 3:
    verbose("writing config file $USER_MODE_TEMP_DIR\n");

    system("cp $CONFIGFILE $USER_MODE_TEMP_DIR/$PROJECT.mln");
    
    # if we read from STDIN, we need to write down the transcript instead
     open( F, ">$USER_MODE_TEMP_DIR/$PROJECT.mln" )
      or print STDERR
      "WARNING: Failed to open $USER_MODE_TEMP_DIR/$PROJECT.mln\n";
     printBlock($DATA_ROOT,"",F);
#    my $ct;
#    foreach $ct (@CONFIG_FILE_TRANSCRIPT) {
#        print F $ct;
#    }
#    print F "\n";
     close(F);
#    system("cat $USER_MODE_TEMP_DIR/$PROJECT.mln");
#    exit;
    # 4.
    my $each;
    foreach $each (@MODULE_DIRS) {
        verbose("$shell{'CP'} -r $each $USER_MODE_TEMP_DIR/modules\n");
        system("$shell{'CP'} -r $each $USER_MODE_TEMP_DIR/modules");
    }

    # ... and the default version:
    if ( stat("$DEFAULTS{MODULE_PATH}$DEFAULTS{KERNEL_VERSION}") ) {
        verbose(
"$shell{'CP'} -r $DEFAULTS{MODULE_PATH}$DEFAULTS{KERNEL_VERSION} $USER_MODE_TEMP_DIR/modules/\n"
        );
        system(
"$shell{'CP'} -r $DEFAULTS{MODULE_PATH}$DEFAULTS{KERNEL_VERSION} $USER_MODE_TEMP_DIR/modules/"
        );
    }

    # 5.
    open( KV, ">$USER_MODE_TEMP_DIR/$KERNEL_VERSION_LOOKUP" )
      or die "Failed to open $USER_MODE_TEMP_DIR/$KERNEL_VERSION_LOOKUP";
    foreach $each ( getHosts() ) {
	my $xen = getScalar("/host/$each/xen"); 
        if (  $xen or getArray("/host/$each/modules") ) {
            if ( $xen ){
		my $default_modules = $DEFAULTS{XEN_MODULES};
		$default_modules = "/lib/modules/" . assumeXenKernelVersion() unless $DEFAULTS{XEN_MODULES};
		my $version = $default_modules;
		$version =~ s/^\/.*\///g;
		
		print KV "$each " . $version . "\n";
#		print "copying $DEFAULTS{XEN_MODULES} $USER_MODE_TEMP_DIR/modules\n";
		system("$shell{'CP'} -r $default_modules $USER_MODE_TEMP_DIR/modules");
	    } else {
		print KV "$each " . getVariable( $each, 'kernel_version' ) . "\n";
	    }
        }

    }

    # 6.
    registerBatchFiles();

    # 7.
    foreach $each (@INPUT_FILES) {

        my $filename = $each;
        $filename =~ s/\//_/g;
        verbose("$shell{'CP'} -r $each $USER_MODE_TEMP_DIR/$filename\n");
        system("$shell{'CP'} -r $each $USER_MODE_TEMP_DIR/$filename");
    }

    # 8.
    mkdir("$USER_MODE_TEMP_DIR/plugins");    
    foreach $each (keys %PLUGIN_LIST){
	verbose("$shell{'CP'} -r $PLUGIN_LIST{$each} $USER_MODE_TEMP_DIR/plugins\n");
	system("$shell{'CP'} -r $PLUGIN_LIST{$each} $USER_MODE_TEMP_DIR/plugins");
	
    }
}

sub readKernelVersions {

    open( KV, "/tmp/mln/$KERNEL_VERSION_LOOKUP" );

    my $l;
    while ( $l = <KV> ) {

        chomp $l;

        my @line = split /\s+/, $l;

        #	print "Reading $l\n";
        $KERNEL_VERSION_TABLE{ $line[0] } = $line[1];

    }

}

sub userModeConfigure {

    my $hostlist;
    my $each;
    my $cows_served;
    my $batch_command;

    my @batch_hosts;
    if ( $RECONFIGURE and @RECONFIGURE_HOST_LIST ) {
	@batch_hosts = @RECONFIGURE_HOST_LIST;
    } else {
	@batch_hosts = getBatchHosts(1);
    }
    my $ubd_devices;
#    print "userModeCOnfigure called\n";
    #    print "Number of hosts for batch 1: $#batch_hosts($BATCH_COUNTER)\n";
    if ( ( $#batch_hosts + 1 ) > 0 ) {
        foreach $each (@batch_hosts) {
	
	    print "adding $each to hostlist\n";
            if ( getScalar("/host/$each/cow_filesystem") ) {
                $ubd_devices .= "ubd"
                  . getUbdDevice( 1, $each )
                  . "=$IMAGEDIR/$each,$IMAGEDIR/"
                  . getScalar("/host/$each/cow_filesystem" ) . " ";
            }
            else {
                my $lvm = getScalar("/host/$each/lvm");
		if ( $lvm ){
		    my $vg = getScalar("/host/$each/lvm_vg");
		    $vg = $DEFAULTS{'MLN_VG'} if not $vg;
		    $ubd_devices .=
		      "ubd" . getUbdDevice( 1, $each ) . "=/dev/$vg/$each.$PROJECT ";
		} else {
		    $ubd_devices .=
		      "ubd" . getUbdDevice( 1, $each ) . "=$IMAGEDIR/$each ";
		}
            }
            $hostlist .= $each . ":";
            $cows_served++;
        }
    }
    else {
        return;
    }

    my $conf = $CONFIGFILE;
    $conf =~ s/^.*\///g;
    verbose("conf: $conf\n");

    my $fs = getLatestTemplate($USER_MODE_COPY_FS);

    my $cowfile = "$USER_MODE_TEMP_DIR/debian.cow";
    system( $shell{'MKCOW'} . " $cowfile $TEMPLATEDIR/$fs" );

    # this command is run inside the virtual machine
    my $mln_command = "build ";

    if ($UPGRADE) {
        $mln_command = "upgrade ";
    }

    if ($SERVICE_HOST) {
        $mln_command = "-L $SERVICE_HOST " . $mln_command;
    }

    $batch_command =
      $mln_command . "-C -f /tmp/mln/$PROJECT.mln -h $hostlist -b 1";

    my $divert_output = " con=pty con1=fd:0,fd:2 ";
    my $silence       = " QUIET=1 1>/dev/null";

    #    my $silence = " QUIET=1";
    if ($VERBOSE) {

        $divert_output = "";
        $silence       = "";

    }

    verbose("mln_command: $mln_command\n");
    my $command =
"$shell{'LINUX'} $divert_output mem=42M ubd0=$cowfile,$TEMPLATEDIR/$fs $ubd_devices project=$PROJECT_PATH files=$FILES_PATH mln=$USER_MODE_TEMP_DIR mln_command=\\\"$batch_command \\\" $silence ";

    out("+---> STARTING VM FOR FILESYSTEM CONFIGURATION (1 of $BATCH_COUNTER) \n");
    verbose("command: $command\n");
    system("$command");

    if ( $BATCH_COUNTER > 1 ) {

        #	print "Preparing for more batches\n";
        my $i;
        for ( $i = 2 ; $i <= $BATCH_COUNTER ; $i++ ) {
            @batch_hosts = getBatchHosts($i);
            if ( ( $#batch_hosts + 1 ) > 0 ) {
                out("+---> STARTING VM FOR FILESYSTEM CONFIGURATION ($i of $BATCH_COUNTER) \n");

                $ubd_devices = "";
                $hostlist    = "";

                foreach $each (@batch_hosts) {

                    #	    print "adding $each to hostlist\n";
                    if ( getScalar( "/host/$each/cow_filesystem") ) {
                        $ubd_devices .= "ubd"
                          . getUbdDevice( $i, $each )
                          . "=$IMAGEDIR/$each,$IMAGEDIR/"
                          . getVariable( "/host/$each/cow_filesystem" ) . " ";
                    }
                    else {
			my $lvm = getScalar("/host/$each/lvm");
			if ( $lvm ){
			    my $vg = getScalar("/host/$each/lvm_vg");
			    $vg = $DEFAULTS{'MLN_VG'} if not $vg;
			    $ubd_devices .=
			      "ubd" . getUbdDevice( 1, $each ) . "=/dev/$vg/$each.$PROJECT ";
			} else {
			    
                        $ubd_devices .= "ubd"
			      . getUbdDevice( $i, $each )
			      . "=$IMAGEDIR/$each ";
			}
                    }

#		    $ubd_devices .= "ubd" . getUbdDevice($i,$each) . "=$IMAGEDIR/$each,$IMAGEDIR/" . getVariable($each,'cow_filesystem') . " ";
                    $hostlist .= $each . ":";
                    $cows_served++;
                }

                $batch_command =
                  $mln_command
                  . "-C -f /tmp/mln/$PROJECT.mln -h $hostlist -b $i ";

                verbose("mln_command: $mln_command\n");

                my $command =
"$shell{'LINUX'} $divert_output mem=42M ubd0=$cowfile,$TEMPLATEDIR/$fs $ubd_devices project=$PROJECT_PATH files=$FILES_PATH mln=$USER_MODE_TEMP_DIR mln_command=\\\"$batch_command\\\" $silence ";

                system("$command");

            }

        }
    }

}

sub verbose {

    print $_[0] if $VERBOSE;

}

sub cleanUpUserModeBuild {

    my $conf = $CONFIGFILE;
    $conf =~ s/^.*\///g;

    system("$shell{'RM'} -r $USER_MODE_TEMP_DIR");

}

sub checkIfAnyAreUp {

    my $host;

    foreach $host ( getHosts() ) {
        if ( checkIfUp($host) ) {
            return 1;
        }
    }
    return 0;
}

# From version 0.82b9 and on, status assumes to be distributed. 
# It can be toggled off using the -R option
#
#


sub printStatus {
    my $opt_string = 'Cudp:h:qs:rR';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    $COLORS = 1 if $opt{C};
    my $singleproject = $opt{p};
    my $singlehost = $opt{h};
    my $up = 1 if $opt{u};
    my $down = 1 if $opt{d};
    $QUIET = 1 if $opt{q};
    my $singleswitch = $opt{s};
    my $persistent = $opt{R};
    my $distributed = 1 unless $SPAWNED_REMOTELY;
    
    
    my $amountTested;
    my $amountOK;
    my @return;
    ($amountTested,$amountOK,@return) = getStatus($singleproject,$singlehost,$up,$down,$QUIET,$singleswitch,$distributed,$persistent);
#    print "at: $amountTested, ok: $amountOK\n";
    foreach (@return){
	out("$_\n");
    }
#    print "ammount tested: $amountTested, ammount OK: $amountOK\n";
    if ( $amountTested == $amountOK ) {
	exit(0);
    } elsif ( $singleproject or $singlehost ) {
	exit(1);
    } elsif( $up ) {
	if ( $amountOK > 0 ){
	    exit(0);
	} else {
	    exit(1);
	}
    } elsif ( $down ) {
	if ( $amountOK == 0 ){
	    exit(0);
	} else {
	    exit(1);
	}
    }
}

####################
#
# monitor persistent projects will automatically test for persistent projects and 
# boot virtual machines which are down
####################
sub monitorPersistentHandler {
    my $opt_string = 'Cudp:h:qs:rS:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    $COLORS = 1 if $opt{C};
    my $singleproject = $opt{p};
    my $singlehost = $opt{h};
    my $up = 1 if $opt{u};
    my $down = 1 if $opt{d};
    $QUIET = 1 if $opt{q};
    my $singleswitch = $opt{s};
    my $persistent = $opt{R};
    my $distributed = 1 unless $SPAWNED_REMOTELY;
    
    my $switch = $opt{S};
    monitorPersistent($opt{C},$opt{u},$opt{d},$opt{p},$opt{h},$opt{q},$opt{s},$opt{r},$opt{S});
    
}


sub setPersistentHandler {
    
    my $opt_string = 'p:S:q';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
    if ( not ( $opt{p} and $opt{S} and ( $opt{S} eq "on" or $opt{S} eq "off"))){
	out("Usage: mln set_persistent -p <project> -S ( on | off )\n");
	exit 1;
    }
    setPersistent($opt{p},$opt{S},$opt{q});        
}

sub setPersistent {
    my $project = $_[0];
    my $state = $_[1];
    my $origquiet = $QUIET;
    $QUIET = $_[2];
    my @file;
    my $set;
    if ( not stat("$PROJECT_PATH/$project")){
	out("Project $project non-existent\n");
	return;
    }
    if (stat("$CHECK_PERSISTENT_FILE")){
	open(FILE,"$CHECK_PERSISTENT_FILE") or warn "Failed to open $CHECK_PERSISTENT_FILE\n";


	while ( my $line = <FILE> ) {
	    chomp($line);
	    if ( $line =~ /^persistent $project/ ) {
		if ( $state eq "off" ){
		    out("Setting persistent 'off' for project $project\n");		
		} else {
		    if ( $state eq "on" ){
			out("Project $project already persistent\n");
		    }
		    push(@file,$line ."\n");
		    $set = 1;
		}
	    } else {
		push(@file,$line . "\n");
	    }
	 
	}
	close(FILE);
    }
    
    if ( (not $set) and $state eq "on"){
	push(@file,"persistent $project\n");
	out("Setting persistent 'on' for project $project\n");
    }
    open(FILE,">$CHECK_PERSISTENT_FILE") or warn "Failed to open $CHECK_PERSISTENT_FILE\n";
    foreach ( @file ){
	print FILE $_;
    }
    close(FILE);
    $QUIET = $origquiet;
}

sub monitorPersistent {
    $COLORS = 1 if $_[0];
    my $up = 1 if $_[1];
    my $down = 1 if $_[2];
    my $singleproject = $_[3];
    my $singlehost = $_[4];
    $QUIET = 1 if $_[5];
    my $singleswitch = $_[6];
    my $persistent = $_[7];
    my $switch = $_[8];
    my @message_queue;
    # Default is to only do it locally
    my $distributed = 0;
    $distributed = 1 unless $SPAWNED_REMOTELY;
#    my $distributed = 0;

    if ( $switch eq "on" ){
	if ( not stat("$CHECK_PERSISTENT_HINT") ){
	    out("Enabling automatic reboot for persistent projects\n");
	    out("Run 'mln check_persistent' to perform the actual check\n");
	    out("Suppress this message using 'mln check_persistent -S on -q'\n");
	    system("touch $CHECK_PERSISTENT_HINT");
	    return 0;
	} else {
	    out("Automatic reboot for persistent projects is already enabled\n");
	    out("Run 'mln check_persistent' to perform the actual check\n");
	    out("Suppress this message using 'mln check_persistent -S on -q'\n");
	    return 1;	    	    	    
	}
    } elsif ( $switch eq "off" ){
	if ( stat("$CHECK_PERSISTENT_HINT") ){
	    out("Disabling automatic reboot for persistent projects\n");
	    out("Running 'mln check_persistent' will have no effect\n");
	    out("Suppress this message using 'mln check_persistent -S off -q'\n");
	    system("rm $CHECK_PERSISTENT_HINT");
	    return 0;   	
	} else {
	    out("Automatic reboot for persistent projects is already disabled\n");
	    out("Running 'mln check_persistent' will have no effect\n");
	    out("Suppress this message using 'mln check_persistent -S off -q'\n");
	    return 1;	    
	}

    } elsif ( $switch ){
	out("use '-S on' or '-S off'\n");
	exit 2;
    }
    
    if ( not stat("$CHECK_PERSISTENT_HINT")){
	out("Checks are currently disabled\n");
	out("Run 'mln check_persistent -S on' to enable checks\n");
	out("Use '-q' to suppress this message\n");
	exit 1;
    }
    
    my $amountTested;
    my $amountOK;
    my @return;
#    print "before getstatus\n";
    ($amountTested,$amountOK,@return) = getStatus($singleproject,$singlehost,$up,$down,$QUIET,$singleswitch,$distributed);
#    print "at: $amountTested, ok: $amountOK\n";
    my %persistent_projects;
    my %restarted_projects;
    %persistent_projects = getPersistentProjects();
    my $pr_count;
    foreach my $statline (@return){
#	print "got return: $statline\n";
#	out("$_\n");
	if ( $statline =~ /(\S+) host (\S+) down/ ){
#	    print "checking $1 for persistence\n";
	    if ( $persistent_projects{$1} ){
#		print "scheduling $1 for restart ($2)\n";
		push(@message_queue,"$1 host $2 restarted");
		$restarted_projects{$1} = 1;
		$pr_count++;
	    }
	}	
    }
    my $wait = 3;
    if ( $pr_count > 5 ){
	out("More than 5 projects are restarted, increasing wait time to 6 seconds\n");
	$wait = 6;
    }
    foreach ( keys %restarted_projects ){
	startProject($_,"","",$wait,not $distributed);
	sleep $wait;
    }
    foreach (@message_queue ){
        out("$_\n");
    }
    
    if ( %NOTIFICATION ){
	# restarting a persistent project will cause a warning
	if ( %restarted_projects and $NOTIFICATION{'warning'} ){
	    my $message;
	    foreach (@message_queue ){
		$message .= "$_,";
	    }
	    $message =~ s/,$//;
	    my $command = $NOTIFICATION{'warning'};
	    $command =~ s/^(.*)MESSAGE_HERE(.*)$/$1$message$2/;
	    verbose("running command: $command\n");
	    system("$command");
	    
	} elsif ( not %restarted_projects and $NOTIFICATION{'ok'} )  {
	    my $message = "All persistent projects UP";
	    my $command = $NOTIFICATION{'ok'};
	    $command =~ s/^(.*)MESSAGE_HERE(.*)$/$1$message$2/;
	    verbose("running command: $command\n");
	    system("$command");	    
	}		
    }
    
#    print "ammount tested: $amountTested, ammount OK: $amountOK\n";
    if ( $amountTested == $amountOK ) {
	exit(0);
    } elsif ( $singleproject or $singlehost ) {
	exit(1);
    } elsif( $up ) {
	if ( $amountOK > 0 ){
	    exit(0);
	} else {
	    exit(1);
	}
    } elsif ( $down ) {
	if ( $amountOK == 0 ){
	    exit(0);
	} else {
	    exit(1);
	}
    }
}


######################
# This routine fetches persistent projects from /etc/mln/admin
# and returns a hash
#
######################

sub getPersistentProjects {
    my %pers;
#    print "getPersistentProjects called\n";
    open(FILE,"/etc/mln/admin"); 
    if (FILE){
	foreach (<FILE>){
	    if ( not $_ =~ /\s*#/ ){
		if ( $_ =~ /persistent (\S+)/ ){
#		    print "registering project $1 as persistent\n";
		    $pers{$1} = 1;	    
		}
	    }
	}
	return %pers;
    }
}

######################
#  This method collects status on all the projects and hosts. It also has the ability
#  to collect status information remotely on other machines. What we need to do then, is 
#  create a batch of who to connect to about what, so that only one query is sent per remote 
#  host.
#
#########
sub getStatus {

    debug("getStatus called\n");
#    print "getstatus called\n";

    my $singleproject = $_[0];
    my $singlehost = $_[1];
    my $up = 1 if $_[2];
    my $down = 1 if $_[3];
    $QUIET = 1 if $_[4];
    my $singleswitch = $_[5];
    # this is enabled if we are to query the other hosts as well
    my $distributed = $_[6];
    my $persistent = $_[7];
    
    my %all_vms;
    # this is where we store the queries. 
    my %query_batch = ();
    my $temp_root;
    
    my $project_counted;
    my $amountTested;
    my $amountOK;
    my @return;
    # 1. find all projects
    my @projects;
    @projects = `ls -d $PROJECT_PATH/* 2>/dev/null`;

    if ( not $singleproject){
	$DAEMON_USED_MEMORY = 0;
    }
    $NUM_RUNNING_PROJECTS = 0;
    $NUM_RUNNING_HOSTS = 0;

    my $project;
    my %persistent_projects;
    my %restarted_projects;
    if ( $persistent ){
	%persistent_projects = getPersistentProjects();
    }
    # this is a crude check to see if we are root:
    my $xm = `which xm 2>/dev/null`;
    
    if ( $xm ){
#	print "filling XM_LIST_CACHE\n";
	@XM_LIST_CACHE = `$shell{'XM'} list 2>/dev/null`;
	@IFCONFIG_CACHE = `ifconfig`;
	%RESOURCE_TABLE = ();
	%RESOURCE_DELAY_TABLE = ();
	@DEVICE_MAPPING_CACHE = ();
    }
    foreach $project (@projects) {

        chomp $project;

	my $shortname = $project;
	$shortname =~ s/.*\/(\S+)/$1/;
#	print "checking project: $shortname ($persistent_projects{$shortname})\n";
#	print "testing: '$project'\n$PROJECT_PATH/$singleproject\n";
        if ( not $project =~ /lost\+found/ and 
	    ( $singleproject and $PROJECT_PATH . "/" . $singleproject eq $project or not $singleproject ) and 
	    ( ( $persistent and $persistent_projects{$shortname}) or not $persistent )  ) {

		my $pname = $shortname;
		
#            	out ("project: $pname\n");
		chomp $pname;
		
		# make sure we uptade the project before we test the status

		if ( updateProjectVersion($pname) == 0 ){
		    out("Version of $pname could not be verified. Skipping\n");
		    next;
		}
#		print "Project verified\n";

            # 2. for every project, find all hosts
            if ( stat("$PROJECT_PATH/$pname/${pname}.mln") ) {
#                my @hosts = `ls -f $PROJECT_PATH/$pname/images/* 2>/dev/null`;
		$temp_root = buildDataTree("$PROJECT_PATH/$pname/${pname}.mln");
#		print "done building tree\n";
		my %switches;
		
                my $host;
		my @hosts = getHosts($temp_root);
	        %chunked_hosts = ();
		my @project_chunks;
		my $chunk_counter;
		
		foreach $host (@hosts){
		    my $if;
		    my %ifs = getHash("/host/$host/network",$temp_root);
		    foreach $if (keys %ifs) { 
			my $switch = getScalar("/host/$host/network/$if/switch",$temp_root);
			if ( $switch ) {
			    $switches{$switch}{$host} = 1;
			}
		    }
		}

                # - Figure out if they are running
		$project_counted = 0;
                foreach $host (@hosts) {
                    chomp $host;
                    $host =~ s/.*\///g;
                    if ( not $host =~ /^swap_/ and ( $singlehost and $singlehost eq $host or not $singlehost) ) {
#			print "checking out $host\n";

			
			# we check if this will be a remote query or not: 
			my $service_host = getScalar("/host/$host/service_host",$temp_root);
			if ( $SERVICE_HOST and $service_host and $service_host ne $SERVICE_HOST ) {
			   
			    push(@{$query_batch{$service_host}},"$pname $host");
			    verbose("adding to batch list: $pname $host\n");
			
			} else {
			    my $hostcheck = checkIfUp( $host, $pname, $temp_root ); 

			    if ( $hostcheck =~ /^1(|.*)$/g ) {
				$amountTested++;
				my $message = $1;

				if ( not $project_counted ) {
				    $NUM_RUNNING_PROJECTS++;
				    $project_counted = 1;
				}
				$NUM_RUNNING_HOSTS++;
				if ( not $down ) {
#				print "$pname host $host up\n";
				    if (not $persistent){
					push(@return,"$pname host $host up$message");
				    }
				    # $STATUS_TABLE{$pname}{"host"}{$host} = "up";
				    $all_vms{"$host.$pname"} = 1;
				    if ( not $singleproject ){
					my $memory = getScalar("/host/$host/memory",$temp_root);
					$memory = $DEFAULTS{'MEMORY'} unless $memory;
					
					$memory =~  s/(\d+)M/$1/;
					$DAEMON_USED_MEMORY += $memory;
				    }
				    $amountOK++;
				    
				    # figure out where the filesystem is stored				
				    my @key = grep ( /^($host\.$pname)\s+\S+\s+/,@XM_LIST_CACHE );
				# if LVM on VG
				    my $lvm = getScalar("/host/$host/lvm",$temp_root);
				    my $filepath = getScalar("/host/$host/filepath",$temp_root);
				    chomp($key[0]);
#				print "key: $key[0]\n";
				    if ($lvm){
#				    print "LVM\n";
					my $vg = getScalar("/host/$host/vg",$temp_root);
					$vg = $DEFAULTS{'MLN_VG'} if not $vg;
					
					if ( $SAN_PATH{$vg} ){
					    # if SAN
					    $RESOURCE_TABLE{$key[0]} = "SAN:$vg";
#					print "SAN:$vg";
					} else {
					    # else 
					    $RESOURCE_TABLE{$key[0]} = "LOCAL:/dev/$vg";
#					print "LOCAL:/dev/$vg";
					}
				    } elsif ( $filepath ){
					# if Filepath 
					
				   # if SAN
#				    print "file\n";
					if ( $SAN_PATH{$filepath}){
					    $RESOURCE_TABLE{$key[0]} = "SAN:$filepath";
#					print "SAN:$filepath";
					} else {
					    # else
					    $RESOURCE_TABLE{$key[0]} = "LOCAL:" . findHardDriveFor("$filepath");
#					print "LOCAL:" . findHardDriveFor("$PROJECT_PATH/$PROJECT/images");
					}
				    
				    } else {
					
					# ask the plugins for an answer:
					# getDiskResource
					my $resource = "";
					foreach my $plugin (keys %PLUGIN_LIST){
					    
					    my $subcall = $plugin . "_getDiskResource"; 
					    if ( defined(&$subcall) and not $resource ){

						$resource = &$subcall($host,$pname,$temp_root);
						print "Disk resource from plugin: $resource\n" if $resource;
					    }
					    
					}

					if ( $resource ){
					    $RESOURCE_TABLE{$key[0]} = $resource;
					    
					} else {
					    $RESOURCE_TABLE{$key[0]} = "LOCAL:" . findHardDriveFor("$PROJECT_PATH/$pname/images");
					}
					
#				    print "LOCAL:" . findHardDriveFor("$PROJECT_PATH/$PROJECT/images");
					
				    }
				    $RESOURCE_DELAY_TABLE{$key[0]} = getResourceDelay($RESOURCE_TABLE{$key[0]});
#				print "storing: $RESOURCE_TABLE{$key[0]}\n";
			    }
				
			    
			    if ( not $chunked_hosts{$host} ){
				$chunked_hosts{$host} = 1;
				my @switches_in_chunk;
				my @vms_in_chunk;

#				print "checking chunk from $host.$pname\n";
				push(@vms_in_chunk,"$host");
				
				my %nics = getHash("/host/$host/network",$temp_root);
				foreach my $nic (keys %nics)
				{
#				    print "\t\tFound NIC $nic\n";
				    # check if the nic is connected to a switch
				    if ( $nics{$nic}{"switch"})
				    {

					my $switch = $nics{$nic}{"switch"};
					addNetworkConnection($host . "." . $pname,$nic,$switch);
					push(@switches_in_chunk,$switch);
					
#					print "\t\t\tNIC $nic is conencted to " . $switch ."\n";
					my @hosts_on_lan = keys %{$switches{$switch}};
					foreach my $host_on_lan (@hosts_on_lan)
					{
					    if ( not $chunked_hosts{$host_on_lan} ){
						$chunked_hosts{$host_on_lan} = 1;

						push(@vms_in_chunk,"$host_on_lan");
						foreach (get_chunk_tree($host_on_lan,$pname,\%switches,$temp_root,$switch)){
#						    print "adding $_ to chunk\n";
						    push(@vms_in_chunk,$_);
						}
					    }
					    #			    get_chunk_tree_from_vm($host_on_lan,$project,$switch,\%vms,\@switches_in_chunk,\@vms_in_chunk);
					}
				    } else {
					addNetworkConnection($host . "." . $pname,$nic,"XEN_LAN");
				    }
				}
#				my $servicehostip = getScalar("/host/$host/service_host");
#				push(@project_chunks,{'hosts' => \@vms_in_chunk,
#							 'switches' => \@switches_in_chunk,
#							 'servicehostip' => $servicehostip,
#							 'servicehostname' => $xenhosts{$servicehostip}{'hostname'}
#						     });
#				my $vm_counter =  0;
				my $chunk = "$pname : "; 

				foreach (@vms_in_chunk){
#				    print "vms in chunk: $_\n";
				    $chunk .= $_ . " : ";
		#		    $project_chunks[$chunk_counter][$vm_counter++] = $_;
				}
		#		$chunk_counter++;
#				print "saving $chunk\n";
				push(@chunk_list,$chunk);
			    }

			    
			
			    } elsif ( $hostcheck =~ /^0(|.*)/g ) {
				my $message = $1;
				
				$amountTested++;
				if ( not $up ){
#				print "$pname host $host down\n";
				    
				    if ( $persistent ){
					push(@return,"$pname host $host restarted$message");
					if ( not $restarted_projects{$pname}){
#				    $STATUS_TABLE{$pname}{"host"}{$host} = "restarted";
					    startProject($pname,"","",5,1);
					    $restarted_projects{$pname} = 1;
					} 
				    } else {
					push(@return,"$pname host $host down$message");
#				    $STATUS_TABLE{$pname}{"host"}{$host} = "down";
				    }
				    
#				out( "down\n", "cyan" );
				} else {
				    push(@return,"$pname host $host down$message");
				}
			    }
			}
                    }
                }
		
		# $chunks{$pname} = @project_chunks;
            }
		

		
		
            # 3. for every project, find all switches
		
	    my @switches = `ls -f $PROJECT_PATH/$pname/start_* 2>/dev/null`;
            my $switch;

            foreach $switch (@switches) {
                chomp $switch;

                $switch =~ s/.*\///g;

                if ( not $switch =~ /start_(\d|\d\d)_.*/ ) {
		    
		    $switch =~ s/start_(.*)\.sh/$1/;
		    
		    if ( $singleswitch and $singleswitch eq $switch or not $singleswitch ) {
			my $switch_up_via_plugin;

			if ( %PLUGIN_LIST ){			    
			    my $plugin;
			    foreach $plugin (keys %PLUGIN_LIST){
				
				my $subcall = $plugin . "_checkIfSwitchIsUp"; 
#	    print "calling $subcall\n";
				verbose("calling $subcall\n");
				if ( defined(&$subcall) and not $switch_up_via_plugin ){
				    $switch_up_via_plugin = &$subcall($switch,$pname);
				}
				
			    }
			}    
			if ( $switch_up_via_plugin == 1 ){
			    push(@return,"$pname switch $switch up");
			    $amountOK++;
			} elsif ( $switch_up_via_plugin == -1 ){
			    if ( not $persistent){
				push(@return,"$pname switch $switch down");
			    }
			}
			$amountTested++;
			
			# - Figure out if they are running
			if ( not $switch_up_via_plugin ){
			    if ( stat("$PROJECT_PATH/$pname/network/$switch") == 1 ) {
				if ( not $down) {
				    if ( not $persistent){
					push(@return,"$pname switch $switch up");
				    }
#				out( "up\n", "green" );
				}
				$amountOK++;
			    }
			    else {
				if ( not $up ) {
				    if ( not $persistent){
					push(@return,"$pname switch $switch down");   
				    }
#				out( "down\n", "cyan" );
				}
			    }
			}
		    }
		}
            }
	    }
    }
    
#    if ( @XM_LIST_CACHE ){
#	@XM_LIST_CACHE = ();
#    }
    if ( $distributed and not $persistent){
	# lets send out queries to the other servers
	my $server;
	my @TICKETS;	
	foreach $server ( keys %query_batch ){
#	    print "connecting to $server\n";
	    # 1 connect to server
	    my $sock = new IO::Socket::INET(
		PeerAddr => $server,
		PeerPort => 34001,
		Proto    => 'tcp');
	    
	    $sock or (print "no socket to $server: $!\n" and next);
	    
	    # 2 send list of projects and hosts
	    my $list;
	    foreach ( @{$query_batch{$server}}) {
		$list .= $_ .",";
	    }
	    
	    print $sock "status_request:$list\n";
	    
	    my $ticket = <$sock>;
#	    print "Got reply $ticket";
	    while ( not $ticket =~ /TICKET:(\d+)\n/ ){
		if ( $ticket =~ /project_version_request:(\S+):/ ){	
		    my $version = getProjectVersion($1);
		    my $project = $1;
#		    print "version is $version\n";
		    print $sock "project_version:$project:$version\n";
		    $ticket = <$sock>;
		    if ( $ticket eq "GET-PROJECT-FILE\n" ){
			open(FILE,"$PROJECT_PATH/$project/$project.mln");
			foreach (<FILE>){
			    print $sock "$_";
			}
			print $sock "OUTPUT-END\n";
			
		    } elsif ( $ticket =~ /GOODBYE\n/ ) {
			print "Version OK\n";
		    }
		}
		print "Getting a new reply\n";
		$ticket = <$sock>;
#		print "Got reply $ticket";
		last if not $ticket;
								      
	    }
	    if ( $ticket =~ /TICKET:(\d+)\n/ ){
		$ticket = $1;
		my $t = new buildTicket;
		$t->ticket($ticket);

		$t->host($server);
		$t->port(34001);
		push(@PENDING_TICKETS,$t);	
	    } else {
		print "ERROR: $server gave wrong output: $ticket\n";
	    }			    
	}
	my @output = collectTickets(2,1); 
	# 3 await response 
	# 4 add response to @return
	my $reply;
	foreach $reply (@output){
	    debug("ouput from remote daemon: $reply\n");
	    my $list;
	    foreach $list (split /,/,$reply ){
	#	print "adding after tickets\n";
		chomp $list;
		if ( $list ){
		    $amountTested++;
		    debug("got result back: '$list'\n");
		    push(@return,$list);
		    if ( $list =~ / up$/ ){
			verbose("VM reported to be up\n");
			$amountOK++;	
		    }
		}
	    }
	}
    }

    @STATUS_ARRAY = @return;
    return ($amountTested,$amountOK,@return);

}

sub getResourceDelay {
    my $resource = $_[0];
    my $delay;
    $resource =~ s/^.*\/dev.*path\/(.*$)/$1/;
    debug("Resource delay for '$resource'\n");
    if ( not @DEVICE_MAPPING_CACHE ){
	@DEVICE_MAPPING_CACHE = `ls -l /dev/disk/by-path`;
    }
    # look for disk mapping;
    my $device;
    foreach my $line (@DEVICE_MAPPING_CACHE ){
#	print "checking: $line";
	if ( $line =~ /$resource.* ..\/..\/(\S+)/ ){
	    debug("Found mapping: $1\n");
	    $device = $1;
	    last if $device;
	}
    }
    open(DISKSTATS,"/proc/diskstats");
    while ( my $line = <DISKSTATS> ){
	if ( $line =~ /$device / ){
	    my @array = split /\s+/,$line;
	    $delay = $array[13];

	}
	
    }
    close(DISKSTATS);
    debug("Returning delay: $delay\n");
    return $delay;
}

sub findHardDriveFor {
#    print "find harddrive for\n";
    my @drive = `df $_[0]`;
    $drive[1] =~ s/^(\S+)\s+.*$/$1/g;
    chomp $drive[1];    
    return $drive[1];    
}

sub get_chunk_tree {
 # ($host_on_lan,$pname,\%switches,$temp_root,$switch);
    my $host = $_[0];
    my $project = $_[1];
    my $tm = $_[2];
    my %switches = %$tm;
    my $temp_root = $_[3];
    my $origin = $_[4];
    
    my @hosts;
    my %nics = getHash("/host/$host/network",$temp_root);
    if ( scalar (keys %nics) > 1 ){
	foreach my $nic (keys %nics){
	    my $switch = getScalar("/host/$host/network/$nic/switch",$temp_root);
	    addNetworkConnection($host . "." . $project ,$nic,$switch);
	    if ( $switch and $switch ne $origin ){
		my @neighb = keys %{$switches{$switch}};
		foreach (@neighb){
		    if ( not $chunked_hosts{$_}){
			my $new = $_;
			# print "adding $new to chunk\n";
			$chunked_hosts{$new} = 1;
			push(@hosts,"$new");
			foreach ( get_chunk_tree($new,$project,\%switches,$temp_root,$switch) ){
			    push(@hosts,$_);
			}
		    }
		}
	    }
	}
	return @hosts;
    } else {
	foreach my $nic (keys %nics){
	    my $switch = getScalar("/host/$host/network/$nic/switch",$temp_root);
	    addNetworkConnection($host . "." . $project ,$nic,$switch);
	}
	return @hosts;
    }
}
sub addNetworkConnection {
#    print "0: $_[0],1: $_[1], 2: $_[2]\n";
    my $switch = $_[2];
    $switch = "XEN_LAN" unless $switch;
    my $nicTraffic = getNicBytesTransferred($_[0],$_[1]);
    if ( not $NETWORK_TABLE{$_[0]} =~ /$_[1]:$switch/ ){
#	print "$_[0] -> $_[1]:$switch:$nicTraffic;\n";
	$NETWORK_TABLE{$_[0]} .= "$_[1]:$switch:$nicTraffic;";
    }
}

sub getNicBytesTransferred {
    my $vm = $_[0];
    my $nic = $_[1];
    
    my @key = grep ( /^$vm\s+(\d+)\s+/,@XM_LIST_CACHE );
    $key[0] =~ /^$vm\s+(\d+)\s+/;
    my $id = $1;
    my $nicId = $nic;
    $nicId =~ s/eth(\d+)/$1/;
    my $i;
#    print "$vm -> ID: $id, nicId: $nicId\n"; 
    for ($i = 0; $i <= @IFCONFIG_CACHE; $i++){
	if ( $IFCONFIG_CACHE[$i] =~ /^vif$id\.$nicId / ){
	    my $id = $1;
	    $i += 5;
	    my $rx = 0;
	    my $tx = 0;
	    if ( $IFCONFIG_CACHE[$i] =~ /RX bytes:(\d+) .*TX bytes:(\d+) /){
		$rx = $1;
		$tx = $2;

	    } elsif ( $IFCONFIG_CACHE[($i + 1)] =~ /RX bytes:(\d+) .*TX bytes:(\d+) /){
		$rx = $1;
		$tx = $2;
	    }
	    return "$tx:$rx";
#	    print "$id: $IFCONFIG_CACHE[$i]\n";
	}
    }
    return "0:0";
}

sub checkCpuHogHandler {
    
    my $opt_string = "s:qVwh:p:";
    getopts( "$opt_string", \my %opt ) or usage() and exit;
    my $singlehost = $opt{h};
    $QUIET = $opt{q};
    my @alerts;
    eval {require DBI; 1}; 
    
    verbose("database: $DEFAULTS{'db_name'}\n");
    my $dbh = DBI->connect("DBI:mysql:$DEFAULTS{'db_name'}",$DEFAULTS{'db_user'},$DEFAULTS{'db_password'});
    if ( $dbh ){

	if ( $singlehost ){
	    my %VM;
	    # get previous timestamp
	    my $get_last =  $dbh->prepare("SELECT value from Metainformation_MLN where variable='Previous_Update_UNIX';");
	    $get_last->execute();
	    my @array = $get_last->fetchrow_array();
	
	    my $previous_start = $array[0];
	    
	    # get last timestamp
	    my $get_last =  $dbh->prepare("SELECT value from Metainformation_MLN where variable='Last_Update_UNIX';");
	    $get_last->execute();
	    my @array = $get_last->fetchrow_array();
	
	    my $last_start = $array[0];
	    
#	    print "Previous update: $previous_start, last: $last_start. Diff: " . ( $last_start - $previous_start ) . "\n";
	    
	    # get the ID of the server
	    
	    my $check_query = "SELECT serverID FROM Servers AS s WHERE s.name = '$singlehost';";
	    my $server_status = $dbh->prepare($check_query);
	    $server_status->execute();
	    my @array = $server_status->fetchrow_array();
	    my $serverID = $array[0];
#	    print "ServerID = $serverID\n";	    	    
	    
	    # get all previous, fish out cpu
	    my $previous_present = $dbh->prepare("SELECT vmID_FK,cpuSeconds from State_VirtualMachine_Previous where serverID_FK = $serverID");
	    $previous_present->execute();
   
	    while(my($vmID,$cpusecs)=$previous_present->fetchrow_array()){ 
#		print "storing: $vmID and $cpusecs\n";
		$VM{$vmID} = $cpusecs;		
	    }
	    
	    
	    # get all last, fish out cpu
	    my $last_present = $dbh->prepare("SELECT vmID_FK,cpuSeconds from State_VirtualMachine_Last where serverID_FK = $serverID");
	    $last_present->execute();
   
	    while(my($vmID,$cpusecs)=$last_present->fetchrow_array()){ 
		# for all vms, compare
		my $secdiff = $cpusecs - $VM{$vmID};
		my $utilization = $secdiff / ( $last_start - $previous_start );
#		print "$vmID diff: $secdiff in " . ( $last_start - $previous_start ) . "\n";
		if ( $utilization > 0 and $utilization < 1.01 and $utilization > $DEFAULTS{CPUHOG} ){
		    # get VM name
		    my $getVM = $dbh->prepare("SELECT name,projectID_FK from VirtualMachines where vmID = $vmID");
		    $getVM->execute();
		    my ($vmname,$projectID) = $getVM->fetchrow_array();
		    my $getProject = $dbh->prepare("SELECT name from Projects where projectID = $projectID");
		    $getProject->execute();
		    my ($projectname) = $getProject->fetchrow_array();
		    
		    
		    push(@alerts,"$vmname.$projectname ($vmID) has turned into a cpuhog!");
		    
		}
		
	    }
	    
	    foreach (@alerts){
		print "$_\n";
	    }
	    exit 1 if @alerts;
	}
	    
	 
	  
    } else {
	out("No database connecton.");
	exit 3;
    }
}

sub checkRemoteDaemonHandler {
    
    my $opt_string = 'h:qVw';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
    die "You must supply a hostname (-h <hostname>)\n" unless $opt{h};
    $QUIET = $opt{q};
    my $response = daemonIsRunning($opt{h});

    if ( $response ){
	if ( $opt{V} and $VERSION eq $response ){
	    out("MLN daemon is running on $opt{h}, version $response\n");
	    exit 0;
	} elsif ( $opt{V} and not $VERSION eq $response ){
	    # out("MLN daemon is running on $opt{h}, version $response\n");
	    if ( $opt{w}){
		out("Different version: $VERSION\n");
	    } else {
		out("Warning: remote version is different ($VERSION)\n");
	    }
	    exit 1;
	}
	out("MLN daemon is running on $opt{h}, version $response\n");
	exit 0;	
    } else {
	exit 2;
    }
    
}

sub connect_to_server {
    
    my $port = $_[1];
    $port = 34001 unless $port;
    my $sock = new IO::Socket::INET(
	PeerAddr => $_[0],
	PeerPort => $port,
	Proto    => 'tcp');
	    
    $sock or (print "no socket to $_[0]: $!\n" and return 0);
    return $sock;
   
}

sub daemonIsRunning {
    my $sock = new IO::Socket::INET(
	PeerAddr => $_[0],
	PeerPort => 34001,
	Proto    => 'tcp');
	    
    $sock or (print "no socket to $_[0]: $!\n" and return 0);
    print $sock "PING\n";
    my $reply = <$sock>;
    close ($sock);

    if ( $reply =~ /PONG:(\S+)\n/ ){
	return $1;
    }
    return 0;
}


sub checkCowFilesystems {

    my $each;

    foreach $each ( getHosts() ) {

        my $cow = getVariable( $each, 'cow_filesystem' );

        if ($cow) {

            $COW_COUNTER++;

            # we got a cow, now lets add it if it does not exist
            if ( !$COW_FILESYSTEMS{$cow} ) {

                my $new_cow = new CowFilesystem;

                $new_cow->size( getVariable( $each,     'size' ) );
                $new_cow->template( getVariable( $each, 'template' ) );

#		print("adding cow: $cow, " . $new_cow->size . ", " . $new_cow->template . "\n");
                $COW_FILESYSTEMS{$cow} = $new_cow;

            }
            else {

                if (
                    $COW_FILESYSTEMS{$cow}->size ne getVariable( $each, 'size' )
                  )
                {
                    die "Cow filesystem conflict ($cow) -> size \'"
                      . $COW_FILESYSTEMS{$cow}->size
                      . "\' != \'"
                      . getVariable( $each, 'size' ) . "\'\n";
                }
                if ( $COW_FILESYSTEMS{$cow}->template ne
                    getVariable( $each, 'template' ) )
                {
                    die "Cow filesystem conflict ($cow) -> template \'"
                      . $COW_FILESYSTEMS{$cow}->template
                      . "\' != \'"
                      . getVariable( $each, 'template' ) . "\'\n";
                }
            }
        }
    }
}

# ##
# # This method is outdated, since we try to put all hosts in a batch in order to avoid
# # hostfs bugs to cause errors.
# # We now use registerBatchFiles instead.
# ##

# sub registerCowFiles {

#     my $each;
#     my @devices;
#     my $cow_counter = 1;

#     # do we have any cows? Only proceed if.
#     #   print "Number of cows: $COW_COUNTER\n";
#     #   print "Opening: $USER_MODE_TEMP_DIR/cow_batch$BATCH_COUNTER\n";
#     return if ( $COW_COUNTER == 0 );

#     open( BATCH, ">$USER_MODE_TEMP_DIR/cow_batch$BATCH_COUNTER" )
#       or die "Failed to open: $USER_MODE_TEMP_DIR/cow_batch$BATCH_COUNTER\n";
#     foreach $each ( getBlockKeys("/host") ) {

#         my $cow = getVariable( $each, 'cow_filesystem' );

#         if ($cow) {

#             #	    print "$cow_counter $each\n";
#             print BATCH "$cow_counter $each\n";

#             if ( $cow_counter == $BATCH_SIZE ) {
#                 $BATCH_COUNTER++;
#                 close(BATCH);
#                 open( BATCH, ">$USER_MODE_TEMP_DIR/cow_batch$BATCH_COUNTER" );
#                 $cow_counter = 0;
#             }

#             $cow_counter++;

#         }
#     }
#     close(BATCH);
# }

# we use this method to put ALL hosts into
# batch files.

sub registerBatchFiles {

    my $each;
    my @devices;
    my $counter = 1;

    # do we have any cows? Only proceed if.
    #   print "Number of cows: $COW_COUNTER\n";
    #   print "Opening: $USER_MODE_TEMP_DIR/cow_batch$BATCH_COUNTER\n";
    #    return if($COW_COUNTER == 0 );

    open( BATCH, ">$USER_MODE_TEMP_DIR/batch$BATCH_COUNTER" )
      or die "Failed to open: $USER_MODE_TEMP_DIR/batch$BATCH_COUNTER\n";
    foreach $each ( getHosts() ) {

        #	my $cow = getVariable($each,'cow_filesystem');

        if ( not getScalar("/host/$each/service_host" )
                or getScalar("/host/$each/service_host" ) eq $SERVICE_HOST )
        {

            #	    print "$cow_counter $each\n";
            if ( ( $UPGRADE and getScalar("/host/$each",$DIFF) and not $LIVE_LIST{$each} )
                or not $UPGRADE )
            {
		print "adding $each to the batches\n";
                print BATCH "$counter $each\n";

                if ( $counter == $BATCH_SIZE ) {
                    $BATCH_COUNTER++;
                    close(BATCH);
                    open( BATCH, ">$USER_MODE_TEMP_DIR/batch$BATCH_COUNTER" );
                    $counter = 0;
                }

                $counter++;
            }

        }
    }

    #    print "BATCH_COUNTER: $BATCH_COUNTER\n";
    close(BATCH);
}

sub getUbdDevice {

    my $batch_number = $_[0];
    my $hostname     = $_[1];
    my $line;

    if ($USER_MODE_REC) {
        open( BATCH, "$USER_MODE_TEMP_DIR/batch$batch_number" )
          or die "failed to open: $USER_MODE_TEMP_DIR/batch$batch_number\n";
    }
    elsif ($CONFIGURE_HOSTS_ONLY) {
        open( BATCH, "/tmp/mln/batch$batch_number" )
          or die "failed to open: /tmp/mln/batch$batch_number\n";
    }

    while ( $line = <BATCH> ) {

        #	print "getUbdDevice lookup: $line";
        if ( $line =~ /(\d+) $hostname/ ) {
            close(BATCH);
            return $1;
        }

    }
    close(BATCH);

}

sub getBatchHosts {
    my $batch_number = $_[0];
    my $line;
    my @hosts;

    open( BATCH, "$USER_MODE_TEMP_DIR/batch$batch_number" ) or return @hosts;

    while ( $line = <BATCH> ) {
        chomp $line;

        #	print "GET BATCH HOSTS 1: $line\n";
        if ( $line =~ /(\d+) (.*)/ ) {

            #	    chomp $2;
            #	    print "GET BATCH HOSTS 2: $2\n";
            push( @hosts, $2 );

        }

    }
    close(BATCH);
    return @hosts;
}

# this method calls tune2fs in order to figure out wheter the filesystem template uses
# a journal or not.
sub detectExt3Journal {

    my $device = $_[0];
    if ( stat("$device")){
	my @output = `$shell{"TUNE2FS"} -l $device`;
	my $l;
	
	foreach $l (@output) {

	    if ( $l =~ /.*Filesystem features:.*has_journal.*/ ) {
		return "1";
	    }
	}
    }
    return 0;

}


sub handleVariable {
    my $tm = $_[0];
    my @line = @$tm;
    
    # we check for an assignement fo an variable:
    if ( $line[1] eq "=" ){
	$GLOBAL_VARIABLES{$line[0]} = getRestAsString(2,\@line);
	return @line;
    }
}

sub resolveHostnameVariables {
    my $root = $_[0];
    $root = $DATA_ROOT unless $root;
    
    my $host;
    foreach $host ( keys %{$root->blocks('host')->blocks}){
#	print "checking $host\n";
	my $value = getValue($host,"",$root);
	if ( $value ne $host ){
#	    print "detected variable: $value\n";
	    $root->blocks('host')->blocks($value,$root->blocks('host')->blocks($host));
	    delete ${$root->blocks('host')->blocks}{$host};
	}
    }    
#    print "resolve finished\n";
#    printBlock($root);
    return $root;
}

sub buildDataTree {
#    print "parsing file $_[0]\n";
    my $CONF = $_[0];
    return unless stat("$CONF");
#    print "file $CONF fount\n";
    #      if ( not $STDIN_MODE ) {
    #      open (CFILE,"$CONF") or die "Failed to open file $CONF\n";
    #      }
    my @line;
    my $root = new block;
    $root->name("test");
 
    my @line = getCLine($CONF);
    
    # we initialize certain sub-blocks like hosts and switches:
    # 
    $root->blocks('host',new block);
    $root->blocks('switch',new block);
    $root->blocks('superclass',new block);
    
    my $i = 0;    
    while ( not $line[0] eq "MLN_END" ) {
#        print "parser: $line[0]\n";

	if ( $line[0] eq "host" ) {
	    # we have a new host block!
#	    print "new host block: $line[0]\n";
	    if ( $line[1] eq "{" ) {
		$root->blocks('host',parseBlock());
	    } else {
		$root->blocks('host')->blocks($line[1],parseBlock());
	    }
	} elsif ( $line[0] eq "superclass" ) {
#	    print "new superclass block: $line[0]\n";
	    # we have a new superclass block!
	    if ( $line[1] eq "{" ) {
		$root->blocks('superclass',parseBlock());
	    } else {
		$root->blocks('superclass')->blocks($line[1],parseBlock());
	    }
	} elsif ( $line[0] eq "switch" ) {
	    # we have a new switch block!
#	    print "new switch block: $line[0]\n";
	    if ( $line[1] eq "{" ) {
		$root->blocks('switch',parseBlock());
	    } else {
		$root->blocks('switch')->blocks($line[1],parseBlock());
	    }
	} elsif ( $line[1] =~ /\{/ ) {
	    # we have a new host block!
#	    print "new block: $line[0]\n";
	    $root->blocks($line[0],parseBlock());
	} elsif ( $line[1] eq "=" ) {
#	    we have a new variable
	    $root->value($line[0],getRestAsString(2,\@line));
	    # we are not putting variable declarations into the array
#	    $root->array($i++,getRestAsString(0,\@line));
	} elsif ( not $line[1] =~ /\}/) {
#	    print "line: $line[0]\n";
	    if ( not $line[1] ) {
		$root->value($line[0],1);
	    } else {
		$root->value($line[0],getRestAsString(1,\@line));
	    }
	    debug("setting array[" . $i + 1 ." ] to " . getRestAsString(0,\@line) ."\n");
	    $root->array($i++,getRestAsString(0,\@line));
	} 
	@line = getCLine();
    }
 #   print "returning block: " . $root->name() ."\n";
    $MAIN_FILE_OPENED = 0;
    $root = resolveHostnameVariables($root);
#    printBlock($root);
    return $root;
}

sub parseBlock {
    my $root = new block;
#    $root->name("test");
    my @line;
    my $i = 0;
    @line = getCLine();
    while ($line[0] ne "MLN_END" ) {
#        print "parseBlock: $line[0]\n";
	last if ( $line[0] =~ /\}/ );

       	if ( $line[1] =~ /\{/ ) {
	    # we have a new block!
#	    print "new block: $line[0]\n";
	    $root->blocks($line[0],parseBlock());
	} elsif ( $line[0] eq "network" ) {	
#	    print "special network block case: $line[0]\n";
	    if ( not $root->blocks('network') ) {
		$root->blocks('network',new block);
	    }
	    $root->blocks('network')->blocks($line[1],parseBlock());
	} elsif ( $line[1] eq "=" ) {
#	    we have a new variable
#	    print "variable detected: $line[0]\n";
	    $root->value($line[0],getRestAsString(2,\@line));
	    # we are not putting variable declarations into the array
#	    $root->array($i++,getRestAsString(0,\@line));
	} else {
#	    print "line: $line[0]\n";
	    if ( not $line[1] ) {
		$root->value($line[0],1);
	    } else {
		$root->value($line[0],getRestAsString(1,\@line));
	    }
#	    print "setting array[" . ($i) ."] to " . getRestAsString(0,\@line) ."\n";
	    $root->array($i++,getRestAsString(0,\@line));
	}
	@line = getCLine();
    }
#    print "returning block: " . $root->name ."\n";
    return $root;
}

sub getArray {
    
    my @path = split /\//,$_[0];
    my $host = $_[2];
    shift(@path);
    my $i;
#    my $item = pop(@path);
#    print "getArray: Looking for /" . getRestAsString(0,\@path,"/") ."\n";
    my $block = getBlock($DATA_ROOT,\@path);
#    print "got Block\n";
#    printBlock($block);
    $block = new block if not $block;
   
   
    if ($path[0] eq "host" or $path[0] eq "superclass") {

	# we are looking for something within a host, therefore inheritance applies
	my $superclass = getScalar("/$path[0]/$path[1]/superclass");
	if ( $superclass ) {
#	    print "we have a superclass: $superclass\n";
	    my @array = getArray("/superclass/$superclass/" .getRestAsString(2,\@path,"/"),"raw");	
#	    print "got this from $superclass:\n";
	    # foreach (@array) {
	    # 	print $_ . "\n";
	    # }
	    my @result =  mergeArray(\@array,$block->array);
	    if (not $_[1] ){
		for($i = 0; $i <= $#result ; $i++) {
		    $result[$i] = getValue($result[$i],"/" .getRestAsString(0,\@path,"/"));
		}
	    }
	    return @result;			    
	} else {
#	    verbose("getArray: host is $path[0]\n");
	    $host = $path[0];
	    my @result =  @{$block->array};
	    for($i = 0; $i <= $#result ; $i++) {
#		print "preparing result $result[$i]\n";
#		print "adding: " . getValue($result[$i],"/" .getRestAsString(0,\@path,"/")) . "\n";
		$result[$i] = getValue($result[$i],"/" .getRestAsString(0,\@path,"/"));
	    }
	    return @result;			    

	}
    } else{

	# no host, so it must regard a switch or even global block
	my $tm = $block->array;
	my @array = @$tm;
	for($i = 0; $i <= $#array ; $i++) {
	    $array[$i] = getValue($array[$i],getRestAsString(0,\@path));
	}
	return @array;	
    }

}

sub lineExists {

    my $line = $_[0];
    my $tm = $_[1];
    my @array = @$tm;

    foreach (@array){
	if ( $line eq $_ ){
	    return 1;
	}
    }
    return 0;
}

sub trimSuperclasses {
    my $tm = $_[0];
    my @array = @$tm;
    my $i;
    my $j;
    my @result;
    for ($i = 0; $i <= $#array; $i++){
	if (not $array[$i] =~ /^superclass \S+$/ ){
	    $result[$j++] = $array[$i];
	} 
    }
    return @result;
}

sub mergeArray {
    my $tm = $_[0];
    my @array1 = @$tm;
    $tm = $_[1];
    my @array2 = @$tm;
    if ( not @array1 ) {
	return @array2;
    }
    my $size1 = $#array1 + 1;
    my $size2 = $#array2 + 1;
    debug("mergeArray: $size1 vs $size2\n"); 
    my $i;
    for ($i = 0; $i <= $#array2; $i++) {
	if ( $array2[$i] and not lineExists($array2[$i],\@array1) ){
	    if ( $array2[$i] =~ /^superclass \S+$/ ){
		@array1 = trimSuperclasses(\@array1);
	    }
#	    print "pushing $array2[$i]\n";
	    push(@array1,$array2[$i]);
	}
    }
    return @array1;
}

sub setScalar {
    
    my @path = split /\//, $_[0];
    # looks like an empty field always shows up.
    shift(@path);
    my $value = $_[1];
    
    my $keyword = pop(@path); 
    
#    print "first element: '$path[0]'\n";
#    exit;
    $DATA_ROOT = verifyBlock( "/" .getRestAsString(0,\@path,"/"),$DATA_ROOT,$keyword,$value);
    
}

sub setArray {
    
    my @path = split /\//, $_[0];
    # looks like an empty field always shows up.
    shift(@path);
    my $tm = $_[1];
    my @array = @$tm;
    my $keyword = $path[$#path + 1]; 
    
#    print "first element: '$path[0]'\n";
#    exit;
    $DATA_ROOT = verifyBlockArray( "/" .getRestAsString(0,\@path,"/"),$DATA_ROOT,$keyword,\@array);
    
}

sub setHash {
    
    my @path = split /\//, $_[0];
    # looks like an empty field always shows up.
    shift(@path);
    my $tm = $_[1];
    my %hash = %$tm;
    my $keyword = $path[$#path + 1]; 
    
    $DATA_ROOT = verifyBlockHash( "/" .getRestAsString(0,\@path,"/"),$DATA_ROOT,$keyword,\%hash);
    
}

sub verifyBlockHash {
    
    my @path = split /\//, $_[0];
    shift(@path);
    my $keyword = $_[2];
    my $tm = $_[3];
    my %new_hash = %$tm;
    my $block = $_[1];
#    print "verifyBlockArray called: [$path[0]] ($#path) $_[0], $keyword\n";
    
    # 1: The path is empty (we are holding the last block), 
    #    meaning we arrived at our destination:
    if ( $#path == -1 ){
	my $new;
#	print "verifyBlock: We found position. Inserting $keyword \n";
	# 1a : We need to check the values
	if ( $block ){
	    my $i = 0;
	    my $each;
	    # we need to keep all the old blocks:
	    $new = new block;

	    my $key;
	    foreach $key (keys %new_hash){
#		print "key: $key\n";
		if ( $new_hash{$key} =~ /HASH/ ){
		    my %n = $new_hash{$key};

		    $new->blocks($key,makeBlock(\%n));

		} else {
		    my @line = split /\s+/,$new_hash{$key};
#		    print "inserting $new_hash{$key}\n";
		    $new->value($line[0],getRestAsString(1,\@line));
		    $new->array($i++,$key . " " . $new_hash{$key});
		}
	    }
	} else {
#	    print "verifyBlock: Block is missing. Should be here\n";
	}
	return $new;
    } else {
	# 2. we need to go deeper into the tree:
	my $next = shift(@path);
#	print "verifyBlock: We check for existence of $next\n";
	if ( $block->blocks($next) ){
	# 2a: the block exists
	    $block->blocks($next,verifyBlockHash("/" . getRestAsString(0,\@path,"/"),$block->blocks($next),$keyword,\%new_hash));
	} else {
	# 2b: the block noes not exist and we need to create it
#	    print "verifyBlock: Block $next non-existent\n";
	    $block->blocks($next, new block);
	    $block->blocks($next,verifyBlockHash("/" . getRestAsString(0,\@path,"/"),$block->blocks($next),$keyword,\%new_hash));
	}
    }
    return $block;
}

sub verifyBlockArray {
    
    my @path = split /\//, $_[0];
    shift(@path);
    my $keyword = $_[2];
    my $tm = $_[3];
    my @new_array = @$tm;
    my $block = $_[1];
#    print "verifyBlockArray called: [$path[0]] ($#path) $_[0], $keyword\n";
    
    # 1: The path is empty (we are holding the last block), 
    #    meaning we arrived at our destination:
    if ( $#path == -1 ){
	my $new;
#	print "verifyBlock: We found position. Inserting $keyword \n";
	# 1a : We need to check the values
	if ( $block ){
	    my $i;
	    my $each;
	    # we need to keep all the old blocks:
	    $new = new block;
	    foreach $each (keys %{$block->blocks}){
		$new->blocks($each,$block->blocks($each));
	    }
	    
	    for ( $i = 0; $i <= $#new_array; $i++){
		my @array = split /\s+/,$new_array[$i];
#		print "inserting: $new_array[$i]\n";
		$new->value($array[0],getRestAsString(1,\@array));
		$new->array($i,$new_array[$i]);
	    }
	} else {
#	    print "verifyBlock: Block is missing. Should be here\n";
	}
	return $new;
    } else {
	# 2. we need to go deeper into the tree:
	my $next = shift(@path);
#	print "verifyBlock: We check for existence of $next\n";
	if ( $block->blocks($next) ){
	# 2a: the block exists
	    $block->blocks($next,verifyBlockArray("/" . getRestAsString(0,\@path,"/"),$block->blocks($next),$keyword,\@new_array));
	} else {
	# 2b: the block noes not exist and we need to create it
#	    print "verifyBlock: Block $next non-existent\n";
	    $block->blocks($next, new block);
	    $block->blocks($next,verifyBlockArray("/" . getRestAsString(0,\@path,"/"),$block->blocks($next),$keyword,\@new_array));
	}
    }
    return $block;
}

sub verifyBlock {
    
    my @path = split /\//, $_[0];
    shift(@path);
    my $keyword = $_[2];
    my $val = $_[3];
    my $block = $_[1];
#    print "verifyBlock called: [$path[0]] ($#path) $_[0], $keyword = $val\n";
    
    # 1: The path is empty (we are holding the last block), 
    #    meaning we arrived at our destination:
    if ( $#path == -1 ){

#	print "verifyBlock: We found position. Inserting $keyword / $val\n";
#	print "test: " . $block->value("important") . "\n";
	# 1a : We need to check the values
	if ( $block ){
	    my $i;
	# 1b : We also need to check the array
	    my @temp = @{$block->array};
	    my $changed = 0;
	    for ( $i = $#temp + 1; $i >= 0; $i--){
		my @array = split /\s+/,$block->array($i);
#		print "arraycheck: $array[0]\n";
		if ( $array[0] eq $keyword ){
		    $block->array($i,"$keyword $val");
		    $changed = 1;
		    last;
		}
	    }
	    if ( not $changed ){
		$block->array($#temp + 1,"$keyword $val");
	    }
	    $block->value($keyword,"$val");
	} else {
#	    print "verifyBlock: Block is missing. Should be here\n";
	}
    } else {
	# 2. we need to go deeper into the tree:
	my $next = shift(@path);
#	print "verifyBlock: We check for existence of $next\n";
	if ( $block->blocks($next) ){
	# 2a: the block exists
	    $block->blocks($next,verifyBlock("/" . getRestAsString(0,\@path,"/"),$block->blocks($next),$keyword,$val));
	} else {
	# 2b: the block noes not exist and we need to create it
#	    print "verifyBlock: Block $next non-existent\n";
	    $block->blocks($next, new block);
	    $block->blocks($next,verifyBlock("/" . getRestAsString(0,\@path,"/"),$block->blocks($next),$keyword,$val));
	}
    }
    return $block;
}

sub mergeBlock {
    my $block = $_[0];
    my $old = $_[1];
    my $path = $_[2];
    my $oldpath = $_[3];
    my $root = $_[4];

    
#    if ( $root ) {
#	print "mergeBlock got root\n";
#    }
#    my %hash = %$tm;
#    my %result;
#    my %empty;
    my %used;
    my $result = new block;
    
     # print "merging new($path) and old($oldpath)\n"; 
     # printBlock($block);
     # print "and old($oldpath):\n";
     # if ($old){
     # 	printBlock($old);
     # }
    # print "---\n";
    my $each;    
    # we need to take care of the new blocks in $block

    if ( $old ) {
	foreach $each ( keys %{$old->blocks} ) {
	    # we check if the block also exists locally. 
	    # in that case we'll merge
#	    print "from old block: $oldpath/$each\n";
	    if ( $block ){
		$result->blocks($each,mergeBlock($block->blocks($each),$old->blocks($each),$path . "/" . $each,$oldpath . "/" . $each,$root));
	    } else {
		$result->blocks($each,$old->blocks($each));
	    }
	    $used{$each} = 1;
	}
	# next come all the values: 
	foreach $each ( keys %{$old->value}) {
	    $result->value($each,getValue($old->value($each),$oldpath . "/" . $each,$root));
#	    push(@{$result->array},"$each " .$result->value($each));
	}	
	foreach $each ( @{$old->array} ){
	    push(@{$result->array},getValue($each,$oldpath,$root));
	}

    }
    
    # locally defined values
    if ( $block and keys %{$block->value} ){
	foreach $each ( @{$block->array} ){
	    push(@{$result->array},getValue($each,$path,$root)) if not lineExists(getValue($each,$path,$root),\@{$result->array});
	}
	foreach $each (keys %{$block->value}) {
	    my $temp = getValue($block->value($each),$path,$root);
#	    print "$each yielded: $temp\n"; 
	    
	    $result->value($each,$temp);

#	    print "result now contains: " . $result->value($each) . "\n";
#	    foreach $temp ( keys %{$result->value}) {
#		print "found key: $temp = " .$result->value($temp). "\n";
#	    }
#	    printBlock($result);
	}
    } else {
#	print "no locally defined values\n";
    }
    
    if ( $block and keys %{$block->blocks} ){
	foreach $each ( keys %{$block->blocks}){
	    if ( not $used{$each} ){
#	    print "local block $path/$each detected\n";
		if ( not $old ){
		    $result->blocks($each,mergeBlock($block->blocks($each),$old,$path . "/" . $each,$oldpath . "/" . $each,$root));
		} else {
		    $result->blocks($each,mergeBlock($block->blocks($each),$old->blocks($each),$path . "/" . $each,$oldpath . "/" . $each,$root));
		}
	    }
	}
    } else {
#	print "no locally defined blocks\n";
    }
    
#    print "returning from ($path):\n";    
    if ( $result ) {
#	printBlock($result);
    } else {
#	print "empty\n";
	return;
    }
    return $result;
}

sub printHash {
    
    my $tm = $_[0];
    my %hash = %$tm;
    my $padding = $_[1];
    my $file = $_[2];
    $file = STDOUT unless $file;
    my $key;
    foreach $key (keys %hash){
	if ( $hash{$key} =~ /HASH/ ){
	    print $file "$padding$key {\n";
	    my %new = $hash{$key};
	    printHash($hash{$key},$padding . "\t",$file);
	    print $file "$padding}\n";
	} else {
	    if ( $key =~ /^\$/ ){
		 print $file "$padding$key = $hash{$key}\n";
	    } else {
		print $file "$padding$key $hash{$key}\n";
	    }
	}
    }
#    print "printHash finished\n";
}
sub makeBlock {
    my $tm = $_[0];
    my %hash = %$tm;
    my $i++;
    my $new = new block;
    my $key;
    foreach $key (keys %hash){
	if ( $hash{$key} =~ /HASH/ ){
	    my %n = $hash{$key};
	    $new->blocks($key,makeBlock(\%n));
	} else {
	    my @line = split /\s+/,$hash{$key};
	    $new->value($line[0],getRestAsString(1,\@line));
	    $new->array($i++,$hash{$key});
	}
    }
    return $new;
}

sub getBlockKeys {
    my $block;
    $block = prepareGetHash($_[0],$_[1]);

    my @array;
    my $each;
    foreach $each ( keys %{$block->blocks}){
#	print "returning key $each\n";
	push(@array,$each);
    }
    return @array;    
}


sub getHash {
    debug("getHash called: $_[0],$_[1]\n");    
    my $block = prepareGetHash($_[0],$_[1]);    
    return makeHash($block);
}

sub makeHash {
    my $block = $_[0];
    my %hash;
    my $each;
    foreach $each ( keys %{$block->value}){
	$hash{$each} = getValue($block->value($each));
    }
    
    foreach $each ( keys %{$block->blocks}){
	my %new = makeHash($block->blocks($each));
	$hash{$each} = \%new; 
    }
    
    return %hash;
}

sub prepareGetHash {
    debug("prepareGetHash($_[0])");
    my @path = split /\//,$_[0];
    my $root = $_[1];

    # if ( $root ) {
    # 	print "prepareGetHash($_[0]) got root\n";
    # } else {
    # 	print "prepareGetHash($_[0]) got no root\n";
    # }
    shift(@path);
#    my $item = pop(@path);
    debug("prepareGetHash: Looking for /" . getRestAsString(0,\@path,"/") ."\n");
    my $block; 
    if ( $root) {
	$block = getBlock($root,\@path);
    } else {
	$block = getBlock($DATA_ROOT,\@path);
    }

#    print "data block:\n";
#    printBlock($block);
    $block = new block if not $block;
    my $result;
    my $empty = new block;
    
    if ($path[0] eq "host" or $path[0] eq "superclass") {

	# we are looking for something within a host, therefore inheritance applies
	
	if ( $path[1] ) {
	    my $superclass;
	    $superclass = getScalar("/$path[0]/$path[1]/superclass",$root);
	    
	    if ( $superclass ) {
#		print "superclass $superclass found\n";
		my $hash = prepareGetHash("/superclass/$superclass/" . getRestAsString(2,\@path,"/"),$root);
		my $oldpath = "/superclass/$superclass";
		if ( $#path > 1) {
		    $oldpath .= getRestAsString(2,\@path,"/");
		}
		$result = mergeBlock($block,$hash,"/" . getRestAsString(0,\@path,"/"),$oldpath,$root);
		return $result;
	    } else {
		$result = mergeBlock($block,$empty,"/" . getRestAsString(0,\@path,"/"),"",$root);
#		print "after mergeBlock: \n";
#		printBlock($result);
		return $result;
	    }
	} else {
	    # we are looking for all hosts
	    my $each;
	    foreach $each (keys %{$block->blocks}){
		$block->blocks($each,prepareGetHash("/host/$each",$root));
	    }
	    return $block;
	}
    } else {
	# no host, so it must regard a switch or even global block
	$result = mergeBlock($block,$empty,"/" .getRestAsString(0,\@path,"/"),"",$root);	
	return $result;
    }
}

sub runPlugins {
    if ( %PLUGIN_LIST ){
	
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    
	    my $subcall = $plugin . "_$_[0]"; 
#	    print "calling $subcall\n";
	    verbose("calling $subcall\n");
	    if ( defined(&$subcall) ){
		&$subcall;
	    }
	    
	}
    }    
    
}

sub runPostParsePlugins {
    if ( %PLUGIN_LIST ){

	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){

	    my $subcall = $plugin . "_postParse"; 
#	    print "calling $subcall\n";
	    debug("calling $subcall\n");
	    if ( defined(&$subcall) ){
		&$subcall;
	    }
	    
	}
    } 
}

#####################
#
# Subroutine which will return an array of filesystems used
# by that particular VM. May be path to file or block-device.
# Calls the _getImportExportFiles in all the plugins

sub getFilesystems {
    my $hostname = $_[0];
    my $project = $_[1]; 
    my $root;
    my @result;
    if ( %PLUGIN_LIST ){
	    
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    
	    my $subcall = $plugin . "_getImportExportFiles"; 
#	    print "calling $subcall\n";
	    verbose("calling $subcall\n");
	    if ( defined(&$subcall) ){
		my $tm = &$subcall($hostname,$project);
		my @array = @$tm;
		if (@array){
		    print "returning: @array\n";
		    return @array;
		}
	    }
	    
	}
    }
    my $filepath = getScalar("/host/$hostname/filepath");
    $result[0] = "$filepath/$hostname.$project";
    ( return @result and print "filepath\n") if $filepath;
    my $lvm = getScalar("/host/$hostname/lvm");
    if ( $lvm ){
	my $lvm_vg = getScalar("/host/$hostname/lvm_vg");
	my $vg = $lvm_vg;
#    print "path is $path\n";
#		    print "/host/$md[2]/lvm_vg -> $vg\n";
	$vg = $DEFAULTS{MLN_VG} unless $vg;
	$result[0] = "/dev/$vg/$hostname.$project";
	return @result;
    }
    $result[0] = "$PROJECT_PATH/$project/images/$hostname";
    return @result;
}

sub getScalar {
    
    my @path = split /\//,$_[0];
    my $root = $_[1];
    shift(@path);
    my $item = pop(@path);
    
    debug("getScalar: Looking for $item ($_[0])\n");
    my $block;
    if ( not $root) {
	$block = getBlock($DATA_ROOT,\@path);
    } else {
	$block = getBlock($root,\@path);
    }
    if ($block and ($path[0] eq "host" or $path[0] eq "superclass") and ($block->value($item) or $block->blocks($item))) {
	# we are looking for something within a host, therefore inheritance applies
	if ( $block->blocks($item) ){
	    return 1;   
	} else {
	    return getValue($block->value($item),"/" .getRestAsString(0,\@path,"/"),$root);
	}
    } elsif ( $item ne "superclass" and $path[1] and ($path[0] eq "host" or $path[0] eq "superclass")  ) {
	my $superclass;
	if ( not $root ) {
	    $superclass = getScalar("/$path[0]/$path[1]/superclass");   
	} else {
	    $superclass = getScalar("/$path[0]/$path[1]/superclass",$root);
	}
	if ( $superclass ){
	    my $rest = getRestAsString(2,\@path,"/");
	    $rest .= "/" if $rest;
	    my $search = "/superclass/$superclass/" . $rest . "$item";
#	    print "not found locally, searching: $search\n";
	    if ( not $root ){
		return getScalar("/superclass/$superclass/" . $rest . "$item");
	    } else {
		return getScalar("/superclass/$superclass/" . $rest . "$item",$root);
	    }
	}  
    } elsif ( $block) {
	# no host, so it must regard a switch or even global block
	if ( $root ) {
	    return getValue($block->value($item),"",$root);
	} else {
#	    print "returning value for: " . $block->value($item) . "\n";
	    return getValue($block->value($item));
	}
    }
}

sub getBlock {
    
    my $block = $_[0];
    my $tm = $_[1];
    my @path = @$tm;
    
#    print "get block called for: $path[0]\n";

    if ( ($#path + 1) >= 1 ) {
	my $item = shift(@path);
	if ( $block and $block->blocks($item) ) {
#	    print "found item";
	    return getBlock($block->blocks($item),\@path);
	}
    } else {
	return $block;
    }
}

sub compareArrays {
     my $tm = $_[0];
    
}
sub getDiff {
    
    my $BEFORE = $_[0];
    my $AFTER = $_[1];
    
    
 #   print "BEFORE:\n";
 #   printBlock($BEFORE);
 #   print "AFTER:\n";

    
    my $DIFF = new block;

#    $DIFF->blocks('switch',new block);
#    $DIFF->blocks('superclass',new block);

    my $each;
#    foreach $each ( @{$AFTER->array}){
	
	
#    }
    
    # we compare the hosts:

    my $h_after = prepareGetHash("/host",$AFTER);    
#    printBlock($h_after);
     my $h_before = prepareGetHash("/host",$BEFORE);    

    foreach $each ( keys %{$h_after->blocks}){
#	print "#### checking $each\n";
	if ( ( $h_before and not $h_before->blocks($each)) or not $h_before ){
	    # we have a new host!
#	    print "new host $each\n";
	    if ( not $DIFF->blocks("host") ) {  
		$DIFF->blocks('host',new block) 
	    }
	    $DIFF->blocks("host")->blocks($each,$h_after->blocks($each));
	} elsif ( $h_before and $h_before->blocks($each)) {
	    # we have old host and need to compare them
#	    print "comparing host $each\n";
	    my $diff = traverseDiff($h_before->blocks($each),$h_after->blocks($each));
#	    print "got back diff:\n";
#	    printBlock($diff);
#	    if (not keys %{$diff
	    if ( keys %{$diff->blocks} or keys %{$diff->value} ){
		if ( not $DIFF->blocks("host") ) {  
		    $DIFF->blocks('host',new block) 
		}
		
		$DIFF->blocks("host")->blocks($each,$diff);
	    }
	}
    }

    # we compare the global block: 
#   $h_after = prepareGetHash("/global",$AFTER);    
#   $h_before = prepareGetHash("/global",$BEFORE);    

#    my $diff = traverseDiff($h_before,$h_after);
#    if ( keys %{$diff->value} or keys %{$diff->blocks}) {
#	$DIFF->blocks("global",$diff);
#    }
    return $DIFF;
}

sub commandDiff {
    
#    print "starting\n";
    my $diff = getDiff(buildDataTree($ARGV[0]),buildDataTree($ARGV[1]));
    
    if ($diff) {
#	print "diff:\n";
	printBlock($diff);
    }
}
    
sub traverseDiff {
    my $BEFORE = $_[0];
    my $AFTER = $_[1];
    my $DIFF = new block;

    my $each;
#    we start with the ordinary values
    foreach $each ( keys %{$AFTER->value}) {
#	print "[$each] before: " . $BEFORE->value($each) . " after: " . $AFTER->value($each) . "\n";
	if ( not $each =~ /^\$/ and (not $BEFORE->value($each) or $BEFORE->value($each) ne $AFTER->value($each) )){
#	    print "DIFF: adding value " . $AFTER->value($each) ."\n";
	    $DIFF->value($each,$AFTER->value($each));
	    push(@{$DIFF->array},$each . " " . $AFTER->value($each));
	}
    }

    foreach $each ( keys %{$BEFORE->value}) {
	if ( not $AFTER->value($each) ){
	    $DIFF->value($each,$BEFORE->value($each));
	    push(@{$DIFF->array},$each . " " . $BEFORE->value($each));
	}
    }
    
    foreach $each ( keys %{$AFTER->blocks}){
	if ( not $BEFORE->blocks($each) ){
	    # block not present before, copying from after
#	    print "block $each is new, copying\n";
	    $DIFF->blocks($each,$AFTER->blocks($each));
	    printBlock($DIFF->blocks($each));
	} else {
	    # block is present, so we traverse it
#	    print "traverse deeper into $each\n";
	    my $diff = traverseDiff($BEFORE->blocks($each),$AFTER->blocks($each));
	    if ( keys %{$diff->blocks} or keys %{$diff->value} ) {
		$DIFF->blocks($each,$diff);
	    }
	}
    }
    
    foreach $each ( keys %{$BEFORE->blocks}){
	if ( not $AFTER->blocks($each) ){
	    # block not present before, copying from after
	    $DIFF->blocks($each,$BEFORE->blocks($each));
	}
    }
    return $DIFF;
}

sub commandSetScalar {
    my $opt_string = 'f:k:v:o:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    my $file = $opt{f};
    my $keyword = $opt{k};
    my $value = $opt{v};
    my $output = $opt{o};
    
    $DATA_ROOT = buildDataTree($file);
    die "error reading file $file\n" unless $DATA_ROOT;
    setScalar("$keyword",$value);
    $output = $file unless $output;
    open(FILE,">$output") or die "falied to open output $output\n"; 
    printBlock($DATA_ROOT,"",FILE);
    close(FILE);
    
}



sub parseMLN {
    
    my $opt_string = 'dvf:S:H:A:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
#   print "parsing: $opt{f}\n";
    my $CONF = $opt{f};
    if ( not $CONF ) {
	$STDIN_MODE = 1;
	$CONF = STDIN;
    }
    $DEBUG = 1 if $opt{d};
    if ($CONF) {
#	print "building data tree\n";
	$DATA_ROOT = buildDataTree($opt{f});
#	print "done reading\n";
#	printBlock($DATA_ROOT);
#	print "***** Printing\n";
	if ( not $opt{S} and not $opt{H} and not $opt{A} ){
	    printBlock($DATA_ROOT);
#	    print "done\n";
	    return;
	}
#	$DATA_ROOT = resolveHostnameVariables();	
	assignHostsToSwitches();
#	print "assigned hosts\n";
	runPostParsePlugins();
#	print "ran plugins\n";
	    
	if ($opt{S}) {
	    my $string = getScalar($opt{S});
	    print "$string\n";
	} elsif ( $opt{A}) {
	    my @array;
 	    @array = getArray($opt{A});
 	    my $i;
 	    for ( $i = 0; $i <= $#array ; $i++) {
 		print  $array[$i] ."\n";
 	    }
 	} elsif ($opt{H}) {
	    my %hash = getHash($opt{H});
#	    $hash{"test"}{"test2"} = ( "fish" => "chips" );
#	    my $key;
	    printHash(\%hash);
	}
	    
    }
    

}


sub printBlock{
    
    my $block = new block; 
    ${block} = $_[0];
    my $padding = $_[1];
    my $FP = $_[2];
#    print "got file pointer\n" if $FP; 
    $FP = STDOUT  unless $FP;

#    print "name: " . $block->name ."\n";
    # we start by printing out the array:
    my $each;
    if ( $block and keys %{$block->value}){
	foreach $each (keys %{$block->value}){
	    if ( $each =~ /^\$/ ){
		print $FP $padding . "$each = ". $block->value($each) ."\n";
	    } else {
#		out($padding . "$each ". $block->value($each)."\n");
	    }
	}
    }
    if ($block and $block->array){
      	foreach $each (@{$block->array}){
      	    print $FP $padding . "$each\n";
      	}
    }
    if ( $block and $block->blocks ){
	foreach $each (keys %{$block->blocks}){
	    print $FP $padding . $each . " {\n";
	    printBlock($block->blocks($each),"\t" . $padding,$FP);
	print $FP $padding . "}\n";
	}
    }    
}

# This method will enevtually generate an XML file based on
# the internal datastructure of MLN.

# sub mln2xml {

#     my @xml;
#     my $each;
#     my $key;

#     my $opt_string = 'f:o:';
#     getopts( "$opt_string", \my %opt ) or usage() and exit;

#     my $filename = $opt{o} if $opt{o};

#     parse_mln_config_file( $opt{f} );

# #######################
#     #
#     # Here is where I write some summaries
#     buildGlobalConfig();

#     # lets generate the header
#     push( @XML_DOC, "<!DOCTYPE mln SYSTEM \"mln.dtd\">" );
#     push( @XML_DOC, "<?xml version=\"1.0\"?>" );

#     push( @XML_DOC, "<project name=\"$PROJECT\">" );

#     #    push ( @XML_DOC, "<project>$PROJECT</project>");

#     # all the switches

#     foreach $key ( getBlockKeys("/switch") ) {

#         push( @XML_DOC, "<switch name=\"$key\"></switch>" );
#     }

#     # all superclasses

#     my $type;
#     foreach $type ( ( "superclass", "host" ) ) {
#         foreach $each (%HOSTS) {

#             if ( $HOSTS{$each}{"type"} eq "$type" ) {
#                 push( @XML_DOC, "<host name=\"$each\" type=\"$type\">" );

#                 # All plugins
#                 my $key;
#                 foreach $key ( keys %PLUGIN_LIST ) {
#                     my $pl = $HOSTS{$each}{$key};

#                     #

#                     my %plugin = %$pl;

#                     if (%plugin) {
#                         push( @XML_DOC, "<plugin name=\"$key\">" );
#                         printPlugin( \%plugin, "xml" );
#                         push( @XML_DOC, "</plugin>" );
#                     }
#                 }

#                 push( @XML_DOC, "</host>" );
#             }

#         }

#     }

#     push( @XML_DOC, "</project>" );

#     printXML_DOC($filename);

# }

# sub printXML_DOC {

#     my $file = $_[0];
#     my $line;
#     if ($file) {
#         open( FILE, ">$file" ) or die "Failed to open file $file";

#         foreach $line (@XML_DOC) {

#             print FILE "$line\n";

#         }
#         close(FILE);
#     }
#     else {

#         foreach $line (@XML_DOC) {

#             print "$line\n";

#         }
#     }
# }

sub findPlugins {

    my $plugin_dir;
    foreach $plugin_dir ( @{$DEFAULTS{"PLUGIN_LOCATIONS"}} ){

	verbose("looking in $plugin_dir\n");
	if( stat($plugin_dir)){
	    my $plugin;
#	opendir(DIR,$plugin_dir);
#	foreach $plugin (readdir(DIR)){
	    my @dirlist = `ls $plugin_dir`;
	    foreach $plugin (@dirlist){
		chomp($plugin);
		if (not ($plugin =~ /^\./ or $plugin =~ /~/) ){
		    my $key = $plugin;
		    $key =~ s/(\S+)\.(.*)/$1/;
#		    print "findPlugins called in $key\n";
		    verbose("found plugin: $key\n");
		    $PLUGIN_LIST{$key} = "$plugin_dir/$plugin";
		}
	    }
	    closedir(DIR);
	}
    }
    
    
}

##
# A simple sub which executes the which command but suppresses output.
sub which {

    return `which $_[0] 2> /dev/null`;

}


##
# The mln daemon (EXPERIMENTAL)
#########################################

sub startStopDaemon {
    my $new_sock = $_[0];
    my $reply;
    print $new_sock "OK\n";
    my $force = $_[2];
    my $command = $_[1];
    
    $reply = <$new_sock>;
    if ( $reply =~ /project (\S+)\n/ ){
	# now we know what project to work on.
	my $project = $1;
	print "client wants to $command $project\n";
	print "checking if the project exists and reply\n";
	if (stat("$PROJECT_PATH/$project") ) {
	    print $new_sock "OK\n";
	} else {
	    print $new_sock "NO\n";
	    next;
	}
	if ( $command eq "start" ){

	} elsif ( $command eq "stop" ) {

	}
    }
   
    
}
# The communication daemon

# BUILD and UPGRADE
# the basic command string:
# CLIENT: "(build|upgrade):sleep:wait"
# SERVER: if build or upgrade: 
#   "GIVE-FILE"
# CLIENT: send file + "FILE-END"
# server loads file and checks for files block
# if ( files ) {
# SERVER: FILE:filename
# if client opens file
#   CLIENT: OUTPUT
#   CLIENT: print file
#   CLIENT: OUTPUT-END
# } else {
#   CLIENT: NO-FILE
# }
# SERVER: send back "TICKET:(\d+)"
# server runs command in background and
# stores output together with ticket and IP
# [ new connection ]
# CLIENT: TICKET:
# new client connection asks for result with ticket
# if ( output ready and wait comes from same IP )
# SERVER: OUTPUT
# SERVER: print output
# SERVER: OUTPUT-END
# close
# else 
# SERVER: WAIT

# START AND STOP
# CLIENT: (start|stop):project:force:wait
# if ( project )
# server runs start/stop and records output
# SERVER: OUTPUT
# SERVER: print output
# SERVER: OUTPUT-END
# else
# NO-SUCH-PROJECT

# STATUS
# CLIENT: status:project:host:up:down
# server runs status 
# SERVER: OUTPUT
# SERVER: print output
# SERVER: OUTPUT-END

# MIGRATION
# CLIENT: migrate:host:project
# server checks
# SERVER: OUTPUT
# SERVER: send image
# SERVER: OUTPUT-END
# else:
# SERVER: WAIT

sub sendOutput {
    
    my $socket = $_[0];
    my $output = $_[1];
     
    print $socket "OUTPUT\n";
    print $socket "$output\n";
    print $socket "OUTPUT-END\n";
    
}

sub getFilesToCopy {
    
    my $data = $_[0];
    my %list;
    my $host;
    foreach $host (getHosts($data)){
	next unless getScalar("/host/$host/service_host",$data) eq $SERVICE_HOST;
	my %files = getHash("/host/$host/files",$data);
	my $file;
	# print "getting files from $host\n";
	foreach $file (keys %files) {
	    print "registering $file for copying\n"; 
	    $list{$file} = 1;
	}
    }
    return keys %list;
}

sub authorizedHosts {

    my $peer = $_[0];
    print "got extra info: $_[1]\n";
    if ( $_[1] ){

	my @array = split /:/,$_[1];
	print "this regards $array[0]\n";
	if ( $array[0] eq "migrate" ) {
	    print "this regards a migration: $PROJECT_PATH/$array[1]/lock/$array[3]\n";
	    if (stat("$PROJECT_PATH/$array[1]/lock/$array[3]")){
		my $reciever = `cat "$PROJECT_PATH/$array[1]/lock/$array[3]"`;
		chomp $reciever;
		$reciever =~ s/(\S+)(:.*:.*)/$1/;
		print "peer: $peer eq reciever: $reciever\n";
		if ( $peer eq $reciever ){
		    print "reciever accepted\n";
		    return 1;
		}
	    }
	} elsif ( $array[0] eq "project_version_request"){
	    return 1;	    
	}
	
	if ( $array[0] eq "upgrade" and $array[7] ){
	    print "Project-specific password: $array[7], project: $array[3]\n";
	    my $data = buildDataTree("$PROJECT_PATH/$array[3]/$array[3].mln");
	    my $password = getScalar("/global/project_password",$data);
	    print "stored password: $password\n";
	    if ( $password eq $array[7] ){
		print "password accepted\n";
		return 1;
	    }
	    
	}
    }
    
    debug("checking peer address: $peer\n");
    my $allow_line;
    foreach $allow_line (@ALLOWED_DAEMONS){
	my $expr = $allow_line;
	$expr =~ s/\./\\./g;
	$expr =~ s/\*/\\d+/g;
	debug("expression: $expr ($allow_line)\n");
	if ( $peer =~ /$expr/ ){
	    verbose("client is accepted\n");
	    return 1;
	}
    }
    out("no daemon_allow matches found - disconnecting client\n");
    return 0;
}

# The special thing about this method, is that it
# creates migration data for the following events:
# - images that move between remote servers
# - images that will be fetched by this client from a remote server

# It will NOT register:
# - images that are local and have to be pushed to a remote server
# this means, that the client needs to keep track of this last item manually, or in a separate 
# function. Images need do be pushed before the remote server starts upgrading. 
# This can create a bottleneck, so we need to send data to all other remote hosts first, and then to
# the push-recievers. Also, the push reciever needs to fork 
# before the push so that it can handle other downloads aswell.

sub registerLeavingImages {
    my $host;
    my %push_images;
    return unless $DIFF;
    # get the old data: 
    
#    my $old = buildDataTree("$PROJECT_PATH/$project/$project.mln");
    foreach $host ( getHosts($DIFF) ){
	print "checking if $host has to migrate\n";
	my $new_s = getScalar("/host/$host/service_host");
	my $old_s = getScalar("/host/$host/service_host",$OLD_DATA_ROOT);
	print "old: $old_s, new $new_s\n";
	if ( $SERVICE_HOST and not $old_s ){
	    $old_s = $SERVICE_HOST;
	}

	if ( $new_s and $old_s and $old_s ne $new_s ){
	    # this host is moving, lets store it:
	    if ( $old_s and not $old_s eq $SERVICE_HOST ) {
		# check if server is down: 
		
		print "registering host to move: $new_s:$host:$old_s\n";
#		push(@moving_hosts,"$PROJECT:$new_s:$host:$old_s");
		if ( $DOWN_SERVERS{$old_s} ){
		    $MIGRATION_DATA{"$PROJECT:$new_s:$host:$old_s:DOWN"} = 1;
		} else {
		    $MIGRATION_DATA{"$PROJECT:$new_s:$host:$old_s:UP"} = 1;
		}
	    } else {
		print "host $host will have to be pushed first\n";
		$old_s = $SERVICE_HOST unless $old_s;
		$push_images{"$PROJECT:$new_s:$host:$old_s"} = 1;
		$PUSH_TARGETS{$new_s} = 1;
	    }
	}
    }
    return %push_images;
}

sub establishConnection {
    use IO::Socket;
    my $server = $_[0];
    my $port = $_[1];
    my $attempts = $_[2];
    my $wait = $_[3];

    my $socket;
    my $i;
    for ( $i = 1; $i <= $attempts; $i++ ){
	$socket = new IO::Socket::INET(
	PeerAddr => $server,
	PeerPort => 34001,
	Proto    => 'tcp');
	if ( $socket ) {
	    return $socket;
	}
    }
}

sub sendFile {
    my $target = $_[0];
    my $sock = $_[1];
    if ( open (FILE,"cat $target | gzip -c |")){
#	print "Sending file $target\n";
	my $scalar;
	my $packetcounter = 0;
	my $data_transfered;
	my $lasttime = time();
	while( read(FILE,$scalar,1448)){
	    $data_transfered += 1448;
	    $packetcounter++;
	    if ($packetcounter == 8192 ){
		my $data = int(($data_transfered / 1024) / 1024);
		my $now = time();
		my $diff =  (${data}/($now - $lasttime));
		out("$target - ${data}MB @ " . sprintf("%.1f",$diff) ."MB/s\n");
		$packetcounter = 0;
	    }
	    send ($sock,$scalar,"0");
	}
	print $sock "OUTPUT-END\n";
#	print "Done\n";
	close(FILE);
    }
   
}

sub recieveFile {
    my $target = $_[0];
    my $sock = $_[1];
    my $data_transfered;
    if ( open(FILE,"| gunzip -cq > $target ") ){
	my ($buffer,$double);
	my $readMore="true";
	my $previous = "";
	my $bytecounter;			
#	print "pipe open\n";
	my $outcounter;
	my $lasttime = time();	
	my $starttime = $lasttime;
	while($readMore){	    
	    recv ($sock,$buffer,1448,"0");
	    $bytecounter += 1448;
	    $outcounter++;
	    if ( $outcounter == 8192 ){
		$data_transfered = int(($bytecounter / 1024 ) / 1024);
		my $now = time();
		my $diff =  (${data_transfered}/($now - $lasttime));
		out("$target - ${data_transfered}MB @ " . sprintf("%.1f",$diff) ."MB/s\n");
		$outcounter = 0;
	    }
	    $double = $previous . $buffer;
	    if($double =~ /OUTPUT-END\n/){
		$double =~ s/OUTPUT-END\n//;
		print FILE "$double";
		$readMore = "";
	    }
	    else{
		print FILE "$previous";
		$previous = $buffer;
	    }
	}
	close(FILE);
	my $endtime = time();
	if ( $endtime <= $starttime ){
	    $endtime = $starttime + 1;
	}
	out( "$target transfered in ". ( $endtime - $starttime) ." seconds. Compressed: " . int(($bytecounter / 1024) / 1024) . "MB @ " . int((($bytecounter / 1024) / 1024) / ($endtime - $starttime)) . "MB/s\n");
    }
}

sub fetchIncomingImages {
#    print "$ENV{'PID'} -   fetchIncomingImages called\n";
    my $data = $_[0];
    my $tm = $_[1];
    my %migration_data = %$tm;
    my $project = getScalar("/global/project",$data);
    my $host;
    # get the old data: 
    my $old = buildDataTree("$PROJECT_PATH/$project/$project.mln");

    my $line;
    foreach $line (keys %migration_data){
	my @md = split /:/,$line; 
	print "$ENV{'PID'} - MIGRATION_DATA line: $line\n";
	if ( $md[0] eq $project and $md[1] eq $SERVICE_HOST and $md[4]){
	    # this is an image we need to get
	    print "$ENV{'PID'} - i need to get $md[2] from $md[3]\n";
	    my $attempts = 3;
	    my $wait = 4;
	    
	    my $i;
	    for ( $i = 1; $i <= $attempts; $i++ ){		
#		print "attempt $i\n";
		my $sock = new IO::Socket::INET(
		    PeerAddr => $md[3],
		    PeerPort => 34001,
		    Proto    => 'tcp');
		
		$sock or (warn "no socket: $!" and return);
		my $data_transfered;
		print "got connected with $md[3]\n";
		print $sock "migrate:$line\n";
		my $reply = <$sock>;
		print "$ENV{'PID'} - got reply back: $reply\n";
		if ( $reply =~ /SIZE:(\d+):(|([^:]+)):(|(.*))\n/ ){
		    my $lvm_vg = getScalar("/host/$md[2]/lvm_vg",$data);
		    my $vg = $lvm_vg;
		    my $filepath = getScalar("/host/$md[2]/filepath",$data);
		    my $path = $5;
		    print "path is $path\n";
#		    print "/host/$md[2]/lvm_vg -> $vg\n";
		    $vg = $DEFAULTS{MLN_VG} unless $vg;
#		    print "$ENV{'PID'} - got message $3 and $vg is on san $SAN_PATH{$vg}\n";
#		    print "reply: $reply";
		    my $san =  isOnSan($md[2],$md[0],$path);
		    if ( $3 eq "LIVE" and $san ){
			print "$ENV{'PID'} - preparing live migration\n";
			if ( $lvm_vg ){
			    system("vgscan 1>/dev/null; vgchange -a y 1>/dev/null");
			}
			print "$ENV{'PID'} - i should prepare switches!!\n";
			
			my $temp = $DATA_ROOT;
			$DATA_ROOT = $data;
			executePluginExclusive("incomingLiveVM",$md[2],$project,$path);
			$DATA_ROOT = $temp;
			
			prepareNetworkSwitches($md[2],$project,$data);
			print $sock "LIVE-MIGRATE\n";
			$reply = <$sock>;
			if( not $reply eq "LIVE-MIGRATE-DONE\n"){
			    print "Could not understand output: $reply\n";
			}
			print "storing $md[2] in LIVE_LIST\n";
			$LIVE_LIST{$md[2]} = 1;
			last;
		    } elsif ( $san ) {
			print "$ENV{'PID'} - host is down, but i got SAN access\n";
			if ( $vg ){
			    system("vgscan 1>/dev/null; vgchange -a y 1>/dev/null");
			}
			print $sock "SAN-ACCESS\n";
			$migration_data{$line} = "";
			last;
		    } else {
			my $target = prepareForImageTransfer($data,$md[2],$1);
			if ($target){
			    print "$ENV{'PID'} - I am ready to recieve image to $target\n";
			    print $sock "GET-IMAGE\n";
			    recieveFile($target,$sock);
#			    my $md5 = `md5sum $target`;
#			    print "md5 checksum: $md5";
			    print $sock "OK\n";
			    
			    $reply = <$sock>;
			    if ( $reply eq "RAM-IMAGE\n" ){
				$target = "$PROJECT_PATH/$project/$md[2].ram";
				recieveFile($target,$sock);
			    }
			    print $sock "OK\n";
#			delete $MIGRATION_DATA{$line};
			    last;
			} else {
			    
			    print $sock "ABORT\n";
			}
		    }
		} else {
		    close($sock);
		    print "no migration allowed, retrying\n";
		    sleep $wait;
		    # $i;		    
		}
	    }
	}
	
    }
    return 1;
}

sub prepareForImageTransfer {
    my $data = $_[0];
    my $host = $_[1];
    my $size = $_[2];
    $size = $size * 1024;
    print "Preparing image of size ${size}KB\n";
    my $project = getScalar("/global/project",$data);
    if ( not stat("$PROJECT_PATH/$project/$project.mln")){
	# project not found, i will have to create the folder
	mkdir("$PROJECT_PATH/$project");

    }
    mkdir("$PROJECT_PATH/$project/images");
    my $lvm = getScalar("/host/$host/lvm",$data);
    # my $project = getScalar("/global/project",$data);
    my $filepath = getScalar("/host/$host/filepath",$data);
    if ( $lvm ) {
	my $vg = getScalar("/host/$host/lvm_vg",$data);
	$vg = $DEFAULTS{"MLN_VG"} unless $vg;
	# we need to create the lvm image:
	my $options = $lvm unless $lvm == 1;
	# i need to check wether the image exists or not:
	my $return;
	if (stat("/dev/$vg/$host.$project")){
	    # we need to see if the size is any different first.
	    lvm_execute($lvm,"/dev/$vg/$host.$project","$shell{'LVRESIZE'} --size ${size}K -v -n /dev/$vg/$host.$project 2>/dev/null");
	} else {
	    lvm_execute($lvm,"/dev/$vg/$host.$project","$shell{'LVCREATE'} -n $host.$project --size ${size}K $vg");   
	}	
	return "/dev/$vg/$host.$project";

       } elsif ( $filepath ){
	   return "$filepath/$host.project";
       } else {
	   return "$PROJECT_PATH/$project/images/$host";
       }
}

sub prepareNetworkSwitches {
    my $host = $_[0];
    my $project = $_[1];
    my $root = $_[2];
    $root = $DATA_ROOT unless $root;
    
    # for all network interfaces
    my %network = getHash("/host/$host/network",$root);
    my $if;
    foreach $if (keys %network){ 
	my $switch = $network{$if}{"switch"};
	if ( $switch ){
	    # what is the switch name?
	    my $obridge = getScalar("/switch/$switch/bridge",$root);
	    my $bridge = $obridge;
	    $bridge = "$switch.$project" unless $obridge;
#	print "bridge name: $bridge " . length($bridge) ."\n";
	    if ( length($bridge) > 16 and not $obridge ){
		my $rest = 15 - length($switch);
		my $crop = $project;
		$crop =~ s/^(.*)(\S{$rest})$/$2/;
		$bridge = "$switch.$crop";
#	    print "new bridge name: $bridge\n";
	    }
	    system("brctl addbr $bridge 2>/dev/null");
	    system("ifconfig $bridge up");
	}
    }
    
}

# socket code from the linux journal
sub runDaemon {
    use IO::Socket;
    use POSIX;
# fork
    my $MLN = "mln -P $PROJECT_PATH";
    
    my $OLDSIG = $SIG{"CHLD"};
    $SIG{"CHLD"} = "IGNORE";   

    my $opt_string = 'p:h:k:wSD:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;

    # we make sure we have a place to store the tickets:
    if( not stat($CLIENT_TICKET_FOLDER)){
	mkdir($CLIENT_TICKET_FOLDER) or die "$!\nFailed to create ticket folder\n";
    }
    system("chmod 600 $CLIENT_TICKET_FOLDER");
    
    my $DETATCH = $opt{D};
    
    my $ssl = $opt{S};
    
    my $port = $opt{p};
    $port = 34001 if not $port;
    my $wait = $opt{w};
    
    my $client_addr;
    my $PID;
    if ( $DETATCH ){
	if ( fork ) {
	    out("Starting MLN in daemon mode\n");
	    
	    exit 0;
	}
	# detatch
	close(STDIN);
        close(STDOUT);
	close(STDERR);
	POSIX::setsid() or die "Can't start a new session: $!";
	# we do not care about childres exit
    }
    $PID = $$;
#    print "pid file: $PID_FILE\n";
    if ( $DETATCH =~ /(\S+)\.pid/ ){
#	print "echo -n $ENV{'PID'} > $DETATCH";
	open ( PID,">$DETATCH") or die "Failed to open PID file $DETATCH: $!\n";
	print PID $PID;
	close (PID);
    }
    
    
    # The daemon can now start
    #####################################
    eval {require Sys::Syslog; 1};
     
    my $SYSLOG = 1 if ($@ =~ / locate Sys\/Syslog.pm in @INC/);
    openlog("MLN Daemon", "pid") if $SYSLOG;
#    parseConfig();
    
    my $ADDRESS = $opt{h};
    $ADDRESS = $DEFAULTS{"LISTEN_ADDRESS"} unless $ADDRESS;
    
    my $sock = new IO::Socket::INET(
	LocalHost => "$ADDRESS",
	LocalPort => $port,
	Proto     => 'tcp',
	Listen    => SOMAXCONN,
	Reuse     => 1);
	
    $sock or ( warn "no socket: $!\n" and return);
    STDOUT->autoflush(1);
    my $time = localtime time;
    print "$time - (user: $ENV{'USER'}, home: $ENV{'HOME'})\n";	
    print "MLN daemon ($VERSION) started on port $port, PID: $PID\n";
    syslog("info","MLN daemon ($VERSION) started on port $port, PID: $PID") if $SYSLOG;

#    my $path = `which mln`;
#    chomp $path;
#    print "subsys location: $path\n";
#    print "$ENV{'PATH'}\n";
    my($new_sock, $buf);
    while ($new_sock = $sock->accept()) {	
	print "-------------------------------\n";
	$time = localtime time;
	print  "$time\n";
	print "got a connection from: " . $new_sock->peerhost() . "\n";
	my $reply = <$new_sock>;
	chomp $reply;
	# send them a message, close connection
	if (not authorizedHosts($new_sock->peerhost(),$reply)){
#	    print "closing socket\n"; 
	    print $new_sock "GOODBYE\n";
	    close($new_sock);
	    syslog("info","Access denied for " . $new_sock->peerhost()) if $SYSLOG;
	    next;
	}

	print "command string: $reply\n";
	my @cline = split /:/,$reply;
	
	##### WHAT COMMAND DID WE GET?
	if ( $cline[0] eq "build" or $cline[0] eq "upgrade" or $cline[0] eq "reconfigure" ) {
	    ###############################################
	    ###  We need to build or upgrade
	    my $manager = $cline[5];
	    out("Manager for this project is $manager\n");
	    print $new_sock "GIVE-FILE\n";

	    
	    my $rand = int(rand(1000));
	    my $filename = "/tmp/$rand.mln";
	    out("got command: $reply, opening $filename\n");
	    
	    open(FILE,">$filename");
	    while ( <$new_sock> ) {
#		print "f: $_";
		last if $_ eq "FILE-END\n";
		print FILE $_;
	    }
	    close FILE;

	    my %migration_data;
	    my $line;
	    while ( $line = <$new_sock> ){
		last if ( $line eq "END-MIGRATIONS\n" );
		print "adding migration data: $line";
		
		chomp $line;
#		$hint = $line unless $hint;

		# only hosts that leave from here 
		$migration_data{$line} = 1;
	    }
	    my $data = buildDataTree($filename);
		
	    my $pid = fork();
	    if ( $pid != 0 ) {
		# we are still on the main parent daemon

		close($new_sock);
		print "Parent closing socket\n";
		# close the socket and check if we need to accept calls for moving images
		next;
	    } else {
		# here is the child 
		my $project = getScalar("/global/project",$data);
		# we need to sync the old MLN config if we do not have it
		if ( ($cline[0] eq "upgrade" ) and not $cline[8]){
		    print "no old version, asking for old config\n";
		    print $new_sock "NEED-OLD-FILE\n";
		    mkdir("$PROJECT_PATH/$project");
		    mkdir("$PROJECT_PATH/$PIDDIR_NAME");
		    open(FILE,">$PROJECT_PATH/$project/${project}.mln");
		    while ( <$new_sock> ) {
#		print "f: $_";
			last if $_ eq "FILE-END\n";
			print FILE $_; 
		    }
		    close FILE;
		    print "i got the old project file\n";
		    # get the old config
		} else {
		    # this will in principle never happen for upgrades or reconfigurations
		    # they will alsways sync old file with server.
		    print "i got an old project\n";
		    print $new_sock "GOT-OLD-FILE\n";
		    # don't need 
		}
		$OLD_DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/${project}.mln");
		foreach $line (keys %migration_data ){
		    print "*** Migration info: $line\n"; 
		    prepareForLeavingImage($line,$OLD_DATA_ROOT);
		}

		# checking if we get an image
		$reply = <$new_sock>;
#		print "got reply: $reply";
		while ( $reply =~ /PUSH:(\S+):(\d+):(|(\S+)):(|(.*))\n/ ){
		    my $size = $2;
		    my $image = $1;
		    my $path = $6;
		    my $filepath = getScalar("/host/$image/filepath",$OLD_DATA_ROOT);
		    my $vg = getScalar("/host/$image/lvm_vg",$OLD_DATA_ROOT);
		    $vg = $DEFAULTS{"LVM_VG"} unless $vg;
		    out("checking if VM is on shared storage\n");
		    if ( $4 eq "LIVE" and isOnSan($image,$project,$OLD_DATA_ROOT,$path) ){

			print "Live migrating\n";
			my $temp = $DATA_ROOT;
			$DATA_ROOT = $OLD_DATA_ROOT;
			# notify the plugins to make ready
			executePluginExclusive("incomingLiveVM",$image,$project,$path);
			$DATA_ROOT = $temp;
			
			if ( $vg ){
			    system("vgscan 1>/dev/null; vgchange -a y 1>/dev/null");
			}
			# prepare the network switches
			prepareNetworkSwitches($image,$project,$OLD_DATA_ROOT);
			print $new_sock "LIVE-MIGRATE\n";
			
		    } elsif ( $6 and ( $SAN_PATH{$vg} or $SAN_PATH{$filepath}) ){
			print "$vg is on san but down. No need to copy.";
			if ( $vg ){
			    system("vgscan 1>/dev/null; vgchange -a y /dev/$vg 1>/dev/null");
			}
			print $new_sock "SAN-ACCESS\n";
		    } else {
			# we will recieve an image, time to prepare for it:
			print "preparing for push\n";
			my $target = prepareForImageTransfer($data,$image,$size);
			print "target: $target\n";
			if ($target){
			    print "I am ready to recieve image to $target\n";
			    print $new_sock "GET-IMAGE\n";
			    recieveFile($target,$new_sock);
			    print $new_sock "OK\n";
			    print "waiting for a RAM-IMAGE\n";			
			    $reply = <$new_sock>;
			    if ( $reply eq "RAM-IMAGE\n" ){
				$target = "$PROJECT_PATH/$project/$image.ram";
				recieveFile($target,$new_sock);
			    }		    
			    print $new_sock "OK\n";
			}	
		    }
		    print "asking for more filesystems to migrate\n";
		    $reply = <$new_sock>;
#		    print "new line: $reply";
		}
		
		# We ask for any files needed during the copy process
		my @filesToCopy = getFilesToCopy($data);
		if ( @filesToCopy ){
		    my $file;
		    foreach $file (@filesToCopy){
			print "$rand: Asking for $file\n";
			print $new_sock "FILE:$file\n";
			$reply = <$new_sock>;
			if ( $reply eq "OUTPUT\n" ){
			    if ( open(FILE,"| tar -C $FILES_PATH -xz") ){
				my ($buffer,$double);
				my $readMore="true";
				my $previous = "";
				
				print "pipe open\n";
				while($readMore){
				    recv ($new_sock,$buffer,1448,"0");
				    $double = $previous . $buffer;
				    if($double =~ /OUTPUT-END$/){
					$double =~ s/OUTPUT-END$//;
					print FILE "$double";
					$readMore = "";
				    }
				    else{
					print FILE "$previous";
					$previous = $buffer;
				    }
				}
				close(FILE);
				print "$file transfered to $FILES_PATH\n";
			    }
			}
		    }
		}

		# my $ticket = new buildTicket;
		# $ticket->ticket($rand);
		# $ticket->host($new_sock->peerhost());
		my $peerhost = $new_sock->peerhost();
		print $new_sock "TICKET:$rand\n";
		print "Sending out ticket: $rand\n";
#		close($new_sock);
		# we need to register the ticket for later
		my $order = $cline[0];
		my $hostlist;
		if ( $cline[4] ){
		    $hostlist = "-h ";
		    foreach (split /,/,$cline[4]){
			$hostlist .= $_ . ":";
		    }
		}
		my $projectName = getScalar("/global/project",$data);
		if ( not stat("$PROJECT_PATH/".$projectName) and $order ne "build" ) {
		    print "$rand: project is nonexistent from before, i need to build it\n"; 
		    $order = "build";
		}				
		if ( $cline[0] eq "upgrade" ){
		    fetchIncomingImages($data,\%migration_data);
		    my $key;
		    foreach $key (keys %MIGRATION_DATA){
			print "OBSOLETE_MIGRATION_DATA: $key\n";
		    }
		}
#		my $command;
#		if ( $order eq "reconfigure" ){
#		    $command = "$MLN -R reconfigure -p $projectName $hostlist 2>&1";
#		} else {
#		    $command = "$MLN -R $order -S -r -f $filename ";
#		    my $live = " -l ";
#		    if ( $order eq "upgrade" and 
#			$command .= $live;
#		    }
#		    $command .= " 2>&1";
#		}
#		print "$rand: running command $command\n";
#		# $reply = system("$command");
#		my $output = `$command`;
#		print "$rand: return value: $?\n";
		$GLOBAL_OUTPUT = $new_sock if not $cline[8];
		$RESTART_UPGRADED = 1 if $cline[10];
		if ( $order eq "build" ){
		    buildMLNproject($filename,1,0,1);
		} elsif ( $order eq "reconfigure" ) { 
		    print "(BETA) Reconfiguring $projectName\n";
		    $RECONFIGURE = 1;
		    $RECONFIGURE_REBUILD = $cline[11];
		    if ( $cline[4] ){
			$HOSTLIST = $cline[4];
			$HOSTLIST =~ s/,/:/g;			
		    }
		    reconfigureMLNproject($projectName,1,0,1);
		    
		} elsif ($order eq "upgrade") {
		    close($new_sock) if $cline[8];
		    my $live;
		    if (%LIVE_LIST ){
			foreach (keys %LIVE_LIST){
			    $live .= "$_:";
			}
		    }
		    if ($cline[9] ){
			foreach ( split /,/,$cline[9]){
			    $live .= $_ . ":";
			}
			
		    }

		    my $remotely_spawned = not $cline[8];
		    print "running upgrade routine for version $cline[6]\n";
		    #                     0       1   2 3 4 5 6     7
#		    print "0: $filename\n";
#		    print "1: $live\n";
 #                   print "2: 1\n";
#		    print "3: 0\n";
#		    print "4: 0\n";
#		    print "5: 0\n";
#		    print "6: $remotely_spawned\n"; # $SPAWNED_REMOTELY
#		    print "7: $cline[6]\n";
		    
#		    print "8: $cline[8]\n";
  		    #                     0       1   2 3 4 5      6       7
#		    print "before subroutine\n"; 
#		    system ("cat $PROJECT_PATH/$PROJECT/$PROJECT.mln");
		    upgradeMLNproject($filename,$live,1,0,0,0,$remotely_spawned,$cline[6]);
#		    exit(0) if $cline[8];
		}
		print $new_sock "OUTPUT-END\n";
		system("rm $filename");
		print "$rand: storing ticket $rand and exiting\n";
		open (OUT,">$CLIENT_TICKET_FOLDER/$rand");
		print OUT "$peerhost\n";
		print OUT "fakeoutput\n";
		close(OUT);
		close($GLOBAL_OUTPUT);
		close($new_sock);
		print "$rand Done, thread closing\n";
		exit(0);
	    }
	} elsif ( $cline[0] eq "project_version_request" ) {
	    my $pid = fork();
	    if ( $pid != 0 ) {
		# we are still on the main parent daemon
		
		close($new_sock);
		print "Parent closing socket\n";
		# close the socket and check if we need to accept calls for moving images
		next;
	    } else {
		print "project version request on project $cline[1] from $cline[2]\n";
		my $project = $cline[1];
		if ( stat("$PROJECT_PATH/$project")){
		    open(FILE, "$PROJECT_PATH/$project/service_hosts");
		    my @service_hosts = grep ( /$cline[2]/, <FILE>);
		    close (FILE);
		    if (scalar @service_hosts){
			my $version = getProjectVersion($project);
			print "Found service host match, returning $version\n";
			print $new_sock "project_version:$project:$version\n";
			my $reply = <$new_sock>;
			print "got new reply $reply";
			if ($reply eq "GET-PROJECT-FILE\n"){
			    print "preparing o send file\n";
			    open(FILE, "$PROJECT_PATH/$project/$project.mln");
			    foreach (<FILE>){
				print "Sending: $_";
				print $new_sock $_;
			    }
			    print "Sending OUTPUT-END\n";
			    print $new_sock "OUTPUT-END\n";
			    close(FILE);
			}
			close($new_sock);
			exit 1;
		    } else {
			print $new_sock "GOODBYE\n";
		    }
	    
	    
	    
	    # read file into an array
	    
	    
	    

	    }
	

	    close ($new_sock);
	    }
	} elsif ( $cline[0] eq "PING" ) {
	    print "returning PONG:$VERSION\n";
	    print $new_sock "PONG:$VERSION\n";
	    close ($new_sock);
	} elsif ( $cline[0] eq "execute" ) {
	    my $exec = $cline[1];
	    acquire_lock();
	    out("Ecexuting $exec\n");
	    my @output = `$exec`;
	    release_lock();
	    foreach (@output){
		print $new_sock $_;
	    }
	    print $new_sock "OUTPUT_END\n";
	    close ($new_sock);
	} elsif ( $cline[0] eq "TICKET" ) {
	    print "Client asks for ticket '$cline[1]'\n";  
	    if ( stat("$CLIENT_TICKET_FOLDER/$cline[1]") ){

		open(OUT,"$CLIENT_TICKET_FOLDER/$cline[1]");
		my $hostpeer = <OUT>;
		chomp $hostpeer;
		print "Ticket found, checking ". $new_sock->peerhost() . " - $hostpeer\n";
		if ( $new_sock->peerhost()  eq $hostpeer ){
		    print $new_sock "OUTPUT\n";
#		print $CLIENT_TICKETS{$cline[1]}->output();
		    my $line; 
		    while ( $line = <OUT> ){
			print $new_sock $line;
		    }
		    print $new_sock "OUTPUT-END\n";
		    close (OUT);
		    system("rm $CLIENT_TICKET_FOLDER/$cline[1]");
		} else {
		    print $new_sock "GOODBYE\n";
		}
	    } else {
		print $new_sock "WAIT\n";
	    }

	} elsif ( $cline[0] eq "remove_project" ) {
	    my $rand = int(rand(10000));
	    print "$rand: Client wants to remove project $cline[1]\n";
	    if ( stat("$PROJECT_PATH/$cline[1]")){
		print "$rand: Project found locally at $PROJECT_PATH/$cline[1]\n";
		print $new_sock "TICKET:$rand\n";
		my $peerhost = $new_sock->peerhost();
		close($new_sock);
		my $command = "$MLN -R remove -f -p $cline[1]  2>1";
		print "$rand Running command: $command\n";
#		my @output = `$MLN -R remove -f -p $cline[1]`;
		my @output;
		system("$MLN -R remove -f -p $cline[1]");
		open (LOG,">$CLIENT_TICKET_FOLDER/$rand") or print "error opening ticket: $!\n";
		print LOG "$peerhost\n";
		foreach (@output){
		    print "$_";
		    print LOG "$_";
		}
		close(LOG);
	    } else {
		print "$rand: Project not present\n";
		print $new_sock "NO-SERVICE\n";		
		close($new_sock);
	    }	    
	} elsif ( $cline[0] eq "status_request" ) {
	    my $pid = fork();
	    if ( $pid != 0 ){
		# we are inside the parent
		close ($new_sock);
		next;
	    } else {

		my $rand = int(rand(10000));
		print "$rand: status_request\n";
		my %project_list;
		# time to recieve the batch and process it
		my $line;
		foreach $line ( split /,/,$cline[1] ){
		    $line =~ /(\S+) (\S+)/;
		    print "$rand: reading: $2.$1\n";
		    push(@{$project_list{$1}},$2);
		}		
		# next, we compute the status for each of the projects

		my $project;
		my $result;
		
		foreach $project ( keys %project_list ){
		    print "updating project $project\n";
		    
		    if ( not $DEFAULTS{"CHECK_PROJECT_VERSION"} ){
			# we don't check for project versions
			next;
		    }
		    
		    if ( not stat("$PROJECT_PATH/$project/manager")){
			# this project is local, exiting quietly. 
			next;
		    }
    
		    verbose("manager OK\n");

		    # 1. Get the project version
		    my $version = getProjectVersion($project);
		    print "my version is $version\n";
		    # 2. Find the manager and connect
    
		    my $manager = getProjectManager($project);
		    verbose("my manager is $manager\n");
		    
    # 3. Ask the manager for latest version
		    print $new_sock "project_version_request:$project:$SERVICE_HOST\n";
		    my $reply = <$new_sock>;
#		    print "answer back: $reply";
		    chomp $reply;
		    if ( $reply =~ /^project_version:$project:(\d+)$/ ){
			# 4. If local version is old, ask for newer version
			if ( $1 > $version ){
			    out("Project has been updated to version $1. Local version was $version\n");
			    print $new_sock "GET-PROJECT-FILE\n";
			    system("cp $PROJECT_PATH/$project/$project.mln $PROJECT_PATH/$project/$project.mln" . time );
			    open(FILE,">$PROJECT_PATH/$project/$project.mln");
			    $reply = <$new_sock>;		
			    while( $reply ne "OUTPUT-END\n" ){
				print FILE $reply;
				$reply = <$new_sock>;				
			    }	
			    close(FILE);
		# print "Done\n";
			    setProjectVersion($project,$1);

			} else {
#			    print "version OK\n";
			    print $new_sock "GOODBYE\n";
			 #   return $version;
			}
		    } else {
			out("$manager did not provide correct project version answer\n");
			$result .= "Project version of $project could not be verified,";
			delete($project_list{$project});
		    }	    	    

		}
		
#		print "sending ticket\n";
		print $new_sock "TICKET:$rand\n";
	       
		my $peerhost = $new_sock->peerhost();
		close($new_sock);
		
		foreach $project ( keys %project_list ){

		    $DATA_ROOT =  buildDataTree("$PROJECT_PATH/$project/$project.mln");
		    foreach (@{$project_list{$project}}) {
			if ( checkIfUp($_,$project) ){
			    $result .= "$project host $_ up,";
			} else {
			    $result .= "$project host $_ down,";
			}
		    }
		}
		print "(PID: $$) storing ticket: $rand\n";
		open (LOG,">$CLIENT_TICKET_FOLDER/$rand") or print "error opening ticket: $!\n";
		print LOG "$peerhost\n";
		print LOG "$result\n";		
		close(LOG);
		exit(0);
		print "exited\n";
	    }
	} elsif ( $cline[0] eq "import" ) {
	    my $pid = fork();
	    
	    if ( $pid != 0 ){
		# we are inside the parent
		close ($new_sock);
		next;
	    } else {
		my $project = $cline[1];
		print "Importing project: $project\n";

		# check for project dir presence
		if ( stat("$PROJECT_PATH/$project") ){
		    print "Project is present\n";
		    # shut down hosts
		} else {
		    system("mkdir -p $PROJECT_PATH/$project/images");
		    print "Creating $PROJECT_PATH/$project\n";
		}
		# get configuration		    		    
		print $new_sock "GET-CONFIG\n";
		print "recieving config\n";
		recieveFile("$PROJECT_PATH/$project/$project.mln",$new_sock);
		print "config file is transmitted\n";
		# get a list of needed filesystems
		$DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/$project.mln");
		my %targets;
		foreach my $host (getHosts()){
		    print "checking $host\n";
		    my $service_host = getScalar("/host/$host/service_host");
		    
		    if ($SERVICE_HOST and $service_host and $service_host ne $SERVICE_HOST ) {
			
			# host is remote, we cannot bother
			
		    } else { 
			    # host is local
			print "$host needs to be imported\n";
			my $plugin_in_charge = 0;
			if ( %PLUGIN_LIST ){
			    
			    my $plugin;
			    foreach $plugin (keys %PLUGIN_LIST){
				
				my $subcall = $plugin . "_getImportExportFiles"; 
				
				verbose("calling $subcall\n");
				if ( defined(&$subcall) and not $plugin_in_charge){
				    my %plugin_targets = &$subcall($host,$project);
				    foreach my $key ( keys %plugin_targets ){
					if ( $key ){
					    print "saving $key -> $plugin_targets{$key}\n";
					    $targets{$key} = $plugin_targets{$key};
					    $plugin_in_charge = 1;
					}
				    }
				}
				
			    }
			}    
			if ( $plugin_in_charge){
			    # no need to use native LVM or FILES
			} else {
			    # Native files or LVM
			    if ( getScalar("/host/$host/lvm")){
				my $vg = getScalar("/host/$host/lvm_vg");
				$vg = $DEFAULTS{'MLN_VG'} if not $vg;
				$targets{$host} = "/dev/$vg/$host.$project";
			    } else {
				$targets{$host} = "$PROJECT_PATH/$project/images/$host";
			    }
			}
		    }
		}

		# download them
		my $target;
		    
		foreach $target ( keys %targets ){
		    if ( $target ){
			print "sending: FILE:$target -> $targets{$target}\n";
			print $new_sock "FILE:$target\n";
			my $read = <$new_sock>;
			if ( $read eq "SEND-FILE\n" ){
			    print "preparing to recieve\n";
			    recieveFile($targets{$target},$new_sock);			    
			}
		    }
		}
		sleep 1;
		print $new_sock "DONE\n";
		
		# run import routine and send output to socket
		print "Calling importMLNproject\n";
		$SPAWNED_REMOTELY = 1;
		importMLNproject($project);
		
		print $new_sock "OUTPUT-END\n";
		# OUTPUT-END
	    
	    }
	} elsif ( $cline[0] eq "export" ) {
	    my $pid = fork();
	    
	    if ( $pid != 0 ){
		# we are inside the parent
		close ($new_sock);
		next;
	    } else {
		my %targets;
		my $project = $cline[1];
		print "Request for export of project $cline[1]\n";
		if ( stat("$PROJECT_PATH/$project/$project.mln")){
		    $DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/$project.mln");
		    print "Project found\n";
		    # find all local hosts
		    my $host;
		    foreach $host (getHosts()){
			print "checking $host\n";
			my $service_host = getScalar("/host/$host/service_host");

			if ($SERVICE_HOST and $service_host and $service_host ne $SERVICE_HOST ) {
			    
			    # host is remote, we cannot bother
			    		
			} else { 
			    # host is local
			    print "$host needs to be transmitted\n";
			    my $plugin_in_charge = 0;
			    if ( %PLUGIN_LIST ){
				
				my $plugin;
				foreach $plugin (keys %PLUGIN_LIST){
				    
				    my $subcall = $plugin . "_getImportExportFiles"; 
		
				    out("calling $subcall\n");
				    if ( defined(&$subcall) and not $plugin_in_charge){
					 my %plugin_targets = &$subcall($host,$project);
					foreach my $key ( keys %plugin_targets ){
					    if ( $key ){
						print "saving $key -> $plugin_targets{$key}\n";
						$targets{$key} = $plugin_targets{$key};
						$plugin_in_charge = 1;
					    }
					}
				    }
				    
				}
			    }    
			    if ( $plugin_in_charge){
				# no need to use native LVM or FILES
			    } else {
				# Native files or LVM
				 if ( getScalar("/host/$host/lvm")){
				     my $vg = getScalar("/host/$host/lvm_vg");
				     $vg = $DEFAULTS{'MLN_VG'} if not $vg;
				     $targets{$host} = "/dev/$vg/$host.$project";
				 } else {
				     $targets{$host} = "$PROJECT_PATH/$project/images/$host";
				 }
			     }
			}
		    }
		    my $target;
		    
		    foreach $target ( keys %targets ){
			if ( $target ){
			    print "sending: FILE:$target -> $targets{$target}\n";
			    sleep 1;
			    print $new_sock "FILE:$target\n";
			    print "Reading response\n";
			    my $read = <$new_sock>;
			    print "Read: $read";
			    if ( $read eq "SEND-FILE\n" ){
				print "preparing to send\n";
				if ( open (FILE,"cat $targets{$target} | gzip -c |")){
				    print "file opened\n";
				    my $scalar;
				    my $packetcounter = 0;
				    my $data_transfered;
				    while( read(FILE,$scalar,1448)){
					$data_transfered += 1448;
					$packetcounter++;
					if ($packetcounter == 4096 ){
					    my $data = int(($data_transfered / 1024) / 1024);
					    print "${data}MB\n";
					    $packetcounter = 0;
					}
					send ($new_sock,$scalar,"0");
				    }
				    print "Done\n";
				    close(FILE);
				}
				print $new_sock "OUTPUT-END\n";
				
				
			    }
			}
		    }
		    print $new_sock "DONE\n";
		    

		    
		    # find out where their filesystem is (ask plugins)
		    # get an array of files per VM
		    
		    print "Child exiting\n";
		    close($new_sock);
		    exit 0;
		}
	    }	    
	} elsif ( $cline[0] eq "migrate" ) {
	    
	    my $pid = fork();

	    if ( $pid != 0 ){
		# we are inside the parent
		close ($new_sock);
		next;
	    } else {
#		print "preparing for migration\n";
		my $reciever;
		my $filesource;
		my $line;
		my $size;
		if (stat("$PROJECT_PATH/$cline[1]/lock/$cline[3]")){
#		    print "lock-file found\n";
		    $line = `cat "$PROJECT_PATH/$cline[1]/lock/$cline[3]"`;
		    chomp $line;
#		    print "lock line: $line\n";
		    if ($line =~ /(\S+):(\S+):(\S+)/){
			$reciever = $1;
			$filesource = $2;
			$size = $3;
		    }
		} else {
		    print "no lock-file found at: $PROJECT_PATH/$cline[1]/lock/$cline[3]\n";
		}
		my $md = "$cline[1]:$cline[2]:$cline[3]:$cline[4]";
		print  " " . $reciever . " eq " . $new_sock->peerhost() ."\n";
#		if ( $MIGRATION_DATA{$md} and gethostbyname($cline[4]) eq $new_sock->peerhost() ){
		if ( $reciever eq $new_sock->peerhost() ){
		    $DATA_ROOT = buildDataTree("$PROJECT_PATH/$cline[1]/$cline[1].mln");
#		    print "building data root\n";
#		    my $lvm = getScalar("/host/$cline[3]/lvm");
#		    print "host uses lvm: $lvm\n";
#		    my $vg = getScalar("/host/$cline[3]/vg");
#		    $vg = $DEFAULTS{"MLN_VG"} unless $vg;
		    
		    # we seriously need to shut down the host first!		    
		    my $vg = getScalar("/host/$cline[3]/lvm_vg");
		    $vg = $DEFAULTS{"MLN_VG"} unless $vg;
		    my $filepath = getScalar("/host/$cline[3]/filepath");
		    my $live;
		    my $san;
		    my $path = getImagePath($cline[3],$cline[1]);
		    if ( isOnSan($cline[3],$cline[1],$path) ){
			print "is on san!!\n";
			if ( checkIfUp($cline[3],$cline[1],$DATA_ROOT) ){
			    print "Host is up!\n";
			    $live = "LIVE";
			} 
		    }
		    

		    print "sending: SIZE:$size:$live:$path\n";
		    print $new_sock "SIZE:$size:$live:$path\n";
		    my $reply = <$new_sock>;
#		    print "got reply: $reply";
		    if ( $reply eq "LIVE-MIGRATE\n" ){
			print "we are ready for live migration\n";
			print "xm migrate --live $cline[3].$cline[1] " . $new_sock->peerhost(). "\n";
			my $return = system("xm migrate --live $cline[3].$cline[1] " . $new_sock->peerhost() );
			print "live migration done. Return value $return\n";
			print $new_sock "LIVE-MIGRATE-DONE\n";
			executePlugin("releaseVMfilesystem",$cline[3],$cline[1]);
			removeLockOnImage($cline[3],$cline[1]);
		    } elsif ( $reply eq "SAN-ACCESS\n"  ) {
			print "host down but on san, no need to copy\n";
			removeLockOnImage($cline[3],$cline[1]);
		    } elsif ( $reply eq "GET-IMAGE\n" ){
			if ( checkIfUp($cline[3],$cline[1])){
			    print "host is up\n";
			    stopHost($cline[3],$cline[1]);
			}		    

						      # this is where we do the transfer
			my $file = $filesource;
			# if ( $lvm ){
			#     $file = "/dev/$vg/$cline[3].$cline[1]";
			# } else {
			#     $file = "$PROJECT_PATH/$cline[1]/images/$cline[3]";
			# }
			if ( open (FILE,"cat $file | gzip -c |")){
			    print "file opened\n";
			    my $scalar;
			    my $packetcounter = 0;
			    my $data_transfered;
			    while( read(FILE,$scalar,1448)){
				$data_transfered += 1448;
				$packetcounter++;
				if ($packetcounter == 4096 ){
				    my $data = int(($data_transfered / 1024) / 1024);
				    print "${data}MB\n";
				    $packetcounter = 0;
				}
				send ($new_sock,$scalar,"0");
			    }
			    print "Done\n";
			    close(FILE);
			}
			print $new_sock "OUTPUT-END\n";
			my $md5 = `md5sum $file`;
			print "md5 checksum: $md5\n";
			# next, we look for a ram-disk image and send that over as well 
			$reply = <$new_sock>;
			if ( $reply eq "OK\n" ){
			    print "Transfer OK\n";
			}
			if ( stat("$PROJECT_PATH/$cline[1]/$cline[3].ram") ){
			    print $new_sock "RAM-IMAGE\n";
			    $file = "$PROJECT_PATH/$cline[1]/$cline[3].ram";
			    if ( open (FILE,"cat $file | gzip -c |")){
				print "sending RAM image\n";
				my $scalar;
				my $packetcounter = 0;
				my $data_transfered;
				while( read(FILE,$scalar,1448)){
				    $data_transfered += 1448;
				    $packetcounter++;
				    if ($packetcounter == 4096 ){
					my $data = int(($data_transfered / 1024) / 1024);
					print "${data}MB\n";
					$packetcounter = 0;
				    }
				    send ($new_sock,$scalar,"0");
				}
				print "Done\n";
				close(FILE);
			    }
			    print $new_sock "OUTPUT-END\n";
			    $reply = <$new_sock>;
			    if ( $reply eq "OK\n" ){
				print "Transfer OK\n";
			    }
			}
			removeLockOnImage($cline[3],$cline[1]);
			exit 0;
		    } else {
			print "client aborted\n";
			close($new_sock);
			exit 0;
		    }
		} else {
		    print $new_sock "GOODBYE\n";
		    print "closing connection\n";
		    close($new_sock);
		    exit 0;
		}
		my $key;
		foreach $key (keys %MIGRATION_DATA){
		    print "OBSOLETE_MIGRATION_DATA: $key\n";
		}
		close($new_sock);
		exit 0;

	    }
	} elsif ( $cline[0] =~ /daemon_status/ ) {
	    print "daemon status request recieved\n";
	    my $pid = fork();
	    if ( $pid != 0 ){
		# we are inside the parent
		
		close ($new_sock);
		next;
	    } else {
		getStatus(0,0,1,0,1,"");

		# 0 number of projects
		# 1 number of nodes
		# 2 amount of used memory
		# 3 amount of memory left
		# 4 groups
		# 5 chunks
		
		my $DAEMON_MEMORY_LEFT;
		my $CURRENT_USAGE;
		if ( @XM_LIST_CACHE ){
		    $XM_LIST_CACHE[1] =~ /(\S+)\s+(\d+)\s+(\d+)\s+/;
		    $CURRENT_USAGE = $3;
		}
		
		$DAEMON_MEMORY_LEFT = `xm info 2>/dev/null | grep free_memory`;
		$DAEMON_MEMORY_LEFT =~ s/.*\: (\d+)/$1/;
		chomp $DAEMON_MEMORY_LEFT;
		$DAEMON_MEMORY_LEFT = "0" unless $DAEMON_MEMORY_LEFT;
		my $return_string =  "$NUM_RUNNING_PROJECTS:$NUM_RUNNING_HOSTS:$DAEMON_USED_MEMORY:". $DAEMON_MEMORY_LEFT . ":$DAEMON_MAX_MEMORY:" . getDaemonGroups();
		print "returning: $return_string\n";
		print $new_sock $return_string . "\n";
		# and then we get the xm list output aswell:
		# ( but only if we have an xm command)
		if ( @XM_LIST_CACHE ){
#		    print "sending xm output\n";
		    print $new_sock "XM-LIST-CACHE\n";
		    shift(@XM_LIST_CACHE);
		    prepareNetFlow();
		    prepareDiskActivity();
		    foreach (@XM_LIST_CACHE){
			chomp $_;
			my $vmname = $_;
			$vmname =~ s/^(\S+)\s+.*$/$1/g;
			$IFCONFIG_NETFLOW{$_} = "0 0" unless $IFCONFIG_NETFLOW{$_};
			$VBD_ACTIVITY{$vmname}{'writes'} = 0 unless $VBD_ACTIVITY{$vmname}{'writes'};
			$VBD_ACTIVITY{$vmname}{'reads'} = 0 unless $VBD_ACTIVITY{$vmname}{'reads'};
#			print "netflow_table($_): $IFCONFIG_NETFLOW{$_}\n";
#			print "NETWORK_TABLE: $vmname -> $NETWORK_TABLE{$vmname}\n";
			my $answer = $_ . " " .$IFCONFIG_NETFLOW{$_} . " " . $RESOURCE_TABLE{$_} . " " . $NETWORK_TABLE{$vmname} . " " . $VBD_ACTIVITY{$vmname}{'reads'} . " " . $VBD_ACTIVITY{$vmname}{'writes'} . " " . $RESOURCE_DELAY_TABLE{$_} . "\n";
			# print $answer . "\n";
			print $new_sock $answer; 
#		    print "line: $_";
		    }
		}
		@XM_LIST_CACHE = ();
		%VBD_ACTIVITY = ();
		print $new_sock "XM-LIST-CACHE-END\n";
		if ( @chunk_list ){
#		    print "sending chunk list\n";
		    print $new_sock "CHUNK-LIST\n";
		    foreach (@chunk_list){
			print $new_sock $_ . "\n";
		    }
		    print $new_sock "CHUNK-LIST-END\n";
		}
		print $new_sock "STATUS-LIST\n";
#		print "STATUS-LIST\n";
		foreach ( @STATUS_ARRAY ){
		    print $new_sock "$_\n";
#		    print "$_\n";
		}		
#		print "done\n";
		print $new_sock "STATUS-LIST-END\n";
		print $new_sock "OUTPUT-END\n";
		
		
		
#		print "closing socket\n";
		close($new_sock);
		exit 0;
	    }
	} elsif ( $cline[0] =~ /(start|stop)/ ) {
	    ###########################################
	    ### we want to start or stop a project
#	    startStopDaemon($new_sock,$1,$2);
	    my $option = $cline[3];
	    my $command = $cline[0];
	    my $project = $cline[1];
	    my $vm = $cline[2];
	    my $wait = $cline[4];

	    
	    my $rand = int(rand(10000));
		# now we know what project to work on.
	    print "$rand: client wants to $command $project $vm\n";
	    $vm = " -h $vm" if $vm;
	    if (stat("$PROJECT_PATH/$project") ) {
		my $peerhost = $new_sock->peerhost();
		print $new_sock "TICKET:$rand\n";
		close($new_sock);
		if ( $option eq "save" ){
		    $option = "-S";
		} elsif ($option eq "force" ){
		    $option = "-H";
		}
		my $wait = " -w $wait " if $wait;
		my $return;
		if ( $command eq "start" ){
		    $return = `$MLN -R start -p $project $vm`;		
		} elsif ( $command eq "stop" ) {
		    $return = `$MLN -R stop -p $project $vm $option $wait `;
		}
		open (LOG,">$CLIENT_TICKET_FOLDER/$rand") or print "error opening ticket: $!\n";
		print LOG "$peerhost\n";
		print "$return";
		print LOG "$return";
		close(LOG);
		
	    } else {
		print $new_sock "NO SUCH PROJECT\n";
		next;
	    }
	    close $new_sock;
	    next;
	    ##########################################
	}
    }
}

sub acquire_lock {
    while ( stat("$MLN_LOCKFILE")){
	out("sleeping while waiting for lock\n");
	sleep 2;
    }
    system("touch $MLN_LOCKFILE");
    out("Lock aquired\n");
    return;
}

sub release_lock {
    out("releasing lock\n");
    system("rm $MLN_LOCKFILE");
}

sub prepareDiskActivity {
    my @xm_list = @XM_LIST_CACHE;
    my @xentop;
#    shift(@xm_list);
    shift(@xm_list);
    open(XENTOP,"xentop -b -i 1 |");
    <XENTOP>;
    my $count;
    while ( my $line = <XENTOP> ){
	if ( not $line =~ /Domain-0/ ){
	    push(@xentop,$line);
	    $count++;
	}

    }
    if ( not $#xm_list == $#xentop ){
	print "XM list and Xentop did not give the same answer!\n";
    }

    for ( my $i = 0; $i < $count ; $i++ ){
	# print "XM LIST: $xm_list[$i]";
	# print "XENTOP: $xentop[$i]";
	my @xm_array = split /\s+/,$xm_list[$i];
	my @xentop_array = split /\s+/,$xentop[$i];
	print "setting r: $xentop_array[14], w: $xentop_array[15] for $xm_array[0]\n";
	$VBD_ACTIVITY{$xm_array[0]}{'reads'} = $xentop_array[14];
	$VBD_ACTIVITY{$xm_array[0]}{'writes'} = $xentop_array[15];
    }
    
}
sub prepareNetFlow {
    
    my $line;
    my $i;
    for ($i = 0; $i <= @IFCONFIG_CACHE; $i++){
	if ( $IFCONFIG_CACHE[$i] =~ /^vif(\d+)\.(\d+) / ){
	    my $id = $1;
	    $i += 6;
	    
#	    print "$id: $IFCONFIG_CACHE[$i]\n";
	    $IFCONFIG_CACHE[$i] =~ /RX bytes:(\d+) .*TX bytes:(\d+) /;
	    my $rx = $1;
	    my $tx = $2;
	    my @key = grep ( /^(\S+)\s+$id\s+/,@XM_LIST_CACHE );
	    if ( $key[0] ){
#		print "found key: $key[0]\n";
		chomp $key[0];
		if ($IFCONFIG_NETFLOW{$key[0]} =~ /(\d+) (\d+)/){
		    $IFCONFIG_NETFLOW{$key[0]} = ($rx + $1) . " " . ($tx + $2);
		} elsif ( $rx and $tx ) {
		    $IFCONFIG_NETFLOW{$key[0]} = "$rx $tx";
		} else {
		    $IFCONFIG_NETFLOW{$key[0]} = "0 0";
		}
#		print "$key[0]: $IFCONFIG_NETFLOW{$key[0]}\n";
	    }
	}
    }
}

sub isOnSan {
    
    my $host = $_[0];
    my $project = $_[1];
    my $path = $_[2];

    if ( $path ){
	foreach my $sanpath (keys %SAN_PATH){
	    print "testing $path with $sanpath\n";
	    if ( $path =~ /^$sanpath/ ){
		out("$path matches $sanpath\n"); 
		return 1;
	    }
	}
    }
    
    
    # if LVM:
    

    if ( getScalar("/host/$host/lvm")){
	my $vg = getScalar("/host/$host/lvm_vg");
	$vg = $DEFAULTS{"MLN_VG"} unless $vg;
	# is $vg on SAN_PATH -> return 1
	if ( $SAN_PATH{$vg} ){
	    verbose("$host is on SAN\n");
	    return 1;
	}
    
    }
    # if filepath:
    my $filepath = getScalar("/host/$host/filepath");    

    if ( $filepath ){
	# is $filepath on SAN_PATH (allow subdirectories) -> return 1    
	foreach my $path (keys %SAN_PATH){
	    if ( $filepath =~ /^$path(\/|\S+\/)$host\.$project/ ){
		out("$filepath matches $path\n"); 
		return 1;
	    }
	}
    }
    # get a correct path from plugin (plugin needs to create theoretical path, not check manually)
    
    
    
    # Not on a SAN  -> return 0
    return 0;
    
}

sub prepareForLeavingImage {
 
    my @array = split /:/,$_[0];
#    my $socket = $_[1];
    my $project = $array[0];
    my $reciever = $array[1];
    my $data = $_[1];
    return if $reciever eq $SERVICE_HOST; 
    print "reciever: $reciever\n";
    if ( not $array[1] =~ /(\d+)\.(\d+)\.(\d+)\.(\d+)/ ){ 
	$reciever = inet_ntoa(inet_aton($reciever));
	#        my $ipaddr = inet_ntoa("$reciever"); 
#	print "i
#	my $host = gethostbyaddr($ipaddr, AF_INET);
 #       $reciever = gethostbyname($array[1],AF_INET);
    }
    my $host = $array[2];
#    print "$reciever > $PROJECT_PATH/$project/lock/$host\n";
    my $authline = $reciever;
    my $filepath;
    my $size;
    my $lvm = getScalar("/host/$host/lvm",$data);
    if ( $lvm ){
	my $vg = getScalar("/host/$host/lvm_vg",$data);
	$vg = $DEFAULTS{"MLN_VG"} unless $vg;
	$filepath = "/dev/$vg/$host.$project";
	$size = `lvs --noheadings /dev/$vg/$host.$project 2>/dev/null` ;
	chomp $size;
#	print "size string was '$size'\n";
	$size =~ s/(.*) (\d+)(\.|,)(\d+)(M.*)/$2/;
	print "Current LVM size is $size\n";

    } else {
	my $fp = getScalar("/host/$host/filepath",$data);
	if ( $fp ){
	    $filepath = "$fp/$host.$project";
	} else {
	    $filepath = "$PROJECT_PATH/$project/images/$host";
	}
	$size = (stat("$filepath"))[7];
	$size = int(($size / 1024) / 1024);
	print "Size is ${size}M\n";
    }

    $authline .= ":" . $filepath . ":" . $size;
    verifyDirectories("$PROJECT_PATH/$project/lock");
    system("echo $authline > $PROJECT_PATH/$project/lock/$host");
}

sub getImagePath {
    my $host = $_[0];
    my $project = $_[1];
    my $data = $_[2];
    $data = $DATA_ROOT unless $data;
    my $lvm = getScalar("/host/$host/lvm",$data);
    if ( $lvm ){	
	my $vg = getScalar("/host/$host/lvm_vg",$data);
	$vg = $DEFAULTS{"MLN_VG"} unless $vg;
	return("/dev/$vg/$host.$project");
    } 

    my $filepath = getScalar("/host/$host/filepath",$data);    
    if ($filepath) {
	return "$filepath/$host.$project";
    }
    if ( %PLUGIN_LIST ){
	
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    
	    my $subcall = $plugin . "_getFilesystemPath"; 
#	    print "calling $subcall\n";
	    verbose("calling $subcall\n");
	    if ( defined(&$subcall) ){
		my $return = &$subcall($host,$project);
		if ( $return ){
		    return $return;
		}
	    }
	    
	}
    }    
    
    return "$PROJECT_PATH/$project/images/$host";
    
}


sub getImageSize {
    my $host = $_[0];
    my $project = $_[1];
    my $data = $_[2];
    $data = $DATA_ROOT unless $data;
    my $size;
    my $lvm = getScalar("/host/$host/lvm",$data);
    if ( $lvm ){	
	my $vg = getScalar("/host/$host/lvm_vg",$data);
	$vg = $DEFAULTS{"MLN_VG"} unless $vg;
	print "checking size for /dev/$vg/$host.$project\n";
	$size = `lvs --noheadings /dev/$vg/$host.$project 2>/dev/null` ;
	chomp $size;
#	print "size string was '$size'\n";
	$size =~ s/(.*) (\d+)(\.|,)(\d+)(M.*)/$2/;
	print "Current LVM size is $size\n";
    } else {
#			we use stat to get the correct size
	my $filepath = getScalar("/host/$host/filepath",$data);

	$filepath = "$PROJECT_PATH/$project/images/$host" unless $filepath;


	$size = (stat("$filepath"))[7];
	$size = int(($size / 1024) / 1024);
	print "Size is ${size}M\n";
    }
    return $size;
}
    
    

sub doOnRemote {

    my $opt_string = 'p:h:f:c:vds:wP:V:l:S';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
    
    my $port = $opt{p};
    $port = 34001 if not $port;
    my $live;
# initialize host and port
    if ( $opt{l} ){
	foreach (split /:/,$opt{l}){
	    print "adding live host $_\n";
	    $LIVE_LIST{$_} = 1;
	}
    }
    
    my $host = $opt{h};

    my $file = $opt{f};
    
    my $command = $opt{c};
    $VERBOSE = $opt{v};
    $DEBUG = $opt{d};
    #                      0       1     2     3       4      5    6    7    8
    initiateBuildClient($command,$host,$port,$file,$opt{s},$opt{w},0,$opt{V},1,$opt{S});

}

####
# Figure out if a project is distributed or not:
####

sub isDistributed {
    my $root = $DATA_ROOT;
    $root = $_[0] if $_[0];
    my @hosts = getHosts($root);
    my $host;
    my @array;
    foreach $host (@hosts){
	my $sh = getScalar("/host/$host/service_host",$root);
	if ( $SERVICE_HOST and $sh and $SERVICE_HOST ne $sh ){
	    push(@array,$sh);
	}
    }
    return @array;
}


sub collectTickets {
    
    return unless @PENDING_TICKETS;
    use IO::Socket;
    my $sleep = $_[0];
    my $silent = $_[1];
    $sleep = $DEFAULT_COLLECT_TICKETS_SLEEP unless $sleep; 
    my $ticket;
    my $message;
    my @output;

    while ( @PENDING_TICKETS ){
	if (not $message){
	    out("Collecting reports from servers...\n") unless $silent;
	    $message = 1;
	} else {
	    out(".") unless $silent;
	}
	my @tickets;	
	foreach $ticket (@PENDING_TICKETS){
#	    print "connecting to " . $ticket->host() . "\n";
	   
	    if ( $ticket and not $ticket->sock()){
		my $sock = new IO::Socket::INET(
		    PeerAddr => $ticket->host(),
		    PeerPort => $ticket->port(),
		    Proto    => 'tcp');
		
		
		$sock or (warn "no socket: $!" and return);
		print $sock "TICKET:". $ticket->ticket() . "\n";
		my $reply = <$sock>;
		if ( $reply eq "OUTPUT\n" ){		
		    print "[ output from " .$ticket->host() ." ]\n" if not $silent;
		    if ( $silent ){
			while ($reply = <$sock>) {
			    last if $reply eq "OUTPUT-END\n";
			    push(@output,$reply);
			}
		    } else {
			while ($reply = <$sock>) {
			    last if $reply eq "OUTPUT-END\n";
			    print "| " .$reply;
			}
			
		    }
		} else {
		    push(@tickets,$ticket);	
		}
	    } else {
#		print $ticket->host() . " has an open socket\n";
		my $reply;
		my $sock = $SOCKET_HOLDER[$ticket->sock()];
		if ( not $sock ){
		    print "sock not defined\n";
		}
		while ( $reply = <$sock> ) {

		    if ( $reply eq "OUTPUT-END\n"){
			close($sock);
			close($SOCKET_HOLDER[$ticket->sock()]);
			last;
		    } else {
			push(@tickets,$ticket);		
		    }
		    print "[" . $ticket->host() ."] $reply";
		}
	    }
	}
	@PENDING_TICKETS = @tickets;
#	print "waiting\n";
	sleep $sleep if @PENDING_TICKETS;
    }
    return @output;
}
##########################################
# When an image is migrated successfully
# we remove the lock on it
#########################################
sub removeLockOnImage {
    my $host = $_[0];
    my $project = $_[1];
    my $lockfile = "$PROJECT_PATH/$project/lock/$host";
    if (stat("$lockfile")){
	system("$shell{'RM'} $lockfile");
    }
}

sub initiateBuildClient {
    use Socket;    
    my $command = $_[0];
    my $host = $_[1];
    my $port = $_[2];
    my $file = $_[3];
    my $sleep = $_[4];
    my $wait = $_[5];
    my $tm = $_[6];
    my %push_images = %$tm;
    my $version = $_[7];
    my $disable_remotely_spawned = $_[8];
    my $restart_reconfigured = $_[9];
    $command = "reconfigure" if $command eq "rc";
    
    use IO::Socket;
    print "Sending project to $host:$port\n";
    my $sock = new IO::Socket::INET(
	                  PeerAddr => $host,
	                  PeerPort => $port,
	                  Proto    => 'tcp');
    
    $sock or (warn "no socket: $!" and return);
    
    my $reply;
#    print "printing command: $command\n";
#    STDOUT->autoflush(1);

    my $hostlist;
#    out("HOSTLIST: $HOSTLIST\n");
    $hostlist = $HOSTLIST;
    $hostlist =~ s/:/,/g;
    # if ($HOSTLIST){
    # 	foreach (split $HOSTLIST,/:/ ){
    # 	    $hostlist .= $_ . ",";
    # 	}
    # }
    $DATA_ROOT = buildDataTree($file);
    my $project_password = getScalar("/global/project_password");
    my $projectTag = getScalar("/global/project");
    
    my $live;
    foreach ( %LIVE_LIST ){
	$live .= $_ . ",";
    }
    $live =~ s/,$//;
    #                          0      1     2        3         4             5          6            7                  8                  9        10                       11
    my $command_string = "$command:$sleep:$wait:$projectTag:$hostlist:$SERVICE_HOST:$version:$project_password:$disable_remotely_spawned:$live:$restart_reconfigured:$RECONFIGURE_REBUILD";
    print "$command_string\n";
    print $sock $command_string . "\n";
    
    # we either have to wa
    $reply = scalar <$sock>;
    
    die "Got wrong reply from server: $reply\n" unless $reply eq "GIVE-FILE\n";
#    print "connection ok, sending project file\n";
    # starting to copy file:
#    open (FILE,A);
#    my $line;
#    print "opened file: $file\n";
#    while ( $line = <FILE> ){
#	print "$line";
#	print $sock $line;	
#    }
    printBlock($DATA_ROOT,"",$sock);
    print $sock "FILE-END\n";
    if ( keys %MIGRATION_DATA ){
	foreach (keys %MIGRATION_DATA ){
	    print $sock $_ . "\n";
	}
	print $sock "END-MIGRATIONS\n";
    } else {
	verbose("no migrations in this upgrade\n");
	print $sock "END-MIGRATIONS\n";
    }
    
    $reply = <$sock>; # ( NEED-OLD-FILE | GOT-OLD-FILE );
    
    if ( $reply eq "NEED-OLD-FILE\n" ){
	printBlock($OLD_DATA_ROOT,"",$sock);
	print $sock "FILE-END\n";
    } 
    
#    print "looking for images to push\n";
    if ( $PUSH_TARGETS{$host} ){
	my $line;
	foreach $line (keys %push_images ){
#	    print "checking out: $line\n"; 
	    if ( $line =~ /^$PROJECT:$host:(\S+):.*$/ ){
		my $image = $1;
		print "I need to push image $image\n";

		my $lvm = getScalar("/host/$image/lvm",$OLD_DATA_ROOT);
		my $vg = getScalar("/host/$image/lvm_vg",$OLD_DATA_ROOT);
		my $xen = getScalar("/host/$image/xen",$OLD_DATA_ROOT);
		$vg = $DEFAULTS{"MLN_VG"} unless $vg;
		# i need image size and path
		my $size = getImageSize($image,$PROJECT,$OLD_DATA_ROOT);
		my $path = getImagePath($image,$PROJECT,$OLD_DATA_ROOT);
		my $live;		
		print "$vg is on san: $SAN_PATH{$vg} and is up: " . checkIfUp($image,$PROJECT,$OLD_DATA_ROOT) . "\n";
		if ( isOnSan($image,$PROJECT,$OLD_DATA_ROOT) and $xen and checkIfUp($image,$PROJECT,$OLD_DATA_ROOT)){		    
		    $live = "LIVE";
		}
		print "PUSH:$image:$size:$live:$path\n";
		print $sock "PUSH:$image:$size:$live:$path\n";
		$reply = <$sock>;
		print "reply: $reply";
		my $file;
		if ($lvm){
#		    $file = "/dev/blablabla/$image.$PROJECT";
		    $file = "/dev/$vg/$image.$PROJECT";
		} else {
		    $file = "$PROJECT_PATH/$PROJECT/images/$image";
		}
		if ( $reply eq "GET-IMAGE\n"){
		    print "Host must be shut down before transfer. OUCH!!\n";
		    # shut down host!!
		      
		    if ( open (FILE,"cat $file | gzip -c |")){
#			print "file opened\n";
			my $scalar;
			my $counter;
			my $bytecounter;
			while( read(FILE,$scalar,1448)){
			    $bytecounter += 1448;
			    $counter++;
			    if ( $counter == 4096 ){
				print int(($bytecounter / 1024 ) / 1024) ."MB\n";
				$counter = 0;
			    }
			    send ($sock,$scalar,"0");
			}
#			print "Done\n";
			close(FILE);
			print "Done\n";
			print $sock "OUTPUT-END\n";
#			print "waiting for OK\n";
			# this is where i should incorporate a checksum
			$reply = <$sock>;
			if ( $reply eq "OK\n"){			    
			    print "transfer OK\n";
			}
			if ( stat("$PROJECT_PATH/$PROJECT/$image.ram") ){
			    print $sock "RAM-IMAGE\n";
			    $file = "$PROJECT_PATH/$PROJECT/$image.ram";
			    if ( open (FILE,"cat $file | gzip -c |")){
				print "sending RAM image\n";
				my $scalar;
				my $packetcounter = 0;
				my $data_transfered;
				while( read(FILE,$scalar,1448)){
				   # print "$packetcounter\n";
				    $data_transfered += 1448;
				    $packetcounter++;
				    if ($packetcounter == 4096 ){
					my $data = int(($data_transfered / 1024) / 1024);
					print "${data}MB\n";
					$packetcounter = 0;					
				    }
				    send ($sock,$scalar,"0");
				}
				print "Done\n";
				close(FILE);
			    }

			}
			print $sock "OUTPUT-END\n";
			$reply = <$sock>;
			if ( $reply eq "OK\n"){			    
#			    print "transfer OK\n";
			}
		    }
		} elsif($reply eq "LIVE-MIGRATE\n") {
		    print "got reply $reply";
		    print "Will live migrate\n";
		    system("xm migrate --live $image.$PROJECT $host");
		    my $temp = $DATA_ROOT;
		    $DATA_ROOT = $OLD_DATA_ROOT;
		    executePlugin("leavingLiveVM",$image,$PROJECT);
		    $DATA_ROOT = $temp;
		} elsif($reply eq "SAN-ACCESS\n") {
		    print "got reply $reply";
		    print "Host is on san, no need to copy\n";
		}
	    }
	}  
    }
#    print "nothing more to push\n";
    print $sock "END-PUSHING\n";
    
    
    $reply = <$sock>;
    # we might get a ticket, or we have to transfer a couple of files
    while ( not $reply =~ /TICKET:(\d+)\n/ ){
	if ($reply =~ /FILE:(\S+)\n/ ){ 
	    # we open a socket that is a tar of the file/folder:
	    my $filename = $1;
	    print "copying $filename\n";
	    
	    if (open (FILE,"tar -C $FILES_PATH -cz $filename |")){
#		print "file opened\n";
		print $sock "OUTPUT\n";
		my $scalar;
		while( read(FILE,$scalar,1448)){
		    print ".";
		    send ($sock,$scalar,"0");
		}
		print "\n";
		close(FILE);
		print $sock "OUTPUT-END";
	    }
	    # transfer the file
	    $reply = <$sock>;
	} else {
	    close($sock);
	    print "got wrong reply from server: $reply\n";
	    return;
	}
    }
    
    if ( $reply =~ /TICKET:(\d+)\n/ ){
#	print "got ok back, building started. Ticket $1 recieved.\n";
	my $ticket = new buildTicket;
	$ticket->host($host);
	$ticket->port($port);
	$ticket->ticket($1);
	$ticket->sock($#SOCKET_HOLDER + 2);
#	print "adding socket on position " . ( $#SOCKET_HOLDER + 2) . "\n";
	$SOCKET_HOLDER[$#SOCKET_HOLDER + 2] = $sock;
	push (@PENDING_TICKETS,$ticket);
    } else {
	print "Error, wrong reply: $reply\n";
    }
    
#    close $sock or die "close: $!";
   
}

sub executePlugin {
    my $name = $_[0];
    shift(@_);
    
    if ( %PLUGIN_LIST ){
	
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    
	    my $subcall = $plugin . "_$name"; 
#	    print "calling $subcall\n";
	    verbose("calling $subcall\n");
	    if ( defined(&$subcall) ){
		my $return = &$subcall(@_);
		verbose("$plugin returned $return\n");
	    }
	    
	}
    }    
    
}
sub executePluginExclusive {
    my $name = $_[0];
    shift(@_);
    
    if ( %PLUGIN_LIST ){
	
	my $plugin;
	foreach $plugin (keys %PLUGIN_LIST){
	    
	    my $subcall = $plugin . "_$name"; 
#	    print "calling $subcall\n";
	    verbose("calling $subcall\n");
	    if ( defined(&$subcall) ){
		my $return = &$subcall(@_);
		if ( $return ){
		    return $return;
		}
	    }
	    
	}
    }    
    
}


sub remoteStartClient {
    return if $SPAWNED_REMOTELY;
    use Socket;    
    my $command = $_[0];
    my $host = $_[1];
    my $port = $_[2];
    $port = 34001 unless $port;
    my $project = $_[3];
    my $vm = $_[4];
    my $option = $_[5];
    my $wait = $_[6];
    
    use IO::Socket;
#    print "conencting to $host, $port\n";
    my $sock = new IO::Socket::INET(
	                  PeerAddr => $host,
	                  PeerPort => $port,
	                  Proto    => 'tcp');
    
    $sock or (warn "no socket: $!" and return);
    
    my $reply;

    print $sock "$command:$project:$vm:$option:$wait\n";
    
    $reply = <$sock>;
        
    if ( $reply =~ /TICKET:(\d+)\n/ ) {
	close($sock);
	my $ticket = new buildTicket;
	$ticket->host($host);
	$ticket->port($port);
	$ticket->ticket($1);
	return $ticket;
    } else {
	print "got wrong reply from server $reply\n";
	close($sock);
	return 0;
    }

    
}
			   		       
sub startRemoteBuilds {
    
    return if $SPAWNED_REMOTELY;
#    print "Not remotely spawned, so i proceed\n";
    my @service_hosts;
    my $command = $_[0];
    my $version = $_[1];
    my $host;
    my %remote_targets;
    my $restart = $RESTART_UPGRADED;
#    print "service host: $SERVICE_HOST\n";
    foreach $host ( getHosts() ){ 
	my $service_host = getScalar("/host/$host/service_host");
	if ( not $service_host ){
	    $service_host = getScalar("/host/$host/location");
	}
	if ( $service_host and $service_host ne $SERVICE_HOST ){
#	    print "$host has service_host: $service_host on $SERVICE_HOST\n";
	    $remote_targets{$service_host} = 1;
	    push(@service_hosts,$service_host);
	}
    }
    
    if ($UPGRADE){
	foreach $host ( getHosts($OLD_DATA_ROOT) ){ 
	    my $service_host = getScalar("/host/$host/service_host",$OLD_DATA_ROOT);
	    if ( not $service_host ){
		$service_host = getScalar("/host/$host/location",$OLD_DATA_ROOT);
	    }
	    if ( $service_host and $service_host ne $SERVICE_HOST ){
		out("Will also contact $service_host regarding $host\n");
		$remote_targets{$service_host} = 1;
		$remote_targets{getScalar("/host/$host/service_host",$DATA_ROOT)} = 1;
	    }
	}	
    }
    
    if (keys %remote_targets) {
	
	my %push_images = registerLeavingImages();
	out("--- Running remote commands ---\n");
	# first, we contact all the hosts that we not need to push to
	foreach $host (keys %remote_targets) {
	    if ( not $PUSH_TARGETS{$host} and not $DOWN_SERVERS{$host}){		
		initiateBuildClient($command,$host,34001,"$CONFIGFILE",0,1,\%push_images,$version,"",$restart);
	    }
	}
	# next, we contact all the hosts we are pushing an image to
	foreach $host (keys %remote_targets) {
	    if (  $PUSH_TARGETS{$host} and not $DOWN_SERVERS{$host} ){
		initiateBuildClient($command,$host,34001,"$CONFIGFILE",0,1,\%push_images,$version,"",$restart);
	    }
	}
	fetchIncomingImages();
    }
    return @service_hosts;
}


sub doRemoteStarts {
#    print "do remote starts called\n";
    return if $SPAWNED_REMOTELY;
    my $project = $_[0];
    $DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/$project.mln");
    my $command = $_[1];
    my $option = $_[2];
    my $wait = $_[3];
    my $host;
    my $port;
    my %remote_targets;
#    print "service host: $SERVICE_HOST " . getScalar("/global/project") ."\n";
    foreach $host ( getHosts() ){ 
	my $service_host = getScalar("/host/$host/service_host");
	if ( not $service_host ){
	    $service_host = getScalar("/host/$host/location");
	}
	if ( $service_host and $service_host ne $SERVICE_HOST ){
#	    print "$host has service_host: $service_host on $SERVICE_HOST\n";
	    $remote_targets{$service_host} = 1;
	}
    }
    if (keys %remote_targets) {
	foreach $host (keys %remote_targets) {
	    my $ticket = remoteStartClient($command,$host,$port,getScalar("/global/project"),"",$option,$wait);
	    if ( $ticket ){
		push(@PENDING_TICKETS,$ticket);
	    }
	}
    }
    
}

sub getHosts {
    
    my $root = $_[0];
    if ( not $root ){
	$root = $DATA_ROOT;
    }
    my @array;

    # s mln xenguard skal funke ogs n.. 
    # hvor de start/stop scriptene skal lages burde vi finne ut av, samt det LV greiene da :)
    # ok
    
    if ( $root and $root->blocks("host")){
	foreach (keys %{$root->blocks("host")->blocks} ){
	    push(@array,getValue($_));
	}
    }
    return @array;
}

sub getSuperclasses {
    
    my $root = $_[0];
    if ( not $root ){
	$root = $DATA_ROOT;
    }
    my @array;
    foreach (keys %{$root->blocks("superclass")->blocks} ){
	push(@array,$_);
    }
    return @array;
}

sub showDaemonStatus {
    
    my $opt_string = 'lg:rCxsva:D';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
    
    %HOST_INFO = ();
    %PROJECT_INFO = ();
    $VERBOSE = $opt{v};
    $COLORS = $opt{C};
    my $summary_only = $opt{s};
    my $list_only = $opt{x};
    my $long = $opt{l};
    my $local;
    my $groups = $opt{g};
    my $raw = $opt{r};
    my $added_files = $opt{a};
    my $fetch_start;
    my $fetch_stop;
    my $USE_DATABASE = $opt{D};
    my @query_list;
    if ( $list_only and $summary_only ){
	print "-x and -s are mutually exlusive\n";
	exit 1;
    }
    if ( not $groups ) {
	@query_list = @DAEMON_STATUS_QUERY_HOSTS;
    } else {
	my @gr = split /,/,$groups;
	my $g;
	foreach $g (@gr){
	    verbose("adding hosts from group $g\n");
	    push(@query_list,@{$DAEMON_GROUPS{$g}});
	}
    }

#    my $absent;    
    my @absent_list;
    my $max_daemon_name_length = 0;
    if ( not $local ){
	my $server;
	foreach $server (@query_list){
	    if (length($server) > $max_daemon_name_length ){
		 $max_daemon_name_length = length($server);
	    }
	}
#	print "max length: $max_daemon_name_length\n";
	if ( not $raw and not $list_only){
	    out("Server" . " " x ($max_daemon_name_length - 6) ." #proj #vms Mem.Used Mem.Ava Groups\n","cyan");
	    out("-" x ( $max_daemon_name_length - 6) . "----------------------------------------------\n","cyan");
	}
	my @sum;
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime time;
	$year += 1900;
	$mon += 1;
	
	$min = "0$min" if $min < 10;
	$mon = "0$mon" if $mon < 10;
	$mday = "0$mday" if $mday < 10;
	$sec = "0$sec" if $sec < 10;
	$hour = "0$hour" if $hour < 10;
	$fetch_start = "$year-$mon-$mday $hour:$min:$sec";

	foreach $server (@query_list){
	    $STATUS_MAX_VM_NAME_LENGTH = 0;
	    my @status = getDaemonStatus($server);
	    # 0 number of projects
	    # 1 number of nodes
	    # 2 amount of used memory
	    # 3 amount of memory left
	    if ( $raw ){
		if ( $status[0] =~ /\d+/ ){
		    print "$server,$status[0],$status[1],$status[2],$status[3],$status[4]\n";
		}
	    } elsif ( not $list_only ){
		print "$server". " " x ($max_daemon_name_length - length($server)) ." ";
		$sum[0] += $status[0];
		if ( $status[0] =~ /\d+/ ){
		    print " " x ( 5 - length("$status[0]")) . "$status[0] ";

		} else {
		    $status[0] = "n/a";
		    out(" " x ( 5 - length("$status[0]")) . "$status[0] ","red");
		    push(@absent_list,$server);
   		}

		$sum[1] += $status[1];
		if ($status[1] =~ /\d+/ ){
		    print " " x ( 4 - length("$status[1]")) . "$status[1] ";		    
		} else {
		$status[1] = "n/a";
		    out(" " x ( 4 - length("$status[1]")) . "$status[1] ","red");
		}
		$sum[2] += $status[2];
		if ($status[2] =~ /\d+/){
		    print " " x ( 8 - length("$status[2]")) . "$status[2] ";
		} else {
		    $status[2] = "n/a";
		    out(" " x ( 8 - length("$status[2]")) . "$status[2] ","red");
		}
		$sum[3] += $status[3];

		if ( $status[3] =~ /\d+/ ){
		    print " " x ( 7 - length("$status[3]")) . "$status[3] ";
		} else {
		    $status[3] = "n/a";		    
		    out(" " x ( 7 - length("$status[3]")) . "$status[3] ","red");
		}
		
		$DAEMON_GROUP_INDEX{$server} = "n/a" unless $DAEMON_GROUP_INDEX{$server};
                print " $DAEMON_GROUP_INDEX{$server}\n";		
	    }
	}
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime time;
	$year += 1900;
	$mon += 1;
	
	$min = "0$min" if $min < 10;
	$mon = "0$mon" if $mon < 10;
	$mday = "0$mday" if $mday < 10;
	$sec = "0$sec" if $sec < 10;
	$hour = "0$hour" if $hour < 10;
	$fetch_stop = "$year-$mon-$mday $hour:$min:$sec";

	if ( $raw ){
	    exit 0;
	}
	if ( not $raw and not $list_only ){
	    out("-" x ( $max_daemon_name_length - 6) . "----------------------------------------------\n","cyan");
	    print "Total:" . " " x ($max_daemon_name_length - 5);
	    
	    $sum[0] = "n/a" unless $sum[0];
	    print " " x ( 5 - length("$sum[0]")) . "$sum[0] ";

	    $sum[1] = "n/a" unless $sum[1];
	    print " " x ( 4 - length("$sum[1]")) . "$sum[1] ";

	    $sum[2] = "n/a" unless $sum[2];
	    print " " x ( 8 - length("$sum[2]")) . "$sum[2] ";

	    $sum[3] = "n/a" unless $sum[3];
	    print " " x ( 7 - length("$sum[3]")) . "$sum[3]\n";

	    
	}
	# this is were we print out the xm list for all the xen servers
	# if data is available, it will be in $XM_LIST_RESULT{$server}
	my $header = 0;

	# foreach $server (@query_list){
	#     if (not $XM_LIST_RESULT{$server} ){
	# 	$absent++;
	#     }
	# }
	if ( @absent_list > 5 and not $long ){
	    print "\n";
	    out("WARNING: more that 5 servers did not respond!\nUse the -l option to get the complete output\n","red");
	} else {
	    foreach $server ( @absent_list ){

		if ( not $header ){
		    print "\n";
		    out("Hosts that did not answer:\n","red");
		    out("-" x ( $max_daemon_name_length - 6) . "----------------------------------------------\n","red");
		    $header = 1;
		}
		print "$server: n/a\n";
	    }
	
	}
	
#	printHash(\%HOST_INFO);
#	printHash(\%PROJECT_INFO);
	my $redundancy_factor = get_redundancy_factor();
	out("Redundancy factor: " . scalar(keys %HOST_INFO) . " / " . $redundancy_factor . "\n");

	# get storge conflict table
	my $storage_conflict_table = get_storage_conflict_table();
	out("Storage conflicts: " . sprintf("%f",$storage_conflict_table) . "\n");

	out("Service host         Storage Conflicts\n");
	out("--------------------------------------\n");
	foreach my $server ( sort {$LOCATION_CONFLICT_TABLE{$b} <=> $LOCATION_CONFLICT_TABLE{$a}} keys %LOCATION_CONFLICT_TABLE ){
	    out("$server" . " " x ( $max_daemon_name_length - 6) . $LOCATION_CONFLICT_TABLE{$server} . "\n");
	}
#	out("Location conflicts: " . sprintf("%f",$storage_conflict_table) . "\n");
	
	
	if ( $added_files ){
	    my @files = split /,/,$added_files;
	    foreach my $file (@files){
		out("Adding file: $file\n");
		$DATA_ROOT = buildDataTree($file);
#		assignHostsToSwitches();
		my @new_hosts = getHosts();
		my %switches;
		my $host;
		foreach $host (@new_hosts){
		    my $if;
		    my %ifs = getHash("/host/$host/network");
		    foreach $if (keys %ifs) { 
			my $switch = getScalar("/host/$host/network/$if/switch");
			if ( $switch ) {
			    $switches{$switch}{$host} = 1;
			}
		    }
		}


		my $project = getScalar("/global/project");
	        %chunked_hosts = ();
		foreach my $new_host ( @new_hosts ){
		    
		    $PROJECT_INFO{$project}{$new_host}{"memory"} = getScalar("/host/$new_host/memory");
		    my $sh = getScalar("/host/$new_host/service_host");
		    $HOST_INFO{$sh}{"free_memory"} -= $PROJECT_INFO{$project}{$new_host}{"memory"};
		    if ( $HOST_INFO{$sh}{"free_memory"} < 0 ){
			print "error adding project $project: $sh is out of memory\n";
			exit 1;
		    }
		    
		    
		    if ( not $chunked_hosts{$new_host} ){
			$chunked_hosts{$new_host} = 1;
				my @switches_in_chunk;
				my @vms_in_chunk;

				verbose("checking chunk from $new_host.$project\n");
				push(@vms_in_chunk,"$new_host");
				
				my %nics = getHash("/host/$new_host/network");
				foreach my $nic (keys %nics)
				{
#				    print "\t\tFound NIC $nic\n";
				    # check if the nic is connected to a switch
				    if ( $nics{$nic}{"switch"})
				    {
					my $switch = $nics{$nic}{"switch"};
					push(@switches_in_chunk,$switch);
					
#					print "\t\t\tNIC $nic is conencted to " . $switch ."\n";
					my @hosts_on_lan = keys %{$switches{$switch}};
					foreach my $host_on_lan (@hosts_on_lan)
					{
#					    print "working with $host_on_lan\n";
					    if ( not $chunked_hosts{$host_on_lan} ){
						$chunked_hosts{$host_on_lan} = 1;
						push(@vms_in_chunk,"$host_on_lan");
						foreach (get_chunk_tree($host_on_lan,$project,\%switches,$DATA_ROOT,$switch)){
#						    print "adding $_ to chunk\n";
						    push(@vms_in_chunk,$_);
						}
					    }
					    #			    get_chunk_tree_from_vm($host_on_lan,$project,$switch,\%vms,\@switches_in_chunk,\@vms_in_chunk);
					}
				    }
				}
			        my $chunk_memory;
				my $chunk = "$project : "; 
				foreach (@vms_in_chunk){
#				    print "vms in chunk: $_\n";
				    $chunk .= $_ . " : ";
				    my $mem = getScalar("/host/$_/memory");
				    $mem =~ s/(\d+)M/$1/;
				    $chunk_memory += $mem;
				    
		#		    $project_chunks[$chunk_counter][$vm_counter++] = $_;
				}
		#		$chunk_counter++;
#			print "adding chunk $chunk $chunk_memory\n";
			        $HOST_INFO{$sh}{"chunks"}{$chunk} = $chunk_memory;
			    }

		    
		}		
	    }
	    my $redundancy_factor = get_redundancy_factor();
	    out("New Redundancy factor: " . scalar(keys %HOST_INFO) . " / " . $redundancy_factor . "\n");
	}

	foreach $server ( @absent_list ){ 
	    $HOST_INFO{$server}{"down"} = 1;
	}

	if ($USE_DATABASE){
	    populateDB($fetch_start,$fetch_stop);
	    
	}

	
	
	if ( $summary_only ) {
	    exit 0;
	}
	print "\n";
	$STATUS_MAX_VM_NAME_LENGTH = 8 unless $STATUS_MAX_VM_NAME_LENGTH;	
	foreach $server (@query_list){
	    if ( $XM_LIST_RESULT{$server} ){
#		print "\n";		

		out("$server  name.project" . " " x ( $STATUS_MAX_VM_NAME_LENGTH - 8 ) . " ID  Mem.Used  VCPU  Status  VCPU.sec   RX.bytes  TX.bytes  Storage" . " \n","cyan");
#		out("-" x ( $max_daemon_name_length - 3) . "-" x ( $STATUS_MAX_VM_NAME_LENGTH ) . "----------------------------------------------\n","cyan");
		foreach (@{$XM_LIST_RESULT{$server}} ){
		    my @line = split /\s+/,$_;
		    print "$server  " . $line[0] . " " x ( $STATUS_MAX_VM_NAME_LENGTH - length($line[0]) + 7 - length($line[1])) . $line[1];
		    print " " x ( 10 - length($line[2])) . $line[2];
		    print " " x ( 6 - length($line[3])) . $line[3];
		    print "  " . $line[4];
		    print " " x ( 10 - length($line[5])) . $line[5] . " ";
#		    $line[6] = "0" unless $line[6];
		    print " " x ( 10 - length($line[6])) . $line[6];
#		    $line[7] = "0" unless $line[7];
		    print " " x ( 10 - length($line[7])) . $line[7];
		    print "  " . $line[8];
		    print "\n";
		}
	    } 
	}
	%XM_LIST_RESULT = ();
    }
}

sub allHostsDown {
    
    foreach ( keys %{$PROJECT_INFO{$_[0]}} ){
	if ( $PROJECT_INFO{$_[0]}{$_}{"state"} eq "up" ){
	    return 0;
	}
    }
    return 1;
}

sub checkDBexistence {
    my $dbh = $_[0];
    my $show_query = $dbh->prepare("SHOW TABLES");
    $show_query->execute();
    if ( $show_query->fetchrow_array() ){
	verbose("database exists\n");
		
    } else {
	verbose("Database empty, initializing database\n");
	my $create_db_query = "SET FOREIGN_KEY_CHECKS=0;";
	my $create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE Status_Description ( statusID int(11) UNSIGNED NOT NULL AUTO_INCREMENT, description varchar(100), PRIMARY KEY(statusID) );";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE Projects (    projectID int(11) UNSIGNED NOT NULL AUTO_INCREMENT,    name varchar(50),    startDate date,    comments varchar(200),    PRIMARY KEY(projectID) );";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE Priority_Description (    priorityID int(11) UNSIGNED NOT NULL AUTO_INCREMENT,    description varchar(100),    PRIMARY KEY(priorityID));";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE Metainformation_MLN ( variable varchar(50), value varchar(50) );";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE Links (    linkID int(11) UNSIGNED NOT NULL AUTO_INCREMENT,    url varchar(100),    name varchar(50),    PRIMARY KEY(linkID));";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

       	$create_db_query = "CREATE TABLE Servers (    serverID int(11) UNSIGNED NOT NULL AUTO_INCREMENT,    name varchar(50),    memTotalAvailable double(15,3),    comments varchar(200),    PRIMARY KEY(serverID));";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE VirtualMachines (    vmID int(11) UNSIGNED NOT NULL AUTO_INCREMENT,    name varchar(50),    startDate date,    comments varchar(200),    projectID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(vmID),    CONSTRAINT Ref_05 FOREIGN KEY (projectID_FK)    REFERENCES Projects(projectID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE VM_Connection (    connectionID int(11) UNSIGNED NOT NULL AUTO_INCREMENT,    vmID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    nameNetworkCard varchar(50),    nameConnection varchar(50),    PRIMARY KEY(connectionID, vmID_FK),    CONSTRAINT Ref_06 FOREIGN KEY (vmID_FK)    REFERENCES VirtualMachines(vmID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

       	$create_db_query = "CREATE TABLE Groups (    nameGroup varchar(50) NOT NULL,    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    comments varchar(200),    PRIMARY KEY(nameGroup, serverID_FK),    CONSTRAINT Ref_09 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE State_Server (    timeLastUpdate timestamp(14) NOT NULL,    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    numVMs int(11),    numProjects int(11),    cpuSeconds double(15,3),    memUsed double(15,3),    statusServer_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(timeLastUpdate, serverID_FK),    CONSTRAINT Ref_01 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_10 FOREIGN KEY (statusServer_FK)    REFERENCES Status_Description(statusID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

       	$create_db_query = "CREATE TABLE State_Connection (    timeLastUpdate timestamp(14) NOT NULL,    connectionID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    vmID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    networkTrafficIN double(15,3),    networkTrafficOUT double(15,3),    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(timeLastUpdate, connectionID_FK, vmID_FK),    CONSTRAINT Ref_08 FOREIGN KEY (connectionID_FK, vmID_FK)    REFERENCES VM_Connection(connectionID, vmID_FK)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_14 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE State_Project (    timeLastUpdate timestamp(14) NOT NULL,    projectID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    priority_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    statusProject_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(timeLastUpdate, projectID_FK),    CONSTRAINT Ref_02 FOREIGN KEY (projectID_FK)    REFERENCES Projects(projectID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_11 FOREIGN KEY (statusProject_FK)    REFERENCES Status_Description(statusID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_12 FOREIGN KEY (priority_FK)    REFERENCES Priority_Description(priorityID)    ON DELETE NO ACTION    ON UPDATE NO ACTION    );";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE State_VirtualMachine (	    timeLastUpdate timestamp(14) NOT NULL,	    vmID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',	    cpuSeconds double(15,3),	    memory double(15,3),   diskIOread int(11), diskIOwrite int(11),    locationFilesystem varchar(100),   technology varchar(50),    numCPUs int(11),    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    statusVM_FK int(11) UNSIGNED NOT NULL DEFAULT '0',  diskDelay int(11) DEFAULT 0,  PRIMARY KEY(timeLastUpdate, vmID_FK),    CONSTRAINT Ref_03 FOREIGN KEY (vmID_FK)    REFERENCES VirtualMachines(vmID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_04 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_13 FOREIGN KEY (statusVM_FK)    REFERENCES Status_Description(statusID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE State_Server_Last (    timeLastUpdate timestamp(14) NOT NULL,    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    numVMs int(11),    numProjects int(11),    cpuSeconds double(15,3),    memUsed double(15,3),    statusServer_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(timeLastUpdate, serverID_FK),    CONSTRAINT Ref_01 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_10 FOREIGN KEY (statusServer_FK)    REFERENCES Status_Description(statusID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

       	$create_db_query = "CREATE TABLE State_Connection_Last (    timeLastUpdate timestamp(14) NOT NULL,    connectionID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    vmID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    networkTrafficIN double(15,3),    networkTrafficOUT double(15,3),    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(timeLastUpdate, connectionID_FK, vmID_FK),    CONSTRAINT Ref_08 FOREIGN KEY (connectionID_FK, vmID_FK)    REFERENCES VM_Connection(connectionID, vmID_FK)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_14 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE State_Project_Last (    timeLastUpdate timestamp(14) NOT NULL,    projectID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    priority_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    statusProject_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(timeLastUpdate, projectID_FK),    CONSTRAINT Ref_02 FOREIGN KEY (projectID_FK)    REFERENCES Projects(projectID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_11 FOREIGN KEY (statusProject_FK)    REFERENCES Status_Description(statusID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_12 FOREIGN KEY (priority_FK)    REFERENCES Priority_Description(priorityID)    ON DELETE NO ACTION    ON UPDATE NO ACTION    );";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE State_VirtualMachine_Last (	    timeLastUpdate timestamp(14) NOT NULL,	    vmID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',	    cpuSeconds double(15,3),	    memory double(15,3),   diskIOread int(11), diskIOwrite int(11),    locationFilesystem varchar(100),    technology varchar(50),    numCPUs int(11),    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    statusVM_FK int(11) UNSIGNED NOT NULL DEFAULT '0',  diskDelay int(11) DEFAULT 0,  PRIMARY KEY(timeLastUpdate, vmID_FK),    CONSTRAINT Ref_03 FOREIGN KEY (vmID_FK)    REFERENCES VirtualMachines(vmID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_04 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_13 FOREIGN KEY (statusVM_FK)    REFERENCES Status_Description(statusID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE State_Server_Previous (    timeLastUpdate timestamp(14) NOT NULL,    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    numVMs int(11),    numProjects int(11),    cpuSeconds double(15,3),    memUsed double(15,3),    statusServer_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(timeLastUpdate, serverID_FK),    CONSTRAINT Ref_01 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_10 FOREIGN KEY (statusServer_FK)    REFERENCES Status_Description(statusID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

       	$create_db_query = "CREATE TABLE State_Connection_Previous (    timeLastUpdate timestamp(14) NOT NULL,    connectionID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    vmID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    networkTrafficIN double(15,3),    networkTrafficOUT double(15,3),    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(timeLastUpdate, connectionID_FK, vmID_FK),    CONSTRAINT Ref_08 FOREIGN KEY (connectionID_FK, vmID_FK)    REFERENCES VM_Connection(connectionID, vmID_FK)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_14 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE State_Project_Previous (    timeLastUpdate timestamp(14) NOT NULL,    projectID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    priority_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    statusProject_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    PRIMARY KEY(timeLastUpdate, projectID_FK),    CONSTRAINT Ref_02 FOREIGN KEY (projectID_FK)    REFERENCES Projects(projectID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_11 FOREIGN KEY (statusProject_FK)    REFERENCES Status_Description(statusID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_12 FOREIGN KEY (priority_FK)    REFERENCES Priority_Description(priorityID)    ON DELETE NO ACTION    ON UPDATE NO ACTION    );";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "CREATE TABLE State_VirtualMachine_Previous (	    timeLastUpdate timestamp(14) NOT NULL,	    vmID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',	    cpuSeconds double(15,3),	    memory double(15,3),    diskIOread int(11), diskIOwrite int(11),    locationFilesystem varchar(100),    technology varchar(50),    numCPUs int(11),    serverID_FK int(11) UNSIGNED NOT NULL DEFAULT '0',    statusVM_FK int(11) UNSIGNED NOT NULL DEFAULT '0',  diskDelay int(11) DEFAULT 0,  PRIMARY KEY(timeLastUpdate, vmID_FK),    CONSTRAINT Ref_03 FOREIGN KEY (vmID_FK)    REFERENCES VirtualMachines(vmID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_04 FOREIGN KEY (serverID_FK)    REFERENCES Servers(serverID)    ON DELETE NO ACTION    ON UPDATE NO ACTION,    CONSTRAINT Ref_13 FOREIGN KEY (statusVM_FK)    REFERENCES Status_Description(statusID)    ON DELETE NO ACTION    ON UPDATE NO ACTION);";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	
	
	$create_db_query = "SET FOREIGN_KEY_CHECKS=1;";

	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = " INSERT INTO Priority_Description (priorityId, description) VALUES (1, 'Low');";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = " INSERT INTO Priority_Description (priorityId, description) VALUES (2, 'Normal');";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	
	$create_db_query = " INSERT INTO Priority_Description (priorityId, description) VALUES (3, 'High');";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "	INSERT INTO Status_Description (statusId, description) VALUES (1, 'Running');";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "	  INSERT INTO Status_Description (statusId, description) VALUES (2, 'Stopped'); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "	INSERT INTO Status_Description (statusId, description) VALUES (3, 'Broken'); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "	INSERT INTO Status_Description (statusId, description) VALUES (4, 'Inconsistent'); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Last_Update', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Last_Update_Finish', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Last_Update_UNIX', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Last_Update_Finish_UNIX', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	
	
	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Previous_Update_UNIX', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Previous_Update_Finish_UNIX', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Previous_Update', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Previous_Update_Finish', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	
	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Fetch_Data_Start', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();
	$create_db_query = "	INSERT INTO Metainformation_MLN (variable, value) VALUES ('Fetch_Data_Finish', ''); ";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

	$create_db_query = "INSERT INTO Links (linkID, url, name) VALUES (1,'http://mln.sourceforge.net/','The MLN project');";
	$create_query = $dbh->prepare($create_db_query);
	$create_query->execute();

    }

}

sub populateDB {
    
    my $fetch_start = $_[0];
    my $fetch_stop = $_[1];
    
    eval {require DBI; 1}; 
    
    verbose("database: $DEFAULTS{'db_name'}\n");
    my $dbh = DBI->connect("DBI:mysql:$DEFAULTS{'db_name'}",$DEFAULTS{'db_user'},$DEFAULTS{'db_password'});
    if ( $dbh ){
	my %serverID_table;
	my %projectID_table;
	my $update_time = time;
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime $update_time;
	$year += 1900;
	$mon += 1;
	
	$min = "0$min" if $min < 10;
	$mon = "0$mon" if $mon < 10;
	$mday = "0$mday" if $mday < 10;
	$sec = "0$sec" if $sec < 10;
	$hour = "0$hour" if $hour < 10;
	my $time = "$year-$mon-$mday $hour:$min:$sec";
	verbose("success: ($update_time) $time\n");

#	my @tables = $dbh->tables();
	
#	foreach (@tables) {	    
#	    print "$_\n";	    
#	}
	
#	printHash(\%{$HOST_INFO{"broken.vlab.iu.hio.no"}});
#	printHash(\%PROJECT_INFO);
#	exit;
	# 1 For all the servers

	# Check if the DB i[As existent, if not, initialize the DB: 
	
	checkDBexistence($dbh);

	my $get_last =  $dbh->prepare("SELECT value from Metainformation_MLN where variable='Last_Update_UNIX';");
	$get_last->execute();
	my @array = $get_last->fetchrow_array();
	
	my $last_start_insert = $array[0];
	print "last timestamp: $last_start_insert\n";
	
	my $get_last =  $dbh->prepare("SELECT value from Metainformation_MLN where variable='Last_Update';");
	$get_last->execute();
	my @array = $get_last->fetchrow_array();
	
	my $last_start_insert_date = $array[0];
	print "last timestamp: $last_start_insert_date\n";
	
	my $start_insert = $dbh->prepare("UPDATE Metainformation_MLN set value='$last_start_insert' where variable='Previous_Update_UNIX';");
	$start_insert->execute();
	my $start_insert = $dbh->prepare("UPDATE Metainformation_MLN set value='$last_start_insert_date' where variable='Previous_Update';");
	$start_insert->execute();		
	
	my $start_insert = $dbh->prepare("UPDATE Metainformation_MLN set value='$time' where variable='Last_Update';");
	$start_insert->execute();
	my $start_insert = $dbh->prepare("UPDATE Metainformation_MLN set value='$update_time' where variable='Last_Update_UNIX';");
	$start_insert->execute();
	foreach my $server (keys %HOST_INFO){

	    # 1a check if the servers are defined
#	    print "checking if $server is present in DB\n";
	    my $check_query = "SELECT serverID FROM Servers AS s WHERE s.name = '$server';";
	    my $server_status = $dbh->prepare($check_query);
	    $server_status->execute();
	    my $serverID;
	    if ( $server_status ){

		my @line = $server_status->fetchrow_array();
		verbose("serverID for $server is '$line[0]'\n");
		if ( $line[0] == 0 and not $HOST_INFO{$server}{"down"}){
		    # server is not present, adding to the database
		    verbose("Inserting new server into database\n");
		    # get last server ID
		    my $id_query = $dbh->prepare("SELECT Ifnull(MAX(serverID),0) FROM Servers;");
		    $id_query->execute();
		    my @ar = $id_query->fetchrow_array();
		    my $max_id = $ar[0]; 
#		    print "max id: $max_id, next: " . ($max_id + 1) . "\n";
		    $serverID = $max_id + 1;
#		    print "INSERT INTO Servers(serverID,name,memTotalAvailable) VALUES ( " . ($max_id + 1) . ",$server,$HOST_INFO{$server}{'max_memory'});\n";
#		    print "INSERT INTO Servers(serverID,name,memTotalAvailable) VALUES ( " . ($max_id + 1) . ",'$server',$HOST_INFO{$server}{'max_memory'});";
#		    print "INSERT INTO Servers(serverID,name,memTotalAvailable) VALUES ( " . ($max_id + 1) . ",'$server',$HOST_INFO{$server}{'max_memory'});";
		    my $insert_query_string;
		    if ( $HOST_INFO{$server}{'max_memory'} ){
			$insert_query_string = "INSERT INTO Servers(serverID,name,memTotalAvailable) VALUES ( " . ($max_id + 1) . ",'$server', $HOST_INFO{$server}{'max_memory'});";
		    } else {
			$insert_query_string = "INSERT INTO Servers(serverID,name,memTotalAvailable) VALUES ( " . ($max_id + 1) . ",'$server',0);";			
		    }
#		    print "$insert_query_string" . "\n";
		    my $insert_query = $dbh->prepare($insert_query_string);
		    $insert_query->execute();
		    
		} else {
		    $serverID = $line[0];
		}
		
	    } else {
		print "fail $!\n";
	    }
#	    exit;
	    # 1b enter state information about the server
	    # if the state update fails, the server is not created
	    
	    # info for update: time, serverID_FK, numVMs, numProjects, cpuSeconds, memUsed, status, vm_cpuSeconds
	    my $numVMs;
	    my $numProjects;
	    
	    $serverID_table{$server} = $serverID;
	    if ($serverID){

		my $previous_present = $dbh->prepare("SELECT timeLastUpdate, serverID_FK, numVMs, numProjects, memUsed, statusServer_FK, cpuSeconds from State_Server_Previous where ServerID_FK = $serverID");
		$previous_present->execute();
		my @last_array = $previous_present->fetchrow_array();
		if ( @last_array ){
		    my $delete_previous = $dbh->prepare("DELETE from State_Server_Previous where serverID_FK = $serverID");
		    $delete_previous->execute();
		}
		
		my $last_present = $dbh->prepare("SELECT timeLastUpdate, serverID_FK, numVMs, numProjects, memUsed, statusServer_FK, cpuSeconds from State_Server_Last where ServerID_FK = $serverID");
		$last_present->execute();
		my @last_array = $last_present->fetchrow_array();
		if ( @last_array ){
		    my $update_previous_string = "INSERT INTO State_Server_Previous ( timeLastUpdate, serverID_FK, numVMs, numProjects, memUsed, statusServer_FK, cpuSeconds ) values ( '$last_array[0]', $last_array[1], $last_array[2], $last_array[3], $last_array[4] , $last_array[5], $last_array[6] );";
#		    print "$update_previous_string\n";
		    my $update_previous = $dbh->prepare($update_previous_string);
		    $update_previous->execute();
		    
		    my $delete_last = $dbh->prepare("DELETE from State_Server_Last where serverID_FK = $serverID");
		    $delete_last->execute();
		}
		my $state_query;
		my $state_query_last;
		if ( not $HOST_INFO{$server}{"down"}){
		    $state_query = "INSERT INTO State_Server ( timeLastUpdate, serverID_FK, numVMs, numProjects, memUsed, statusServer_FK, cpuSeconds ) values ( '$time', $serverID, $HOST_INFO{$server}{'num_vms'}, $HOST_INFO{$server}{'num_projects'},  $HOST_INFO{$server}{'used_memory'},1, $HOST_INFO{$server}{'cpu_sec'} );";
		    $state_query_last = "INSERT INTO State_Server_Last ( timeLastUpdate, serverID_FK, numVMs, numProjects, memUsed, statusServer_FK, cpuSeconds ) values ( '$time', $serverID, $HOST_INFO{$server}{'num_vms'}, $HOST_INFO{$server}{'num_projects'},  $HOST_INFO{$server}{'used_memory'},1, $HOST_INFO{$server}{'cpu_sec'} );";
		} else {
		    # host is down
		    $state_query = "INSERT INTO State_Server ( timeLastUpdate, serverID_FK, numVMs, numProjects, memUsed, statusServer_FK, cpuSeconds ) values ( '$time', $serverID, 0, 0, 0, 2, 0 );";
		    $state_query_last = "INSERT INTO State_Server_Last ( timeLastUpdate, serverID_FK, numVMs, numProjects, memUsed, statusServer_FK, cpuSeconds ) values ( '$time', $serverID, 0, 0, 0, 2, 0 );";
		}
		my $update_query = $dbh->prepare($state_query);
		$update_query->execute();
		$update_query = $dbh->prepare($state_query_last);
		$update_query->execute();
	    }
	    
	    if ( not $HOST_INFO{$server}{"down"}){
		my %server_groups;
		foreach my $group (split /,/,$DAEMON_GROUP_INDEX{$server} ){
		    if ( $group ne "n/a"){ 
			$server_groups{$group} = 1;
		    }
		}
		
	    # get groups of servers:
		my $group_query = $dbh->prepare("SELECT g.nameGroup FROM Groups AS g where g.serverID_FK = $serverID;");
		$group_query->execute();

	    # update groups of the server:
		while(my(@db_group)=$group_query->fetchrow_array()){ 
#		print "checking if $db_group[0] is present: ";
		    if ( $server_groups{$db_group[0]} == 1 ){
#		    print "yes\n";
#		    $server_groups{$db_group}= 0;
			$server_groups{$db_group[0]} = 0;
		    } else {
#		    print "no, need to delete it\n";
			my $delete_query = $dbh->prepare("DELETE FROM Groups WHERE serverID_FK = $serverID AND nameGroup = '$db_group[0]';");
			$delete_query->execute();
		    }
		}
		foreach my $group (keys %server_groups){
		    if ( $server_groups{$group} == 1 ){
			verbose("$group is a new group, adding to DB\n");
			my $add_query = $dbh->prepare("INSERT INTO Groups(serverID_FK,nameGroup) VALUES ($serverID,'$group');");
			$add_query->execute();
		    }
		}
	    }
	}
	
#	exit ;
	# 2 For all the projects
	foreach my $project ( keys %PROJECT_INFO ){
	    # 2a check if the project is defined
	
	    # get the ID of the project:
#	    print "checking if $project is present in DB\n";
	    my $check_query = "SELECT projectID FROM Projects AS p WHERE p.name = '$project';";
	    my $project_status = $dbh->prepare($check_query);
	    $project_status->execute();
	    my $projectID;
	    my @line = $project_status->fetchrow();
	    if ( $line[0] == 0 and allHostsDown($project) ){
		verbose("Project $project all down and unknown, skipping\n");
		next;
	    } elsif ( $line[0] == 0 ){
		verbose("Project $project is not in DB, creating\n");
		my $id_query = $dbh->prepare("SELECT Ifnull(MAX(projectID),0) FROM Projects;");
		$id_query->execute();
		my @ar = $id_query->fetchrow_array();
		my $max_id = $ar[0]; 
#		print "max id: $max_id, next: " . ($max_id + 1) . "\n";
		$projectID = $max_id + 1;
#		    print "INSERT INTO Servers(serverID,name,memTotalAvailable) VALUES ( " . ($max_id + 1) . ",$server,$HOST_INFO{$server}{'max_memory'});\n";
		my $insert_query = $dbh->prepare("INSERT INTO Projects(projectID,name,startDate) VALUES ( " . ($max_id + 1) . ",'$project','$time');");
		$insert_query->execute();
	    
	    } else {
		$projectID = $line[0];
	    }
	    $projectID_table{$project} = $projectID;
	    my $vms_up;
	    my $vms_down;
#
#	    exit;
	    # 2c for each VM in the project
	    foreach my $vm ( keys %{$PROJECT_INFO{$project}} ){
#		$vm .= "." . $project;
#		print "checking VM $vm\n";
		my $check_query = "SELECT vmID FROM VirtualMachines AS v WHERE v.name = '$vm' and v.projectID_FK = ". $projectID_table{$project} . ";";
		my $project_status = $dbh->prepare($check_query);
		$project_status->execute();
		my $vmID;
		my @line = $project_status->fetchrow();
		if ( $line[0] == 0 ){
#		    print "VM needs to be created: $project, \n";
		    my $id_query = $dbh->prepare("SELECT Ifnull(MAX(vmID),0) FROM VirtualMachines;");
		    $id_query->execute();
		    my @ar = $id_query->fetchrow_array();
		    my $max_id = $ar[0]; 
#		    print "max id: $max_id, next: " . ($max_id + 1) . "\n";
		    $vmID = $max_id + 1;
#		    print "INSERT INTO Servers(serverID,name,memTotalAvailable) VALUES ( " . ($max_id + 1) . ",$server,$HOST_INFO{$server}{'max_memory'});\n";
		    my $insert_query = $dbh->prepare("INSERT INTO VirtualMachines(vmID,name,projectID_FK,startDate) VALUES ( " . ($max_id + 1) . ",'$vm',$projectID,'$time');");
		    $insert_query->execute();
# ,'$time',0);");
		    
		} else {
		    $vmID = $line[0];
		}
		
		# update status for each V
		my $previous_present = $dbh->prepare("SELECT timeLastUpdate,vmID_FK,cpuSeconds,memory,locationFilesystem,diskIOread,diskIOwrite,serverID_FK,statusVM_FK,diskDelay from State_VirtualMachine_Previous where vmID_FK = $vmID");
		$previous_present->execute();
		my @last_array = $previous_present->fetchrow_array();
		if ( @last_array ){
		    my $delete_previous = $dbh->prepare("DELETE from State_VirtualMachine_Previous where vmID_FK = $vmID");
		    $delete_previous->execute();
		}
		
		my $last_present = $dbh->prepare("SELECT timeLastUpdate,vmID_FK,cpuSeconds,memory,locationFilesystem,diskIOread,diskIOwrite,serverID_FK,statusVM_FK,diskDelay from State_VirtualMachine_Last where vmID_FK = $vmID");
		$last_present->execute();
		my @last_array = $last_present->fetchrow_array();
		if ( @last_array ){
		    my $update_previous_string = "INSERT INTO State_VirtualMachine_Previous(timeLastUpdate,vmID_FK,cpuSeconds,memory,locationFilesystem,diskIOread,diskIOwrite,serverID_FK,statusVM_FK,diskDelay) values ( '$last_array[0]', $last_array[1], $last_array[2], $last_array[3], '$last_array[4]' , '$last_array[5]', '$last_array[6]', '$last_array[7]', $last_array[8],$last_array[9] );";
#		    print "$update_previous_string\n";
		    my $update_previous = $dbh->prepare($update_previous_string);
		    $update_previous->execute();
		    
		    my $delete_last = $dbh->prepare("DELETE from State_VirtualMachine_Last where vmID_FK = $vmID");
		    $delete_last->execute();
		}

		my $vm_state;
		my $vm_state_last;
		if ( $PROJECT_INFO{$project}{$vm}{'state'} eq "up" ){
		    # vm is running
		    $vm_state = "INSERT INTO State_VirtualMachine(timeLastUpdate,vmID_FK,cpuSeconds,memory,locationFilesystem,serverID_FK,statusVM_FK,diskIOread,diskIOwrite,diskDelay) VALUES('$time',$vmID,'" . $PROJECT_INFO{$project}{$vm}{'cpu_sec'} . "','" . $PROJECT_INFO{$project}{$vm}{'memory'} . "','" . $PROJECT_INFO{$project}{$vm}{'storage'} . "', " . $serverID_table{$PROJECT_INFO{$project}{$vm}{'service_host'}} . ", 1, " . $PROJECT_INFO{$project}{$vm}{"vbd"}{"diskIOread"} .",". $PROJECT_INFO{$project}{$vm}{'vbd'}{'diskIOwrite'} . "," . $PROJECT_INFO{$project}{$vm}{'diskDelay'} . ");";
		    $vm_state_last = "INSERT INTO State_VirtualMachine_Last(timeLastUpdate,vmID_FK,cpuSeconds,memory,locationFilesystem,serverID_FK,statusVM_FK,diskIOread,diskIOwrite,diskDelay) VALUES('$time',$vmID,'" . $PROJECT_INFO{$project}{$vm}{'cpu_sec'} . "','" . $PROJECT_INFO{$project}{$vm}{'memory'} . "','" . $PROJECT_INFO{$project}{$vm}{'storage'} . "', " . $serverID_table{$PROJECT_INFO{$project}{$vm}{'service_host'}} . ", 1, " . $PROJECT_INFO{$project}{$vm}{"vbd"}{"diskIOread"} .",". $PROJECT_INFO{$project}{$vm}{'vbd'}{'diskIOwrite'} . "," . $PROJECT_INFO{$project}{$vm}{'diskDelay'} . ");";
		    $vms_up++;
		} else {
		    # VM is down!
		    $vm_state = "INSERT INTO State_VirtualMachine(timeLastUpdate,vmID_FK,cpuSeconds,memory,locationFilesystem,serverID_FK,statusVM_FK) VALUES('$time',$vmID,'','','','$serverID_table{$PROJECT_INFO{$project}{$vm}{'service_host'}}',1)";
		    $vm_state_last = "INSERT INTO State_VirtualMachine_Last(timeLastUpdate,vmID_FK,cpuSeconds,memory,locationFilesystem,serverID_FK,statusVM_FK) VALUES('$time',$vmID,'','','','$serverID_table{$PROJECT_INFO{$project}{$vm}{'service_host'}}',1)";
		    $vms_down++;
		}
#      	print "$project.$vm" . $vm_state ."\n" if ( $project eq "dn36");
		my $vm_update_query = $dbh->prepare($vm_state);
#		print $vm_state . "\n";
		$vm_update_query->execute();		  
		$vm_update_query = $dbh->prepare($vm_state_last);
		$vm_update_query->execute();		  

		

		
		# all connections ...
		foreach my $if ( keys %{$PROJECT_INFO{$project}{$vm}{'network'}} ){
		    # check for connection ID
		    my $check_query = "SELECT connectionID FROM VM_Connection AS v WHERE v.vmID_FK = '$vmID' and v.nameNetworkCard = '$if';";
		    my $project_status = $dbh->prepare($check_query);
		    $project_status->execute();
		    my $conID;
		    my @line = $project_status->fetchrow();
		    if ( $line[0] == 0 ){
			my $id_query = $dbh->prepare("SELECT Ifnull(MAX(connectionID),0) FROM VM_Connection;");
			$id_query->execute();
			my @ar = $id_query->fetchrow_array();
			my $max_id = $ar[0]; 
#		    print "max id: $max_id, next: " . ($max_id + 1) . "\n";
			$conID = $max_id + 1;
#		    print "INSERT INTO Servers(serverID,name,memTotalAvailable) VALUES ( " . ($max_id + 1) . ",$server,$HOST_INFO{$server}{'max_memory'});\n";
			my $insert_query = $dbh->prepare("INSERT INTO VM_Connection(connectionID,vmID_FK,nameNetworkCard,nameConnection ) VALUES ( " . ($max_id + 1) . ",'$vmID','$if','$PROJECT_INFO{$project}{$vm}{'network'}{$if}{'switch'}');");
			$insert_query->execute();

		    } else {
			$conID = $line[0];
		    }
# update the database

		    my $previous_present = $dbh->prepare("SELECT timeLastUpdate,connectionID_FK,vmID_FK,serverID_FK,networkTrafficIN,networkTrafficOUT from State_Connection_Previous where connectionID_FK = $conID");
		    $previous_present->execute();
		    my @last_array = $previous_present->fetchrow_array();
		    if ( @last_array ){
			my $delete_previous = $dbh->prepare("DELETE from State_Connection_Previous where connectionID_FK = $conID");
			$delete_previous->execute();
		    }
		
		    my $last_present = $dbh->prepare("SELECT timeLastUpdate,connectionID_FK,vmID_FK,serverID_FK,networkTrafficIN,networkTrafficOUT from State_Connection_Last where connectionID_FK = $conID");
		    $last_present->execute();
		    my @last_array = $last_present->fetchrow_array();
		    if ( @last_array ){
			my $update_previous_string = "INSERT INTO State_Connection_Previous(timeLastUpdate,connectionID_FK,vmID_FK,serverID_FK,networkTrafficIN,networkTrafficOUT) VALUES('$last_array[0]',$last_array[1],$last_array[2],'" . $last_array[3] ."',$last_array[4],$last_array[5] );";
#		    print "$update_previous_string\n";
			my $update_previous = $dbh->prepare($update_previous_string);
			$update_previous->execute();
			
			my $delete_last = $dbh->prepare("DELETE from State_Connection_Last where connectionID_FK = $conID");
			$delete_last->execute();
		    }
		    
		    my $con_state = "INSERT INTO State_Connection(timeLastUpdate,connectionID_FK,vmID_FK,serverID_FK,networkTrafficIN,networkTrafficOUT) VALUES('$time',$conID,$vmID,'" . $serverID_table{$PROJECT_INFO{$project}{$vm}{'service_host'}} ."',$PROJECT_INFO{$project}{$vm}{'network'}{$if}{'in_bytes'},$PROJECT_INFO{$project}{$vm}{'network'}{$if}{'out_bytes'} );";
#		    print "$con_state\n";
		    my $vm_update_query = $dbh->prepare($con_state);
		    $vm_update_query->execute();		    
		    $con_state = "INSERT INTO State_Connection_Last(timeLastUpdate,connectionID_FK,vmID_FK,serverID_FK,networkTrafficIN,networkTrafficOUT) VALUES('$time',$conID,$vmID,'" . $serverID_table{$PROJECT_INFO{$project}{$vm}{'service_host'}} ."',$PROJECT_INFO{$project}{$vm}{'network'}{$if}{'in_bytes'},$PROJECT_INFO{$project}{$vm}{'network'}{$if}{'out_bytes'} );";
		    $vm_update_query = $dbh->prepare($con_state);
		    $vm_update_query->execute();		    
		}		
	    }
	    # 2b enter state information about the project
	    my $project_state = 1;
	    if ( $vms_up and $vms_down ){
		$project_state = 4;
	    }
	    if ( $vms_down and not $vms_up ){
		$project_state = 2;
	    }

	    my $previous_present = $dbh->prepare("SELECT timeLastUpdate,projectID_FK,statusProject_FK,priority_FK from State_Project_Previous where projectID_FK = $projectID");
	    $previous_present->execute();
	    my @last_array = $previous_present->fetchrow_array();
	    if ( @last_array ){
		my $delete_previous = $dbh->prepare("DELETE from State_Project_Previous where projectID_FK = $projectID");
		$delete_previous->execute();
	    }
		
	    my $last_present = $dbh->prepare("SELECT timeLastUpdate,projectID_FK,statusProject_FK,priority_FK from State_Project_Last where projectID_FK = $projectID");
	    $last_present->execute();
	    my @last_array = $last_present->fetchrow_array();
	    if ( @last_array ){
		my $update_previous_string = "INSERT INTO State_Project_Previous(timeLastUpdate,projectID_FK,statusProject_FK,priority_FK ) VALUES('$last_array[0]',$last_array[1],$last_array[2],$last_array[3]);";
#		    print "$update_previous_string\n";
		my $update_previous = $dbh->prepare($update_previous_string);
		$update_previous->execute();
		
		my $delete_last = $dbh->prepare("DELETE from State_Project_Last where projectID_FK = $projectID");
		$delete_last->execute();
	    }
	    
	    
	    my $state_query = "INSERT INTO State_Project(timeLastUpdate,projectID_FK,statusProject_FK,priority_FK ) VALUES('$time',$projectID,$project_state,1);";
	    my $update_query = $dbh->prepare($state_query);
	    $update_query->execute();
	    $state_query = "INSERT INTO State_Project_Last(timeLastUpdate,projectID_FK,statusProject_FK,priority_FK ) VALUES('$time',$projectID,$project_state,1);";
	    $update_query = $dbh->prepare($state_query);
	    $update_query->execute();

	}
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime time;
	$year += 1900;
	$mon += 1;
	
	$min = "0$min" if $min < 10;
	$mon = "0$mon" if $mon < 10;
	$mday = "0$mday" if $mday < 10;
	$sec = "0$sec" if $sec < 10;
	$hour = "0$hour" if $hour < 10;
	my $end_time = "$year-$mon-$mday $hour:$min:$sec";
	my $end_insert = $dbh->prepare("UPDATE Metainformation_MLN set value='$end_time' where variable='Last_Update_Finish';");
	$end_insert->execute();
	my $end_insert = $dbh->prepare("UPDATE Metainformation_MLN set value='$fetch_start' where variable='Fetch_Data_Start';");
	$end_insert->execute();
	my $end_insert = $dbh->prepare("UPDATE Metainformation_MLN set value='$fetch_stop' where variable='Fetch_Data_Finish';");
	$end_insert->execute();


    } else {
	print "fail: $!\n";
    }
}


sub get_storage_conflict_table {
    
    my @conflict_matrix;
    my $num_conflicts;
    my $num_possible_conflicts;
    # storage conflict table
#    my %location_conflicts;
    my @VM_LIST;
    my %VM_STORAGE;
    my %VM_SH;
    # for all servers

	# for all virtual machines
    foreach my $project (keys %PROJECT_INFO){
	
	foreach my $vm (keys %{$PROJECT_INFO{$project}}){ 
	    push(@VM_LIST,$vm.".".$project);
	    $VM_STORAGE{$vm.".".$project} = $PROJECT_INFO{$project}{$vm}{"storage"};
	    $VM_SH{$vm.".".$project} = $PROJECT_INFO{$project}{$vm}{"service_host"};
#	    print "saving $vm.$project - $VM_STORAGE{$vm.$project} - $VM_SH{$vm.$project}\n";
	}
    }
    for ( my $i = 0; $i < scalar @VM_LIST; $i++){	
	
	for ( my $j = $i + 1; $j < scalar @VM_LIST; $j++){
	    
	    if ( $VM_STORAGE{$VM_LIST[$i]} =~ /^LOCAL:/ and $VM_SH{$VM_LIST[$i]} eq $VM_SH{$VM_LIST[$j]} and $VM_STORAGE{$VM_LIST[$i]} eq $VM_STORAGE{$VM_LIST[$j]}) {
#		print "Local storage conflict: $VM_LIST[$i] / $VM_LIST[$j] : $VM_STORAGE{$VM_LIST[$j]}\n";
		$num_conflicts++;
		$LOCATION_CONFLICT_TABLE{$VM_SH{$VM_LIST[$i]}}++;
	    } elsif ( $VM_STORAGE{$VM_LIST[$i]} =~ /^SAN:/ and $VM_STORAGE{$VM_LIST[$i]} eq $VM_STORAGE{$VM_LIST[$j]} ){
#		print "SAN storage conflict: $VM_LIST[$i] / $VM_LIST[$j] : $VM_STORAGE{$VM_LIST[$j]}\n";
		$num_conflicts++;
		
	    }
	}
    }
    
    
#    print "number of VMs: ". scalar @VM_LIST . "\n";
#    print "number of conflicts: $num_conflicts\n";

	
    return ( $num_conflicts / ( 0.5 * scalar @VM_LIST * (scalar @VM_LIST - 1)));
}

sub distributedRemove {
    my $server = $_[0];
    my $project = $_[1];
    use IO::Socket;
    my $port = 34001;
    debug("Connecting to $server:$port\n");
    my $sock = new IO::Socket::INET(
	                  PeerAddr => $server,
	                  PeerPort => $port,
	                  Proto    => 'tcp',
    );
    
    if ( $sock ) {
	print $sock "remove_project:$project\n";
	my $reply = <$sock>;
	if ( $reply =~ /TICKET:(\d+)\n/ ){
	    close($sock);
	    return $1;
	} else { 
	    print "$server did not have project\n";
	}
    } 
    close($sock);
    return 0;
}


sub getDaemonStatus {
    my $server = $_[0];
	my @nothing;
    use IO::Socket;
    my $port = 34001;
    debug("Connecting to $server:$port\n");
    verbose("Establishing conenction to: $server\n");
    my $sock = new IO::Socket::INET(
	                  PeerAddr => $server,
	                  PeerPort => $port,
	                  Proto    => 'tcp',
	                  Timeout => 2
    );
    verbose("result: ");
    if ( $sock ) {
	verbose("OK\n");
	# asking for status
	print $sock "daemon_status\n";
	my $response = <$sock>;
	chomp $response;
	if ( $response eq "GOODBYE" ){
	    close ($sock);
	    return @nothing;
	}
	my @return = split /:/,$response;
	$HOST_INFO{$server}{"free_memory"} = $return[3];
	$HOST_INFO{$server}{"used_memory"} = $return[2];
	$HOST_INFO{$server}{"num_projects"} = $return[0];
	$HOST_INFO{$server}{"num_vms"} = $return[1];
	$HOST_INFO{$server}{"max_memory"} = $return[4];
	$HOST_INFO{$server}{"groups"} = $return[5];
	$response = <$sock>;
	
	if ( $response eq "XM-LIST-CACHE\n" ){
	    $response = <$sock>;
	    while ( $response ne "XM-LIST-CACHE-END\n" ){
#		print "$response";
		if ( $response =~ /^(\S+\.\S+) /){
		    if ( length($1) > $STATUS_MAX_VM_NAME_LENGTH ){
			$STATUS_MAX_VM_NAME_LENGTH = length($1);
		    }
		}
		my @stat = split /\s+/, $response;
		if ( $stat[1] eq "0" ) {
		    $HOST_INFO{$server}{"memory"} = $stat[2];
		    $HOST_INFO{$server}{"cpu_sec"} = $stat[5];				
		    
		} elsif( $stat[0] =~ /(\S+)\.(\S+)/) {
		    
		    my $proj = $2;
		    my $host = $1;
		    

		    $HOST_INFO{$server}{$proj}{$host}{"memory"} = $stat[2];
		    $HOST_INFO{$server}{$proj}{$host}{"cpu_sec"} = $stat[5];

		    $PROJECT_INFO{$proj}{$host}{"memory"} = $stat[2];
#		    print "'$proj', '$host'\n"; 
		    $PROJECT_INFO{$proj}{$host}{"cpu_sec"} = $stat[5];
		    $PROJECT_INFO{$proj}{$host}{"service_host"} = $server;
		    
		    if ( $stat[8] ){
			$HOST_INFO{$server}{$proj}{$host}{"storage"} = $stat[8];
			$PROJECT_INFO{$proj}{$host}{"storage"} = $stat[8];
		    }
		    
		    if ( $stat[9] ){
#			print "$stat[9]";
			foreach my $ifline (split /;/, $stat[9]){
			    my @ifarray = split /:/, $ifline;
			    $PROJECT_INFO{$proj}{$host}{"network"}{"$ifarray[0]"}{"switch"} = $ifarray[1];
			    $PROJECT_INFO{$proj}{$host}{"network"}{"$ifarray[0]"}{"in_bytes"} = $ifarray[2];
			    $PROJECT_INFO{$proj}{$host}{"network"}{"$ifarray[0]"}{"out_bytes"} = $ifarray[3];
			}
		    }

#			print "disk info for $host.$stat[9]";
		    $PROJECT_INFO{$proj}{$host}{"vbd"}{"diskIOread"} = $stat[10] || 0;
		    $HOST_INFO{$server}{$proj}{$host}{"vbd"}{"diskIOread"} = $stat[10]  || 0;
		    $PROJECT_INFO{$proj}{$host}{"vbd"}{"diskIOwrite"} = $stat[11] || 0;
		    $HOST_INFO{$server}{$proj}{$host}{"vbd"}{"diskIOwrite"} = $stat[11] || 0;
		    $PROJECT_INFO{$proj}{$host}{"diskDelay"} = $stat[12] || 0;
		    $HOST_INFO{$server}{$proj}{$host}{"diskDelay"} = $stat[12] || 0;
		    
		    
		}
		push(@{$XM_LIST_RESULT{$server}},$response);
		$response = <$sock>;
		
	    }
	}
		
	$response = <$sock>;
	if ( $response eq "CHUNK-LIST\n" ){
	    $response = <$sock>;	    
	    my @array;
	    my $memory;
	    while ( $response ne "CHUNK-LIST-END\n" ){
		chomp $response;
#		print "adding chunk to $server: $response\n";
		@array = split / : /, $response; 
		my $project = shift(@array);
#		print "Collecting memory for $project\n"; 
		$memory = 0;
		foreach (@array){
#		    print "$project $_ " . $PROJECT_INFO{$project}{$_}{"memory"} . "\n";
		    $memory +=  $PROJECT_INFO{$project}{$_}{"memory"};
		}
		$HOST_INFO{$server}{"chunks"}{$response} = $memory;
		$response = <$sock>;	    
	    }
	}
	
	$response = <$sock>;
	if ( $response eq "STATUS-LIST\n" ){
#	    print "Status list \n";
	    $response = <$sock>;	    
	    while ( $response ne "STATUS-LIST-END\n" ){
		my ($project,$type,$name,$state) = split /\s+/, $response; 
		if ( $type eq "host" ){
		    $PROJECT_INFO{$project}{$name}{"state"} = $state;
		    $HOST_INFO{$server}{$project}{$name}{"state"} = $state; ;
		} 
		$response = <$sock>;
#		print "$response";
	    }
	}
	close ($sock);
	return @return;
    } else {
	verbose("no socket\n");
	return @nothing;   	
    }
    print "Exiting\n";
}

sub getDaemonGroups {
    
    return "";
    
}

sub get_info_and_build_hash {
    
    
    
}

sub monitorXen {

# print "monitorXen called\n";
# use strict;
# http://search.cpan.org/~rjray/RPC-XML-0.59/lib/RPC/XML/Client.pm
    require RPC::XML;
    require RPC::XML::Client;

    shift @ARGV;
    my $opt_string = 'lo:';
    getopts( "$opt_string", \my %opt ) or usage() and exit;
    
    my $output_dir = $opt{"o"};
    
    my $loop = $opt{"l"};
    
   
# for debug purposes
    use Data::Dumper;

##### CONFIG ######

# my %xenhosts = ("192.168.0.10" => {"port" => "9363"}, 
#					 "192.168.0.11" => {"port" => "9363"}, 
#					 "192.168.0.12" => {"port" => "9363"}, 
#					 "192.168.0.13" => {"port" => "9363"});
# my %xenhosts = ("192.168.0.10" => {"port" => "9363"}, "192.168.0.11" => {"port" => "9363"});
# my %xenhosts = ("mln3.vlab.iu.hio.no" => {"port" => "9363"});
#    %xenhosts = ("192.168.0.13" => {"port" => "9363"}, "192.168.0.10" => {"port" => "9363"}, "192.168.0.11" => {"port" => "9363"});
 
#    %xenhosts = ("mln2.vlab.iu.hio.no" => {"port" => "9363" });
#    $mln = "/usr/local/bin/mln";
#    $mln_files_dir = "/home/i/mln-files";
    
#    $host_cpu_utilisation_low = 0.1;
#    $host_cpu_utilisation_high = 0.7;
    
##### CONFIG END ###
    
##### STATIC VARS #####
#    %host_info;
    %chunks;
    %all_vms;

#######################

    
    do {
#	apiconnect();
	%host_info = ();
#	get_complete_info();
	get_info_and_build_hash();
	get_redundancy_factor();
	printHash(\%HOST_INFO);
# print Dumper(%host_info);
    
	if ( $output_dir ){
	    printMonitorResult($output_dir);
	}
	sleep 20 if ($loop);
    } while($loop)
    # foreach my $host (keys %host_info)
    # {

    # 	print "calling host cpu utilization for $host\n";
    # 	my $total_utilisation = get_total_host_cpu_utilisation($host);
	
    # 	my $vm_number = keys %{$host_info{$host}{'vms'}};
    # 	$vm_number -= 1;
    # 	print "number of vms: $vm_number\n";
    # 	if (($total_utilisation > $host_cpu_utilisation_high) && ($vm_number > 1))
    # 	{
    # 	    print "$host cpu utilisation = $total_utilisation.. Supporting $vm_number VMs..\nStarting migration logic..\n";
# #			high_load_on_host($host);
    # 	}
    # 		elsif (($total_utilisation > $host_cpu_utilisation_high) && ($vm_number == 1))
    # 		{
    # 		    print "$host cpu utilisation = $total_utilisation.. But only Dom0 running here..\n";
    # 		}
    # 		else
    # 		{
    # 		    print "$host cpu utilisation = $total_utilisation.. Nothing to be done..\n";
    # 		}  
    # }
# print Dumper(%host_info);
# sleep(120);
}    

sub getPermutations {
    
    my $size = $_[0];
#    print "get permutations of size ${size}:\n";
    my @servers = keys %HOST_INFO;
    my $result = permute("",\@servers,$size);
#    print "result: $result\n";
    return $result;
    
}

sub permute {
    
    return if ( not $_[0] and not $_[1]);
    my $tm = $_[0];
    my @head = @$tm;
    $tm = $_[1];
    my @tail = @$tm;
    my $size = $_[2];
    
#    print "tail: ";
#    foreach (@tail){
#	print $_ . ":";
#   }
#    print "\n";
    
    my $element = pop(@tail);
#    print "popped $element\n";

    push(@head,$element);
    if ( scalar @head == $size ){
	my $result; 	

	foreach (@head){
	    $result .=  $_ . " : ";
	}

#	print "size OK, returning: $result\n";

	
	if ( scalar @head + scalar @tail - 1 >= $size ){
	    return $result . " <> " . permute($_[0],\@tail,$size); 
	} else {
	    return $result;
	}
    } else {
#	print "size: " . scalar @head . " == $size, moving on\n";
	my $result;
	if ( @tail and scalar @head + scalar @tail >= $size ){
	    $result =  permute(\@head,\@tail,$size); 	    
	}
	if ( @tail and scalar @head + scalar @tail - 1 >= $size ){
	    $result .= " <> " . permute($_[0],\@tail,$size);;
	}
	    
	return $result;

    }
}

sub get_redundancy_factor {
    
    # get list of daemons
    
    # get their status
    my $num_of_servers = scalar(keys %HOST_INFO);
#    print "number of servers: $num_of_servers\n";
    my @servers = keys %HOST_INFO;
    my %chunks; 
    my $red_factor;

    
    for ( my $i = 1; $i <= $num_of_servers; $i++) {
		
	# traverse candidate(s)
	#
	my @candidate_sets = split /<>/, getPermutations($i);

	foreach my $set ( @candidate_sets ){
	    $set =~ s/^( |)(.*) : +$/$2/;
	    my @candidates = split / : /, $set;
#	    print "----\n";
	    my %locked_hosts; 
	    my $server;
	    my $total_memory_chunk_size;		
	    
	    foreach $server (@candidates ){
		$locked_hosts{$server} = 1;
		# get chunks beloning to candidates

		foreach ( keys %{$HOST_INFO{$server}{"chunks"}} ){
#		    print "$server : chunk -> $_ " . $HOST_INFO{$server}{"chunks"}{$_} . "\n";
		    $chunks{$_} = $HOST_INFO{$server}{"chunks"}{$_};
		    $total_memory_chunk_size += $HOST_INFO{$server}{"chunks"}{$_};
		}

	    }
	    verbose("total chunk memory: $total_memory_chunk_size\n");
	    my $total_free_memory;
	    foreach (keys %HOST_INFO){
		if ( not $locked_hosts{$_}){
		    $total_free_memory += $HOST_INFO{$_}{"free_memory"};
		}
	    }	    
	    verbose("total free memory: $total_free_memory\n");
	    if ( $total_free_memory < $total_memory_chunk_size ){
#		verbose("Redundancy breach at $i\n");
#		out("Redundancy breach at $i\n");
		$red_factor =  $i - 1;

		# if we are at 0, just return;
		return 0 if $red_factor == 0;
# attempt to place them
		
		# get all candidates at $red_factor and below;
		for ( my $j = $red_factor; $j > 0; $j--){

		    my @perms = split /<>/, getPermutations($j);
		    verbose("checking placement for level $j - " . scalar @perms . " permutations\n");

		    my $working_permutations;
		    foreach my $set ( @perms){
			$set =~ s/^( |)(.*) : +$/$2/;
			my @candidates = split / : /, $set;
			my @chunk_list;
			my @chunk_memory_list;
			my @chunk_placement;
			my @vacant_servers;
			my @vacant_memory;
			
#			out("candidate: ");
			my %locked_host;
			my $targets;
			my %chunk_hash;
			foreach my $s (@candidates){
#			    out("$s, ");
			    $targets++ if $s eq "mln4.vlab.iu.hio.no";
			    $targets++ if $s eq "mln6.vlab.iu.hio.no";
			    
			    $locked_host{$s} = 1;
			    foreach ( keys %{$HOST_INFO{$s}{"chunks"}} ){
				verbose("adding chunk: $_\n");
				push(@chunk_list,$_);
				push(@chunk_memory_list,$HOST_INFO{$s}{"chunks"}{$_});
				$chunk_hash{$_} = $HOST_INFO{$s}{"chunks"}{$_};
				
			    }
			}    
#			out("\n");
			# i got all the chunks in @chunk_list, and its memory in @chunk_memory_list
#			out("vacant: ");
			my $total_capacity;
			my %host_hash;
			foreach (keys %HOST_INFO){
			    if ( not $locked_host{$_} ){
#				out("$_, ");
				push(@vacant_servers,$_);
				push(@vacant_memory,$HOST_INFO{$_}{"free_memory"});
				$total_capacity += $HOST_INFO{$_}{"free_memory"};
				$host_hash{$_} = $HOST_INFO{$_}{"free_memory"};
			    }
			}
#			out("\n");
			my $total_chunk_memory;
			my $minimal_chunk;
			foreach (@chunk_memory_list){
			    $vacant_memory[0] -= $_;
			    $total_chunk_memory += $_;
			    if ( $_ < $minimal_chunk or $minimal_chunk == 0 ){
				$minimal_chunk = $_;
			    }
			}
			verbose("calling get_working_chunk_placement\n");
			%tried_placements = ();
			my %working_placement = get_first_fit_decreasing(\%host_hash,\%chunk_hash);
#			my $working_placement = get_working_chunk_placement(\@chunk_list,\@chunk_memory_list,\@chunk_placement,$j,\@vacant_servers,\@vacant_memory,0,0,$targets,$total_capacity,$total_chunk_memory,$minimal_chunk);
			if ( scalar keys %working_placement ){
			    $working_permutations++;
			    verbose("Redundancy confirmed at factor $j  ($working_permutations)\n");
			    
			    foreach (@candidates){
			    verbose("removed host: $_\n");
			    }
#			    my @placement = split / : /, $working_placement; 
#			    for( my $n = 0; $n < scalar @chunk_list; $n++){
#				verbose("host $vacant_servers[$placement[$n]] gets chunk $n ( $chunk_list[$n] )\n");				
#			    }
#			    foreach (keys %working_placement){
#				print "$_ $working_placement{$_}\n";
#			    }
			    
			} else {
			    # print "no working placement found on $j when removing: ";
			    # foreach (@candidates){
			    # 	print " $_ : ";
			    # }
			    # print "\n";
			    @perms = ();

			}
			
		    }
		    if ( $working_permutations and $working_permutations == scalar @perms ){
			verbose("all permutations OK for level $j\n");
			%tried_placements = ();
			return $j;
		    } else {
			verbose("$i permutations failed for $j\n");

			if ( $j == 1){
			    return 0;
			}

		    }
		}

	    }

	    
	    
	}

    }
    
    %tried_placements = ();
}

sub get_first_fit_decreasing {
    my $tm = $_[0];
    my %host_list = %$tm;
    $tm = $_[1];
    my %chunk_list = %$tm;
    my @host_array;
    my @host_names;
    my $hi = 0;
    my %placement;
    
#    return;
    
    foreach my $host ( sort {$host_list{$b} <=> $host_list{$a}} keys %host_list ){
	$host_array[$hi] = $host;
	$hi++;
#	print "sorting: $host -> $host_list{$host}\n";
    }
    # for all chunks in sorted order
    my $num_chunks = scalar keys %chunk_list;
    my $chunk_counter = 1;
    foreach my $chunk ( sort {$chunk_list{$b} <=> $chunk_list{$a}} keys %chunk_list ){
#	print "placing ( $chunk_counter of $num_chunks) chunk $chunk ($chunk_list{$chunk}) at ";
	for ( my $i = 0; $i < $hi; $i++){
	    if ( $chunk_list{$chunk} <= $host_list{$host_array[$i]}){
#		print "$host_array[$i] ($host_list{$host_array[$i]}) -> " . ($host_list{$host_array[$i]} - $chunk_list{$chunk}) . "\n";
		$host_list{$host_array[$i]} -= $chunk_list{$chunk};
		$placement{$chunk} = $host_array[$i];
		$chunk_counter++;
		last;
	    }
	}
	if ( not $placement{$chunk} ){
	    verbose("Failed to place $chunk ($chunk_list{$chunk})\n");
	    for ( my $i = 0; $i < $hi; $i++){
		verbose("server: $host_array[$i] ($host_list{$host_array[$i]})\n");
	    }
	    return;
	}
    }
#    print "Solution found:";
#    foreach (keys %placement){
#	print "$_ -> $placement{$_}\n";
#    }
    return %placement;
}

sub get_working_chunk_placement {
    
    my $tm;
    $tm = $_[0];
    my @chunk_list = @$tm;
    $tm = $_[1];
    my @chunk_memory_list = @$tm;
    $tm = $_[2];
    my @chunk_placement = @$tm;
    my $red_factor = $_[3];
    $tm = $_[4];   
    my @vacant_servers = @$tm;
    $tm = $_[5];
    my @vacant_memory = @$tm;
    my $position = $_[6];
    
    my $track = $_[7];
    
    my $targets = $_[8];
    my $capacity = $_[9];
    my $total_weight = $_[10];
    my $minimal_chunk = $_[11];
    
    if ($capacity < $total_weight){
	print "capacity surplus too high\n";
#	<STDIN>;
	return; 
    }
    my @memory_bucket = @vacant_memory;
    my $no_solution;
    
#	print "get working chunk placement: $track\n" if $targets == 2;
	for ( my $server = 0; $server < scalar @memory_bucket; $server++ ){
#	    print "$track: server $server has $memory_bucket[$server]\n" if $targets == 2;;
	    if ( $memory_bucket[$server] < 0 ) {
#		print "$track: going with $server\n" if $targets == 2;
		$no_solution = 1;
		for ( my $chunk = 0; $chunk < scalar @chunk_list; $chunk++){ 
#		    print "chunk $chunk @ $chunk_placement[$chunk]\n" if $targets == 2;
		    if ( $chunk_placement[$chunk] == $server ){
#			print "$track: using chunk $chunk ($chunk_list[$chunk]) $chunk_memory_list[$chunk]\n" if $targets == 2;
			for ( my $hop = $server + 1; $hop < scalar @memory_bucket; $hop++){
#			    print "$track: testing hop server $hop ($memory_bucket[$hop])\n" if $targets == 2;  
			    if ( $memory_bucket[$hop] - $chunk_memory_list[$chunk] >= 0 ){
				my @new_placement = @chunk_placement;
				$new_placement[$chunk] = $hop;
				my $placement_line; 
				for ( my $p; $p < scalar @chunk_list; $p++){
				    if ( not $new_placement[$p] ){
					$placement_line .= "0 ";
				    } else {
					$placement_line .= "$new_placement[$p] ";
				    }
				}
				if ( not $tried_placements{$placement_line} ){
				    $tried_placements{$placement_line} = 1;
				    my $reduced_capacity;
				    if ( $memory_bucket[$server] + $chunk_memory_list[$chunk] > 0 ){
					$reduced_capacity = $memory_bucket[$server] + $chunk_memory_list[$chunk];
#					print "*********************** capacity reduction by $reduced_capacity at $server\n";
#					<STDIN>;
				    }

				    my @new_bucket = @memory_bucket;
				    $new_bucket[$hop] -= $chunk_memory_list[$chunk];
				    $new_bucket[$server] += $chunk_memory_list[$chunk];
				    if ( $new_bucket[$hop] < $minimal_chunk ){
					$reduced_capacity += $new_bucket[$hop];
#					print "*********************** capacity reduction by $reduced_capacity at $hop (minimal: $minimal_chunk)\n";
#					<STDIN>;
				    }
				    print "[ " . (($capacity - $reduced_capacity) - $total_weight) ."]  $placement_line\n";
#				    print "$track: placement: ($chunk_memory_list[$chunk]) $chunk_list[$chunk] : ($server) [$memory_bucket[$server]] -> ($hop) [$memory_bucket[$hop]]\n" if $targets == 2;
#				for ( my $i = 0; $i < scalar @chunk_list; $i++){
#				    print "$vacant_servers[$new_placement[$i]] ($chunk_memory_list[$new_placement[$i]]): $chunk_list[$i]\n";
#
#				}
				    
				    # end the loop
				    $hop = scalar @memory_bucket; 
				    my $result = get_working_chunk_placement(\@chunk_list,\@chunk_memory_list,\@new_placement,$red_factor,\@vacant_servers,\@new_bucket,$position,$track + 1,$targets,$capacity - $reduced_capacity ,$total_weight,$minimal_chunk);
				    if ( $result ){
					debug("solution found, returning $result\n");
					return $result;
					
				    }
				}
			    }
			}
		    }
		}
		last;
	    }
	}
	
	
	# keep looking	

	# if we have untried positions, increase position and try again	
	# if (  $position < scalar @chunk_list ){
	#     print "increasing $position to " . ($position + 1) . " limit is " . scalar @chunk_list . "\n";

	#     my $try = get_working_chunk_placement(\@chunk_list,\@chunk_memory_list,\@chunk_placement,$red_factor,\@vacant_servers,\@vacant_memory,$position + 1 );
	    
	#     if ( $try ){
	# 	# a soluion was found down the road
	# 	return $try;
	#     }	    
	# }

	# if ( $chunk_placement[$position] < ( $red_factor - 1)){
	# # continue with increased placement
	#     print "chunk placement $chunk_placement[$position] is lower than " . ( $red_factor - 1)."\n";

	#     $chunk_placement[$position]++;
	#     my $try = get_working_chunk_placement(\@chunk_list,\@chunk_memory_list,\@chunk_placement,$red_factor,\@vacant_servers,\@vacant_memory,$position);
	#     if ( $try ){
	# 	# a soluion was found down the road
	# 	return $try;
	#     }
	# }
	
	
#	exit 0;
#    } else {
	# we found a working solution, return it
    if ( not $no_solution ){
	my $solution;
	for(my $j = 0; $j < scalar @chunk_list; $j++) {
	    if ( @chunk_placement[$j] ){ 
		$solution .= "$chunk_placement[$j] : ";
	    } else {
		$solution .= "0 : ";
	    }
	}
#	print "solution found, returning $solution\n";
	return $solution;
    } else {
#	print "$track: no solution found\n";
	return "";
	
    }
}

sub printMonitorResult {
    print "printing results as HTML\n";
    my $output_dir = $_[0];
    
    if ( $output_dir ){
	if ( not stat("$output_dir")){

	    mkdir("$output_dir") or die "FATAL: Could not create output directory $output_dir\n";
	}
    }

    my $maxmem;
    my %running_projects;
    
    foreach  (@DAEMON_STATUS_QUERY_HOSTS) {

	my $host = $_;
#	print "host: $host\n";
	$host =~ s/^([^\.]*)(\..*)$/$1/g;
#	print "$host : " . $host_info{$host}{"memory"}{"total"} . "\n";
	if ( $xenhosts{$_}{'session'} ){
#	    print int($host_info{$host}{"memory"}{"total"}) . " > " .  $maxmem . "\n";
	    if ( int($host_info{$host}{"memory"}{"total"}) > $maxmem ){

		$maxmem = int($host_info{$host}{"memory"}{"total"});
#		print "setting $maxmem from $host\n";
	    }
	}
    }

    open (MAIN,">$output_dir/index.html") or die "FATAL:Could not open $output_dir/index.html: $!\n"; 

    print MAIN "<HTML>\n";
    print MAIN "<HEAD>\n";
    print MAIN "<meta http-equiv='Refresh' content='5; url=index.html'>\n";
    print MAIN "</HEAD>\n";
    print MAIN "<BODY>\n";
    print MAIN scalar localtime;
    print MAIN "<h3>Servers</h3>\n";
    print MAIN "<TABLE>\n";
    
    print MAIN "<TR><TD>Hostname</TD><TD>Memory (Free/Total, %Free)</TD><TD>Memory usage bar</TD><TD>VMs</TD><TD>Projects</TD></TR>\n";
    
    foreach my $host (@DAEMON_STATUS_QUERY_HOSTS){
#	print "host: $host\n";
	my $hostname = $host;
	$hostname =~ s/^([^\.]*)(\..*)$/$1/g;
	print MAIN "<TR>\n";
	# Hostname
      	print MAIN "<td>";
	if ( $xenhosts{$host}{'session'} ){
	    print MAIN "<div style='color: green;'>$hostname</div>";
	} else {
	    print MAIN "<div style='color: red;'>$hostname</div>";
	}
	print MAIN "</td>\n";

	# Memory
	print MAIN "<td>";
	if ( $host_info{$hostname}{"memory"}{"total"} ){
	    print MAIN int( $host_info{$hostname}{"memory"}{"free"}) . "/" . int($host_info{$hostname}{"memory"}{"total"}) . ",  " . int( (int($host_info{$hostname}{"memory"}{"free"}) / int($host_info{$hostname}{"memory"}{"total"})) * 100 ) . "%";
	print MAIN "<td>\n";
	    
	print MAIN "<table>\n";
	print MAIN "<tr style=''>\n";
	print MAIN "<td style='height: 10px;width: " . ((( int($host_info{$hostname}{"memory"}{"total"}) - int($host_info{$hostname}{"memory"}{"free"})) / $maxmem) * 100)  . "px; background-color: red'> </td>";
	print MAIN "<td style='width: " . ((int($host_info{$hostname}{"memory"}{"total"}) / $maxmem * 100) - ((( int($host_info{$hostname}{"memory"}{"total"}) - int($host_info{$hostname}{"memory"}{"free"})) / $maxmem) * 100))  . "px; background-color: green'> </td>";
#	print MAIN "<td>padding</td>\n";
	print MAIN "</tr>\n";
	print MAIN "</table>\n";
	print MAIN "</td>\n";
	} else {
	    print MAIN "Not available"
	}
	print MAIN "</td>\n";

	# Number of VMs
	my @vms = keys %{$host_info{$hostname}{"vms"}};
	print MAIN "<td>\n";
	print MAIN ((@vms) - 1);
	print MAIN "</td>\n";
	# Number of Projects. 
	print MAIN "<td>\n";
	my %projects;
	foreach (@vms){
	    next if $_ eq "Domain-0";
	    $_ =~ /(\S+)\.(\S+)/;
	    print "Pushing project: $2\n";
	    $projects{$2} = 1;
	    $running_projects{$2} = 1;
	}
	print MAIN (scalar (keys %projects));
	print MAIN "</td>\n";	
	print MAIN "<TR>\n";	
    }
    print MAIN "<TR><td>Total:</td></tr>\n"; 
    print MAIN "</TABLE>\n";

    # The table for all the projects
    
    print MAIN "<h3>Projects</h3>\n";
    print MAIN "<table border=0 style=''>\n";
    print MAIN "<div style='padding-right: 10px'>\n"; 
    foreach my $project (keys %running_projects){
	print MAIN "<TR style='text-allign: top;'>\n";
	print MAIN "<TD style='text-allign: top;'><b>$project</b></TD>\n";
	$DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/$project.mln");


	print MAIN "<b><TD>Name</TD><TD>Service host</TD><TD>Memory</TD><TD>Type</TD></b></TR>";
	foreach my $host ( getHosts()){
	    my $service_host = getScalar("/host/$host/service_host");
	    my $hostname = $service_host;
	    $hostname =~ s/^([^\.]*)(\..*)$/$1/g;

	    print MAIN "<tr><td>$project</td>\n";	    
	    print "$hostname , 'vms', " . $host . "." . $project . "\n";
	    if ( $host_info{$hostname}{'vms'}{$host . "." . $project} ){
		print MAIN "<td style='color: green'>$host</td>";
	    } else {
		print MAIN "<td style='color: red'>$host</td>";
	    }
	    
	    if ( $xenhosts{$service_host}{'session'} ) {
		print MAIN "<td style='color: green'>$service_host</td>";
	    } else {
		print MAIN "<td style='color: red'>$service_host</td>";
	    }
	    if ( $host_info{$hostname}{'vms'}{$host . "." . $project} {'memory'}{'dynamic_max'} ) {
		print MAIN "<td><div style='text-allign: right;'>" . ($host_info{$hostname}{'vms'}{$host . "." . $project} {'memory'}{'dynamic_max'} / 1024 / 1024) . "</div></td>";
	    } else {
		print MAIN "<td>n/a</td>";
	    }
	    		print MAIN "<td><div style='text-allign: right;'>" . $host_info{$hostname}{'vms'}{$host . "." . $project} {'type'} . "</div></td>";
	    print MAIN "</tr>\n";
	}  

	print MAIN "</TR>\n";
	
    }
    print MAIN "</div>\n";
    print MAIN "</table>\n";
    print MAIN "</BODY>\n</HTML>\n";
    close(MAIN);
      
    
}

sub validate_response
{
    my ($result_ref) = @_;
    if ($result_ref->{'Status'} eq "Success")
    {
		return $result_ref->{'Value'};
    }
# Xen 3.0.4 Error msg:
#
# $VAR1 = {
#          'faultString' => 'method "host.get_metrics" is not supported',
#          'faultCode' => '1'
#        };
    else
    {
	# status = Failure !
#		print Dumper($result_ref);
#		die ("xmlrpc failed! ErrorDescription: $result_ref->{'ErrorDescription'}[1] -> $result_ref->{'ErrorDescription'}[0]");
		print "xmlrpc failed! ErrorDescription: $result_ref->{'ErrorDescription'}[1] -> $result_ref->{'ErrorDescription'}[0]\n";
	return 0;
    }
}
    
sub get_host_cpu_utilisation
{
    my ($xen, $session, $host_name, $host_ref) = @_;
    my $host_cpu_ref = validate_response($xen->simple_request("host.get_host_CPUs", $session, $host_ref));
    foreach (@$host_cpu_ref)
    {
		my $host_cpu_utilisation = validate_response($xen->simple_request("host_cpu.get_utilisation", $session, $_));
		$host_info{$host_name}{'cpus'}{$_} = $host_cpu_utilisation;
#		print "     CPUiNFO: $host_cpu_utilisation\n";
    }
}

sub get_host_pif_utilisation
{
    my ($xen, $session, $host_name, $host_ref) = @_;
    
# This method isnt implemented yet it seems so using PIF.get_all for now..
# This will break when xen is made cluster aware..
#	my $host_pif_ref = validate_response($xen->simple_request("host.get_PIFs", $session, $host_ref));
    my $host_pif_ref = validate_response($xen->simple_request("PIF.get_all", $session));
    foreach (@$host_pif_ref)
    {
		my $host_pif_device = validate_response($xen->simple_request("PIF.get_device", $session, $_));
		my $host_pif_metrics_ref = validate_response($xen->simple_request("PIF.get_metrics", $session, $_));
	
# Whats the best solution performancewise?
# Collecting stats from get_records, or pulling individually?

#		my $host_pif_record = validate_response($xen->simple_request("PIF_metrics.get_record", $session, $host_pif_metrics_ref));
#		my $host_pif_io_read = $host_pif_record->{'io_read_kbs'};
#		my $host_pif_io_write = $host_pif_record->{'io_write_kbs'};
		my $host_pif_io_read = validate_response($xen->simple_request("PIF_metrics.get_io_read_kbs", $session, $host_pif_metrics_ref));
		my $host_pif_io_write = validate_response($xen->simple_request("PIF_metrics.get_io_write_kbs", $session, $host_pif_metrics_ref));

		$host_info{$host_name}{'pifs'}{$host_pif_device} = {'read' => $host_pif_io_read, 'write' => $host_pif_io_write};
#		print "     PiFiNFO: $host_pif_device READ: $host_pif_io_read - WRITE: $host_pif_io_write\n";

#		$host_info{$host_name}{'pifs'}{$host_pif_device}{'read'} = $host_pif_io_read;
#		$host_info{$host_name}{'pifs'}{$host_pif_device}{'write'} = $host_pif_io_write;
	}
}

sub get_host_mem_utilisation
{
	my ($xen, $session, $host_name, $host_ref) = @_;
	my $host_metrics_ref = validate_response($xen->simple_request("host.get_metrics", $session, $host_ref)); 
	my $host_mem_total =  validate_response($xen->simple_request("host_metrics.get_memory_total", $session, $host_metrics_ref)) / 1024 / 1024;
	my $host_mem_free =  validate_response($xen->simple_request("host_metrics.get_memory_free", $session, $host_metrics_ref)) / 1024 / 1024;
	$host_info{$host_name}{'memory'} = {'total' => $host_mem_total, 'free' => $host_mem_free};
#	print "     MEMiNFO: Total: $host_mem_total MB - Free: $host_mem_free MB\n";
}

sub get_vm_mem_info
{
	my ($xen, $session, $host_name, $vm_ref, $vm_name_label) = @_;
	my $vm_mem_stat_max = validate_response($xen->simple_request("VM.get_memory_static_max",$session,$vm_ref));
	my $vm_mem_stat_min = validate_response($xen->simple_request("VM.get_memory_static_min",$session,$vm_ref));
	my $vm_mem_dyn_max = validate_response($xen->simple_request("VM.get_memory_dynamic_max",$session,$vm_ref));
	my $vm_mem_dyn_min = validate_response($xen->simple_request("VM.get_memory_dynamic_min",$session,$vm_ref));

	# not implemented yet.. We'll do this at the same time as getting cpu utilisation
	# in the get_vm_metrics sub instead..
	#my $vm_metrics_ref = validate_response($xen->simple_request("VM.get_metrics",$session,$vm_ref));
	#my $vm_mem_actual = validate_response($xen->simple_request("VM_metrics.get_memory_actual",$session,$vm_metrics_ref));

	$host_info{$host_name}{'vms'}{$vm_name_label}{'memory'} = {'static_max' => $vm_mem_stat_max,
								  'static_min' => $vm_mem_stat_min,
								  'dynamic_max' => $vm_mem_dyn_max,
								  'dynamic_min' => $vm_mem_dyn_min};

	# xm list uses the dynamic min var as far as i can tell.. or?
	# Lets print the memactual info instead of this... I'll do that in the get_vm_metrics sub instead..
	# print "  |- MEMiNFO: Dynamic Min: $vm_mem_dyn_min - Actually in use: $vm_mem_actual\n";
}

sub get_vm_metrics
{
	my ($xen, $session, $host_name, $vm_ref, $vm_name_label) = @_;
	my $vm_metrics_ref = validate_response($xen->simple_request("VM.get_metrics",$session,$vm_ref));
	
	my %vm_vcpu_utilisation = %{validate_response($xen->simple_request("VM_metrics.get_VCPUs_utilisation",$session,$vm_metrics_ref))};
	for my $tempcpu (keys %vm_vcpu_utilisation)
	{
#		print "  |- CPUiNFO: $tempcpu - $vm_vcpu_utilisation{$tempcpu}\n";
		$host_info{$host_name}{'vms'}{$vm_name_label}{'vcpus'} = {$tempcpu => $vm_vcpu_utilisation{$tempcpu}};
	}
	my $vm_mem_actual = validate_response($xen->simple_request("VM_metrics.get_memory_actual",$session,$vm_metrics_ref)) / 1024 / 1024;
	$host_info{$host_name}{'vms'}{$vm_name_label}{'memory'}{'actual'} = "$vm_mem_actual";
#	print "  |- MEMiNFO: Actually in use: $vm_mem_actual MB\n";
}

sub get_vm_vif_utilisation
{
	my ($xen, $session, $host_name, $vm_ref, $vm_name_label) = @_;
	my $vm_vifs = validate_response($xen->simple_request("VM.get_VIFs",$session,$vm_ref));
	foreach (@$vm_vifs)
	{
		my $vif_device = validate_response($xen->simple_request("VIF.get_device",$session,$_));
		my $vif_io_read = validate_response($xen->simple_request("VIF_metrics.get_io_read_kbs", $session, $_));
		my $vif_io_write = validate_response($xen->simple_request("VIF_metrics.get_io_write_kbs", $session, $_));
		$host_info{$host_name}{'vms'}{$vm_name_label}{'vifs'}{$vif_device} = {'read' => $vif_io_read, 'write' => $vif_io_write};
#		print "  |- ViFiNFO: $vif_device READ: $vif_io_read - WRITE: $vif_io_write\n";
	}
}

sub get_vm_vbd_utilisation
{
	my ($xen, $session, $host_name, $vm_ref, $vm_name_label) = @_;
	my $vm_vbds = validate_response($xen->simple_request("VM.get_VBDs",$session,$vm_ref));
	foreach (@$vm_vbds)
	{
		my $vbd_device = validate_response($xen->simple_request("VBD.get_device",$session,$_));
		my $vbd_io_read = validate_response($xen->simple_request("VBD_metrics.get_io_read_kbs", $session, $_));
		my $vbd_io_write = validate_response($xen->simple_request("VBD_metrics.get_io_write_kbs", $session, $_));
		$host_info{$host_name}{'vms'}{$vm_name_label}{'vbds'}{$vbd_device} = {'read' => $vbd_io_read, 'write' => $vbd_io_write};
#		print "  |- VBDiNFO: $vbd_device READ: $vbd_io_read - WRITE: $vbd_io_write\n";
	}
}

sub high_load_on_host
{
	my ($hostname) = @_;
#	print "@_\n";
	my $troublemaker = "";
	my $troublemakerload = 0;
	foreach my $hostname (keys %host_info)
	{
		my %vms = %{$host_info{$hostname}{'vms'}};
		foreach my $vm (keys %vms)
		{
			my $temp_total_cpu_load = 0;
			foreach my $vm_cpu (keys %{$host_info{$hostname}{'vms'}->{$vm}{'vcpus'}})
			{
				$temp_total_cpu_load += $host_info{$hostname}{'vms'}->{$vm}{'vcpus'}->{$vm_cpu};
#				print "$vm $temp_total_cpu_load $host_info{$hostname}{'vms'}->{$vm}{'vcpus'}->{$vm_cpu}\n";
			}
			
			my $cpu_number = keys %{$host_info{$hostname}{'cpus'}};
#			print "$temp_total_cpu_load $cpu_number $troublemakerload\n";
			$temp_total_cpu_load /= $cpu_number;
#			print "$temp_total_cpu_load $cpu_number $troublemakerload\n";
			if($temp_total_cpu_load gt $troublemakerload)
			{
				print "Looks like $vm has higher load than $troublemaker with $temp_total_cpu_load which is higher than $troublemakerload..\n";
				$troublemaker = $vm;
				$troublemakerload = $temp_total_cpu_load;
			}
		}
#	print Dumper(%host_info);
	}
	if ("$troublemaker" eq "Domain-0")
	{
		print "Dom0 is using $troublemakerload, Lets evacuate all possible VMs..\n";
		evacuate_vms($hostname);
	}
	else
	{
		print "Troublemaker $troublemaker has cpu use of: $troublemakerload..\n";
		print "Didnt make any logic to move all except one, so in the mean time lets just move em all.. =)\n";
		evacuate_vms($hostname);
	}
}

sub get_vm_type
{
	my ($xen, $session, $host_name, $vm_ref, $vm_name_label) = @_;
	# not running response through validate_response() here to stop it from crashing..
	#
	# api docs says if this (following) field is set, its a HVM domain.
	my $vm_bootloader_results = $xen->simple_request("VM.get_HVM_boot_policy",$session,$vm_ref);
	if ("$vm_bootloader_results->{'Status'}" eq "Success")
	{
		if ("$vm_bootloader_results->{'Value'}" ne "")
		{
			$host_info{$host_name}{'vms'}{$vm_name_label}{'type'} = "HVM";
		}
		else
		{
			$host_info{$host_name}{'vms'}{$vm_name_label}{'type'} = "PV";
		}
	}
	else
	{
		# However, xen 3.0.4 doest support this part of the api, so afaik I can get the difference with: 
		my $vm_pv_kernel_results = $xen->simple_request("VM.get_PV_kernel",$session,$vm_ref);
		# which is something like:
		# 'PV_kernel': '/boot/vmlinuz-2.6.18-xen',
		# or
		# 'PV_kernel': '/usr/lib/xen/boot/hvmloader',
		if ("$vm_pv_kernel_results->{'Value'}" =~ m/hvm/i)
		{
			$host_info{$host_name}{'vms'}{$vm_name_label}{'type'} = "HVM";
		}
		else
		{
			$host_info{$host_name}{'vms'}{$vm_name_label}{'type'} = "PV";
		}
	}
	
#	print "  |- VBDiNFO: $vbd_device READ: $vbd_io_read - WRITE: $vbd_io_write\n";
}

sub get_host_free_mem
{
	my ($hostname) = @_;
	return $host_info{$hostname}{'memory'}{'free'};
}

sub evacuate_vms
{
	my ($hostname) = @_;
	my $num_chunks_on_this_host = 0;
	my %projects_to_upgrade;
	my $migration_success;
	print "Evacuating all VMs from $hostname..\n";
	my @possible_targets = get_low_cpu_hosts();
	print "We found @possible_targets possible target hosts with less cpu usage than $host_cpu_utilisation_low..\n";
	
	foreach my $target (@possible_targets)
	{
		unless ("$migration_success" eq "YES!")
		{
			my $dest_free_mem = get_host_free_mem($xenhosts{$target}{'hostname'});
		
			# Still under development... !!
			# Will only migrate project "ft1" away from the host atm..
			# Depending on which policy we want to use for "spreading" VMs we need to loop around all VMs
			# That should be migrated off the "high-load host"..
			#
			# A function for gathering the VMs grouped up as mln projects to loop around ??
			#
			# Need to make sure that projects containing HVM VMs are not (live)migrated!
			#
			my %projects = get_projectnames_from_vms();
			foreach my $project (keys %projects)
			{
				my $chunk_array_ref = $chunks{$project};
				foreach my $chunk (@$chunk_array_ref)
				{
					my $service_host_name = $chunk->{'servicehostname'};
					$num_chunks_on_this_host++ if ("$service_host_name" eq "$hostname");
					
					#print "$service_host_name\n";
					#die;
					my $total_mem_on_source_chunk = 0;
					my $vm_array_ref = $chunk->{'hosts'};
					foreach my $vm (@$vm_array_ref)
					{
						if ("$service_host_name" eq "$hostname")
						{
							$total_mem_on_source_chunk += $host_info{$service_host_name}{'vms'}->{"${vm}.${project}"}{'memory'}{'dynamic_min'};
#							print "$hostname $vm ".$total_mem_on_source_chunk." += ".$host_info{$service_host_name}{'vms'}->{"${vm}.${project}"}{'memory'}{'dynamic_min'}."\n";
						}
					}
					if ($total_mem_on_source_chunk < $dest_free_mem)
					{
						if ("$service_host_name" eq "$hostname")
						{
							print "..Found suitable target: $target.. With $dest_free_mem MB free mem.. (we need $total_mem_on_source_chunk MB..)\n";
							update_mln_project($chunk,$project,$target);
							print "reconfigure chunk completed..\n";
							$migration_success = "YES!";
							$chunk->{'servicehostname'} = $target;
							$projects_to_upgrade{$project} = 1;
							$dest_free_mem -= $total_mem_on_source_chunk;
							print "$hostname $host_info{$hostname}{'memory'}{'free'} $dest_free_mem\n";
							$host_info{$xenhosts{$target}{'hostname'}}{'memory'}{'free'} = $dest_free_mem; 
							print "$xenhosts{$target}{'hostname'} $host_info{$xenhosts{$target}{'hostname'}}{'memory'}{'free'} $dest_free_mem\n";
							#last;
						}
						else
						{
#							print "$service_host_name ne $hostname\n";
						}

					}
					else
					{
						$migration_success = "DOH!";
						print "DOH! We can't migrate chunk\n";
						print Dumper($chunk->{'hosts'});
						print ".... from $hostname to $target as this host only has $dest_free_mem MB and we need $total_mem_on_source_chunk MB.. :(\n";
					}
				}
			}
		}
	}
	
	if ($num_chunks_on_this_host > 0)
	{
		unless ("$migration_success" eq "YES!")
		{
			if ($host_cpu_utilisation_low == $host_cpu_utilisation_high)
			{
				print "We reached the host_cpu_utilisation_high ($host_cpu_utilisation_high) without finding suitable targets for migration..\nYou might want to change this to a higher value..\n";
			}
			else
			{
				print "Migration pas possible :(\n";
				$host_cpu_utilisation_low += 0.1;
				evacuate_vms($hostname);
			}
		}
		else
		{
			foreach (keys %projects_to_upgrade)
			{
				upgrade_mln_project($_);
			}
		}
	}
	else
	{
		my $vm_number = keys %{$host_info{$hostname}{'vms'}};
		print "According to our .mln files we have _NO_ hosts/switches running on $hostname!!\n";
		print "BUT according to the API we have $vm_number VMs there.. DOH!\n";
	}
}

sub split_mln_project_vm
{
	# vm names are given as VM_name.project_name
	# We need that project_name for mln's "migrate-total-project"
	my ($vm_name) = @_;
	$vm_name =~ m/^(.+)\.(.+)$/;
	return ($1,$2) unless (! $2);
	die("Something went wrong, I could'nt determine the mln projectname from $vm_name.. :( [1:$1 - 2:$2]\n");
}

sub update_mln_project
{
	my ($chunk_ref,$mln_project_name,$recieving_host_ip) = @_;
	#print Dumper($chunk_ref->{'hosts'});
	#die;
  	$DATA_ROOT = buildDataTree("${mln_files_dir}/${mln_project_name}.mln");

	my @hosts = @{$chunk_ref->{'hosts'}};
	foreach my $host (@hosts)
	{
#		my @mln1 = ("$mln", "setScalar", "-f", "$mln_files_dir/$mln_project_name.mln", "-k", "/host/$host/service_host", "-v", "$recieving_host_ip");
#		print "running cmd: @mln1\n";
#	  	system(@mln1);
	  	#
	  	# Do we have to do this as well? or could we have done it instead?
		#
		# '   ' will not expand variable names. :)
		# i noticed a /host/$host/service_host block in the output. :)
	  	setScalar("/host/$host/service_host",$recieving_host_ip);
		# this output seems to be correct, though. 
		# did you see it on the output? The were all set to 13, i think. 
		# was that correct? could be yes, it chooses from node1 and node3
		# ok, then the problem is related to writing the changes down again. 
		out("Service_host on $host set to " . getScalar("/host/$host/service_host") ."\n");
#right? ja
	}
	foreach my $switch (@{$chunk_ref->{'switches'}})
	{
#		my @mln1 = ("$mln", "setScalar", "-f", "$mln_files_dir/$mln_project_name.mln", "-k", "/switch/$switch/service_host", "-v", "$recieving_host_ip");
#		print "running cmd: @mln1\n";
#	  	system(@mln1);
## fikse dette...
#alts  kalle cmd fra inni mln da.. 
	  	#
	  	# Do we have to do this as well?
	  	#$DATA_ROOT = buildDataTree("${mln_files_dir}/${mln_project_name}.mln");
		#
	  	  setScalar("/switch/$switch/service_host",$recieving_host_ip);
		out("Service host on $switch set to: " . getScalar("/switch/$switch/service_host") . "\n");
	}
	# heraa vi "save" forandringene. de blir ikke syncet med filen.
	out("this is our local copy\n");
#	printBlock($DATA_ROOT);
	saveConfig("${mln_files_dir}/${mln_project_name}.mln");
	out("Config saved:\n");
	# this might be a good idea right now
	# we will delete it as soon as we know it will work :)
	# ok? ser snn ut :)
#	system("cat ${mln_files_dir}/${mln_project_name}.mln");
	#  i think we should test at this point.
}

sub upgrade_mln_project
{
	my ($mln_project_name) = @_;
	
#	my @mln2 = ("$mln", "upgrade", "-f", "$mln_files_dir/$mln_project_name.mln", "-r");
#	print "running cmd: @mln2\n";

	# take copies of the file descriptors
#	open(OLDOUT, ">&STDOUT");
#	open(OLDERR, ">&STDERR");
	# redirect stdout and stderr
#	open(STDOUT, ">/dev/null")  			or die "Can't redirect stdout: $!";
#	open(STDERR, ">&STDOUT")            or die "Can't dup stdout: $!";

	# run program
	# system(@mln2);

# da ser vi hvertfall hva som skjer :)
	# jeg kunne ikke se denne linjen i output over:
	out("Invoking local upgrade method\n");

	# denne metoden bare spyttet ut "Done", saa kanskje det er noe
	# den mangler. 
	# jeg legger paa litt debug output og saa faar vi se
	# ok? :)
	
	# upgradeMLNproject($opt{'f'},$opt{l},$REMOVE,$VERBOSE,$DEBUG,$opt{s},$SPAWNED_REMOTELY);
	# upgradeMLNproject(s1.mln,,,0,0,,)
	upgradeMLNproject("$mln_files_dir/$mln_project_name.mln","","1","0","","","");
	#upgradeMLNproject("$mln_files_dir/$mln_project_name.mln","","1","","","",0);

# nei fordi output var > /dev/null, men kommenterte den redirecten ut n.. 
# ah. da boer vi proeve en gang til, da? jepp :)

   # close the redirected filehandles
#	close(STDOUT)                       or die "Can't close STDOUT: $!";
#	close(STDERR)                       or die "Can't close STDERR: $!";
	# restore stdout and stderr
#	open(STDERR, ">&OLDERR")            or die "Can't restore stderr: $!";
#	open(STDOUT, ">&OLDOUT")            or die "Can't restore stdout: $!";
	# avoid leaks by closing the independent copies
#	close(OLDOUT)                       or die "Can't close OLDOUT: $!";
#	close(OLDERR) 								or die "Can't close OLDERR: $!";
}

sub get_low_cpu_hosts
{
	my @hosts = ();
	my $host_cpu_utilisation_low = $host_cpu_utilisation_low;
	while ((@hosts < 1) && ($host_cpu_utilisation_low < $host_cpu_utilisation_high))
	{
		foreach my $hostname (sort keys %host_info)
		{
			# decide which node is most suitable for recieving more VMs..
			if(get_total_host_cpu_utilisation($hostname) < $host_cpu_utilisation_low)
			{
				push(@hosts,$host_info{$hostname}{'ip'});
			}
		}
		$host_cpu_utilisation_low += 0.1;
	}
	return @hosts;
}

sub get_total_host_cpu_utilisation
{
	my ($host) = @_;
	my $host_cpus = $host_info{$host}{'cpus'};
	# will this do the trick when host has multiple cpus?
	my $total_utilisation = 0;
	foreach my $temp_cpu_ref (keys %$host_cpus)
	{
		$total_utilisation += $host_cpus->{$temp_cpu_ref};
	}
	my $cpu_number = keys %$host_cpus;
    if ( $cpu_number > 0 ){
	$total_utilisation /= $cpu_number;
    }
	return $total_utilisation;
}

sub get_projectnames_from_vms
{
	my %projects;
   foreach (keys %all_vms)
   {
		$_ =~ s/.*?\.(\S+)$/$1/;
		$projects{$_} = 1;
   }
   return %projects;
}

sub build_chunk_hash
{
#    print "build chunk hash called\n";
    my (%vms) = @_;
    
    printHash(\%vms);
  	#print Dumper(%vms);
  	#die;
   # get all project names
   my %projects;
    foreach my $proj (keys %vms){
	$proj =~ s/^(.*)\.//;
	$projects{$proj} = 1;
    }

#   print Dumper(%projects);
#   die;
    
    
   foreach my $project (keys %projects)
   {
#       print "checking project $project\n";
   	#print Dumper(%vms);
		my @project_chunks;

		# create data structure for project
		$DATA_ROOT = buildDataTree("$mln_files_dir/${project}.mln");
		assignHostsToSwitches();
#		print "Searching project $project\n";
		my @hosts = getHosts();
#print "test\n";
		foreach my $host (@hosts)
		{
#			print "----host $host -----\n";
			next unless $vms{"$host.$project"};
#			print "--- $host.$project ---\n";
		    
		    my @switches_in_chunk;
		    my @vms_in_chunk;
		    
		    # print "\tSearching host $host\n";
		    delete($vms{"$host.$project"});
		    push(@vms_in_chunk,"$host");
		   # analyze each host in the project
		   # we have three choices:
		   # $scalar = getScalar("/host/bla/bla");
		   # @array = getArray("/switch/foobar/hosts");
		   # %hash = getHash("/host/foobar/network"); maybe better
		   my %nics = getHash("/host/$host/network");
		   foreach my $nic (keys %nics)
		   {
#				print "\t\tFound NIC $nic\n";
				# check if the nic is connected to a switch
				if ( $nics{$nic}{"switch"})
				{
					my $switch = $nics{$nic}{"switch"};
					push(@switches_in_chunk,$switch);
					
					#print "\t\t\tNIC $nic is conencted to " . $switch ."\n";
					my %hosts_on_lan = getHash("/switch/$switch/hosts");
					foreach my $host_on_lan (keys %hosts_on_lan)
					{
						get_chunk_tree_from_vm($host_on_lan,$project,$switch,\%vms,\@switches_in_chunk,\@vms_in_chunk);
					}
				}
			}
			my $servicehostip = getScalar("/host/$host/service_host");
			push(@project_chunks,{'hosts' => \@vms_in_chunk,
						 'switches' => \@switches_in_chunk,
						 'servicehostip' => $servicehostip,
						 'servicehostname' => $xenhosts{$servicehostip}{'hostname'}
					     });
#print "vmsinchunk\n";
#			print Dumper(@vms_in_chunk);
#print "switchesinchunk\n";
#			print Dumper(@switches_in_chunk);
#print "projectchunks\n";
#			print Dumper(@project_chunks);
		}
		$chunks{$project} = \@project_chunks;
		#print Dumper(%vms);
	}
#	print "chunks\n";
#	print Dumper(%chunks);
}

sub get_chunk_tree_from_vm
{
	my ($vm,$project,$switch,$list_of_vms_ref,$switches_in_chunk_ref,$vms_in_chunk_ref) = @_;
	if ( $list_of_vms_ref->{"$vm.$project"} )
	{
		#print "\t\t\t\tHost $vm is connected to switch " . $switch ."\n";
		delete($list_of_vms_ref->{"$vm.$project"});
		push(@$vms_in_chunk_ref,"$vm");
		
		my %nics = getHash("/host/$vm/network");
	   foreach my $nic (keys %nics)
	   {
			#print "\t\tFound NIC $nic\n";
			# check if the nic is connected to a switch
			if ( $nics{$nic}{'switch'} && ($nics{$nic}{'switch'} ne $switch))
			{
				my $switch = $nics{$nic}{"switch"};
				push(@$switches_in_chunk_ref,$switch);
				
				#print "\t\t\tNIC $nic is conencted to " . $switch ."\n";
				my %hosts_on_lan = getHash("/switch/$switch/hosts");
				foreach my $host_on_lan (keys %hosts_on_lan)
				{
					get_chunk_tree_from_vm($host_on_lan,$project,$switch,$list_of_vms_ref,$switches_in_chunk_ref,$vms_in_chunk_ref);
				}
			}
		}
	}
	else
	{
		# This means we have already mentioned this VM in this chunk already!
		# Skipping!
		# print "Host $vm have already been included in this chunk.. Skipping!\n";
	}
}

sub get_complete_info
{	
#	my %all_vms;
	foreach my $xenhost (sort keys %xenhosts)
	{
#	    print "fetching  info from $xenhost\n"; 
	    next unless $xenhosts{$xenhost}{'session'};

	    my $xen = $xenhosts{$xenhost}{'xen'};
		my $session = $xenhosts{$xenhost}{'session'};
#		print "_______________________\n## $xenhost ##\n-----------------------\n";
	
		my $host_ref = validate_response($xen->simple_request("session.get_this_host", $session, $session));
		
		my $host_name = validate_response($xen->simple_request("host.get_name_label", $session, $host_ref));
		$xenhosts{$xenhost}{'hostname'} = $host_name;
		$host_info{$host_name}{'ip'} = $xenhost;
		
		get_host_cpu_utilisation($xen, $session, $host_name, $host_ref);

		get_host_mem_utilisation($xen, $session, $host_name, $host_ref);
	
		get_host_pif_utilisation($xen, $session, $host_name, $host_ref);
	
	
		my $all_vm_refs = validate_response($xen->simple_request("host.get_resident_VMs",$session, $host_ref));
		
		foreach my $vm_ref (@$all_vm_refs)
		{
			my $vm_name_label = validate_response($xen->simple_request("VM.get_name_label",$session,$vm_ref));
			get_vm_type($xen,$session,$host_name,$vm_ref,$vm_name_label);
			
			my $vm_id = validate_response($xen->simple_request("VM.get_domid",$session,$vm_ref));

#			print "vm: $vm_id\t$vm_name_label\ttype: $host_info{$host_name}{'vms'}->{$vm_name_label}{'type'}\n";
			
			# vm_metrics includes both mem_actual & cpu utilisation
			# So we'll add all stats found in that class in one go..
			get_vm_metrics($xen,$session,$host_name,$vm_ref,$vm_name_label);
			
#			get_vm_cpu_utilisation($xen,$session,$host_name,$vm_ref,$vm_name_label);

			# all other mem stats are added seperately..
			# This might not be needed at all as xen doesnt have functionality to
			# resize mem for a VM atm (afaik)
			get_vm_mem_info($xen,$session,$host_name,$vm_ref,$vm_name_label);
	
			get_vm_vif_utilisation($xen,$session,$host_name,$vm_ref,$vm_name_label);
			
			get_vm_vbd_utilisation($xen,$session,$host_name,$vm_ref,$vm_name_label);
			
			$all_vms{$vm_name_label} = "1" unless ("$vm_name_label" eq "Domain-0");
		}
#		print "\n";
	}
	
	# We don't really need to do this unless cpu utilisation is above configured threshold
	# Not doing it would save some execution time..
	build_chunk_hash(%all_vms);

    
#    printHash(\%xenhosts);
}

    
sub apiconnect
{
    foreach my $xenhost (@DAEMON_STATUS_QUERY_HOSTS) 
    {
	# we check first if the host is allready up and we got a session:
	if ( $xenhosts{$xenhost}{"session"} ){
	    print "checking connection for $xenhost: ";
	    my $xen = $xenhosts{$xenhost}{"xen"};
	    my $host_ref = validate_response($xen->simple_request("session.get_this_host", $xenhosts{$xenhost}{"session"}, $xenhosts{$xenhost}{"session"}));
	    if ( not $host_ref ){
		print "Lost connection to: $xenhost\n";
		$xenhosts{$xenhost}{"session"} = "";
	    } else {
		print "Up\n";
	    }
	}
	
	
	if ( not $xenhosts{$xenhost}{"session"} ){
	    print "connecting to $xenhost\n";
	    my $xen = RPC::XML::Client->new("http://$xenhost:9363");
	    my $ua = $xen->useragent();
	    $ua->timeout(3);
	    my $session = $xen->simple_request("session.login_with_password", "user","");
	    if (! $session)
	    {
		print "Can't connect to $xenhost :(\n";
		$xenhosts{$xenhost} = {'xen' => $xen, 'session' => ""};
	    }
	    else
		{
#			print Dumper(%xenhosts);
#			$xenhosts{$xenhost} = {'xen' => $xen, 'session' => $session->{'Value'}};
		    $xenhosts{$xenhost} = {'xen' => $xen, 'session' => $session->{'Value'}};
#		    			$xenhosts{$xenhost} = {'xen' => $xen, 'session' => "OK"};
#			print "Connected successfully to $xenhost..\nsession: $xenhosts{$xenhost}{'session'}\nxen: $xenhosts{$xenhost}{'xen'}\n";
		}
	}
    }
}



    
sub startMlnConsole {
    system("clear");
    print "[ MLN Console ] Enter VM name and project like this: vmname.project\n";
    print "> ";
    my $result = <STDIN>;
    chomp $result;
    $result =~ /(\S+)\.(\S+)/; 
    if ( $result =~ /[:;]|\.\./){
	sleep 2;
	exit 1;
    }
    my $vm = $1;
    my $project = $2;
#    print "VM: $1, project: $2";
#    print "checking: $PROJECT_PATH/$project/$project.mln\n";
    if ( stat("$PROJECT_PATH/$project/$project.mln")){
	
	$DATA_ROOT = buildDataTree("$PROJECT_PATH/$project/$project.mln");
	if ( getScalar("/host/$vm")){
	    if ( checkIfUp($vm,$project) ){
		my $domid = `xm domid "$vm.$project"`;
		chomp $domid;
		print "domid: $domid\n";
		my $running = `ps aux | grep \"/usr/lib/xen/bin/xenconsole $domid \"| grep -v grep`;
		print "result: $running\n";
		if ( $running =~ s/\S+ *(\d+) .*/$1/){
		    print "Another console session for that vm is still active. If you continue, the other session will be closed. Do you wish to continue?\n\ny/[N]: ";
		    $result = <STDIN>;
		    if ( $result =~ /y|Y|yes|Yes|Ja|ja|j|J/ ){
			kill($running);
		    } else {
			exit 0;
		    }
		}
		
		print "VM found, prepare to enter console. If you see no text right away, press [ENTER] a few times.\n\nPress [ENTER] when ready ...";
		<STDIN>;
		system("clear; /usr/sbin/xm console \"$vm\.$project\"");
		exit;
	    }
	} else {
	    print "Error: $vm not a vm in $project\n"; 
	}

	exit;
    }    
    
    
    
}
